{
  "version": 3,
  "sources": ["../../../../../../../src/cdk/collections/data-source.ts", "../../../../../../../src/cdk/collections/array-data-source.ts", "../../../../../../../src/cdk/collections/dispose-view-repeater-strategy.ts", "../../../../../../../src/cdk/collections/recycle-view-repeater-strategy.ts", "../../../../../../../src/cdk/collections/selection-model.ts", "../../../../../../../src/cdk/collections/unique-selection-dispatcher.ts", "../../../../../../../src/cdk/collections/view-repeater.ts", "../../../../../../../src/cdk/collections/collections_public_index.ts", "../../../../../../../src/cdk/scrolling/virtual-scroll-strategy.ts", "../../../../../../../src/cdk/scrolling/fixed-size-virtual-scroll.ts", "../../../../../../../src/cdk/scrolling/scroll-dispatcher.ts", "../../../../../../../src/cdk/scrolling/scrollable.ts", "../../../../../../../src/cdk/scrolling/viewport-ruler.ts", "../../../../../../../src/cdk/scrolling/virtual-scrollable.ts", "../../../../../../../src/cdk/scrolling/virtual-scroll-viewport.ts", "../../../../../../../src/cdk/scrolling/virtual-scroll-viewport.html", "../../../../../../../src/cdk/scrolling/virtual-for-of.ts", "../../../../../../../src/cdk/scrolling/virtual-scrollable-element.ts", "../../../../../../../src/cdk/scrolling/virtual-scrollable-window.ts", "../../../../../../../src/cdk/scrolling/scrolling-module.ts", "../../../../../../../src/cdk/scrolling/scrolling_public_index.ts", "../../../../../../../src/cdk/portal/portal-errors.ts", "../../../../../../../src/cdk/portal/portal.ts", "../../../../../../../src/cdk/portal/dom-portal-outlet.ts", "../../../../../../../src/cdk/portal/portal-directives.ts", "../../../../../../../src/cdk/portal/portal-injector.ts", "../../../../../../../src/cdk/portal/portal_public_index.ts", "../../../../../../../src/cdk/overlay/scroll/block-scroll-strategy.ts", "../../../../../../../src/cdk/overlay/scroll/scroll-strategy.ts", "../../../../../../../src/cdk/overlay/scroll/close-scroll-strategy.ts", "../../../../../../../src/cdk/overlay/scroll/noop-scroll-strategy.ts", "../../../../../../../src/cdk/overlay/position/scroll-clip.ts", "../../../../../../../src/cdk/overlay/scroll/reposition-scroll-strategy.ts", "../../../../../../../src/cdk/overlay/scroll/scroll-strategy-options.ts", "../../../../../../../src/cdk/overlay/overlay-config.ts", "../../../../../../../src/cdk/overlay/position/connected-position.ts", "../../../../../../../src/cdk/overlay/dispatchers/base-overlay-dispatcher.ts", "../../../../../../../src/cdk/overlay/dispatchers/overlay-keyboard-dispatcher.ts", "../../../../../../../src/cdk/overlay/dispatchers/overlay-outside-click-dispatcher.ts", "../../../../../../../src/cdk/overlay/overlay-container.ts", "../../../../../../../src/cdk/overlay/overlay-ref.ts", "../../../../../../../src/cdk/overlay/position/flexible-connected-position-strategy.ts", "../../../../../../../src/cdk/overlay/position/global-position-strategy.ts", "../../../../../../../src/cdk/overlay/position/overlay-position-builder.ts", "../../../../../../../src/cdk/overlay/overlay.ts", "../../../../../../../src/cdk/overlay/overlay-directives.ts", "../../../../../../../src/cdk/overlay/overlay-module.ts", "../../../../../../../src/cdk/overlay/fullscreen-overlay-container.ts", "../../../../../../../src/cdk/overlay/overlay_public_index.ts", "../../../../../../../src/material/button/button-base.ts", "../../../../../../../src/material/button/button.ts", "../../../../../../../src/material/button/button.html", "../../../../../../../src/material/button/fab.ts", "../../../../../../../src/material/button/icon-button.ts", "../../../../../../../src/material/button/icon-button.html", "../../../../../../../src/material/button/module.ts", "../../../../../../../src/material/button/button_public_index.ts", "../../../../../../../packages/forms/src/directives/control_value_accessor.ts", "../../../../../../../packages/forms/src/directives/checkbox_value_accessor.ts", "../../../../../../../packages/forms/src/directives/default_value_accessor.ts", "../../../../../../../packages/forms/src/validators.ts", "../../../../../../../packages/forms/src/directives/abstract_control_directive.ts", "../../../../../../../packages/forms/src/directives/control_container.ts", "../../../../../../../packages/forms/src/directives/ng_control.ts", "../../../../../../../packages/forms/src/directives/ng_control_status.ts", "../../../../../../../packages/forms/src/directives/error_examples.ts", "../../../../../../../packages/forms/src/directives/reactive_errors.ts", "../../../../../../../packages/forms/src/model/abstract_model.ts", "../../../../../../../packages/forms/src/model/form_group.ts", "../../../../../../../packages/forms/src/directives/shared.ts", "../../../../../../../packages/forms/src/directives/ng_form.ts", "../../../../../../../packages/forms/src/util.ts", "../../../../../../../packages/forms/src/model/form_control.ts", "../../../../../../../packages/forms/src/directives/abstract_form_group_directive.ts", "../../../../../../../packages/forms/src/directives/template_driven_errors.ts", "../../../../../../../packages/forms/src/directives/ng_model_group.ts", "../../../../../../../packages/forms/src/directives/ng_model.ts", "../../../../../../../packages/forms/src/directives/ng_no_validate_directive.ts", "../../../../../../../packages/forms/src/directives/number_value_accessor.ts", "../../../../../../../packages/forms/src/directives/radio_control_value_accessor.ts", "../../../../../../../packages/forms/src/directives/range_value_accessor.ts", "../../../../../../../packages/forms/src/directives/reactive_directives/form_control_directive.ts", "../../../../../../../packages/forms/src/directives/reactive_directives/form_group_directive.ts", "../../../../../../../packages/forms/src/directives/reactive_directives/form_group_name.ts", "../../../../../../../packages/forms/src/directives/reactive_directives/form_control_name.ts", "../../../../../../../packages/forms/src/directives/select_control_value_accessor.ts", "../../../../../../../packages/forms/src/directives/select_multiple_control_value_accessor.ts", "../../../../../../../packages/forms/src/directives/validators.ts", "../../../../../../../packages/forms/src/directives.ts", "../../../../../../../packages/forms/src/model/form_array.ts", "../../../../../../../packages/forms/src/form_builder.ts", "../../../../../../../packages/forms/src/version.ts", "../../../../../../../packages/forms/src/form_providers.ts", "../../../../../../../packages/forms/src/forms.ts", "../../../../../../../packages/forms/public_api.ts", "../../../../../../../packages/forms/index.ts", "../../../../../../../packages/forms/forms.ts", "../../../../../../../src/cdk/text-field/autofill.ts", "../../../../../../../src/cdk/text-field/autosize.ts", "../../../../../../../src/cdk/text-field/text-field-module.ts", "../../../../../../../src/cdk/text-field/text-field_public_index.ts", "../../../../../../../src/material/input/input-errors.ts", "../../../../../../../src/material/input/input-value-accessor.ts", "../../../../../../../src/material/input/input.ts", "../../../../../../../src/material/input/module.ts", "../../../../../../../src/material/input/input_public_index.ts", "../../../../../../../src/material/datepicker/datepicker-errors.ts", "../../../../../../../src/material/datepicker/datepicker-intl.ts", "../../../../../../../src/material/datepicker/calendar-body.ts", "../../../../../../../src/material/datepicker/calendar-body.html", "../../../../../../../src/material/datepicker/date-selection-model.ts", "../../../../../../../src/material/datepicker/date-range-selection-strategy.ts", "../../../../../../../src/material/datepicker/month-view.ts", "../../../../../../../src/material/datepicker/month-view.html", "../../../../../../../src/material/datepicker/multi-year-view.ts", "../../../../../../../src/material/datepicker/multi-year-view.html", "../../../../../../../src/material/datepicker/year-view.ts", "../../../../../../../src/material/datepicker/year-view.html", "../../../../../../../src/material/datepicker/calendar.ts", "../../../../../../../src/material/datepicker/calendar-header.html", "../../../../../../../src/material/datepicker/calendar.html", "../../../../../../../src/material/datepicker/datepicker-animations.ts", "../../../../../../../src/material/datepicker/datepicker-base.ts", "../../../../../../../src/material/datepicker/datepicker-content.html", "../../../../../../../src/material/datepicker/datepicker.ts", "../../../../../../../src/material/datepicker/datepicker-input-base.ts", "../../../../../../../src/material/datepicker/datepicker-input.ts", "../../../../../../../src/material/datepicker/datepicker-toggle.ts", "../../../../../../../src/material/datepicker/datepicker-toggle.html", "../../../../../../../src/material/datepicker/aria-accessible-name.ts", "../../../../../../../src/material/datepicker/date-range-input-parts.ts", "../../../../../../../src/material/datepicker/date-range-input.ts", "../../../../../../../src/material/datepicker/date-range-input.html", "../../../../../../../src/material/datepicker/date-range-picker.ts", "../../../../../../../src/material/datepicker/datepicker-actions.ts", "../../../../../../../src/material/datepicker/datepicker-module.ts", "../../../../../../../src/material/datepicker/datepicker_public_index.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConnectableObservable, Observable} from 'rxjs';\nimport {CollectionViewer} from './collection-viewer';\n\nexport abstract class DataSource<T> {\n  /**\n   * Connects a collection viewer (such as a data-table) to this data source. Note that\n   * the stream provided will be accessed during change detection and should not directly change\n   * values that are bound in template views.\n   * @param collectionViewer The component that exposes a view over the data provided by this\n   *     data source.\n   * @returns Observable that emits a new value when the data changes.\n   */\n  abstract connect(collectionViewer: CollectionViewer): Observable<readonly T[]>;\n\n  /**\n   * Disconnects a collection viewer (such as a data-table) from this data source. Can be used\n   * to perform any clean-up or tear-down operations when a view is being destroyed.\n   *\n   * @param collectionViewer The component that exposes a view over the data provided by this\n   *     data source.\n   */\n  abstract disconnect(collectionViewer: CollectionViewer): void;\n}\n\n/** Checks whether an object is a data source. */\nexport function isDataSource(value: any): value is DataSource<any> {\n  // Check if the value is a DataSource by observing if it has a connect function. Cannot\n  // be checked as an `instanceof DataSource` since people could create their own sources\n  // that match the interface, but don't extend DataSource. We also can't use `isObservable`\n  // here, because of some internal apps.\n  return value && typeof value.connect === 'function' && !(value instanceof ConnectableObservable);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable, isObservable, of as observableOf} from 'rxjs';\nimport {DataSource} from './data-source';\n\n/** DataSource wrapper for a native array. */\nexport class ArrayDataSource<T> extends DataSource<T> {\n  constructor(private _data: readonly T[] | Observable<readonly T[]>) {\n    super();\n  }\n\n  connect(): Observable<readonly T[]> {\n    return isObservable(this._data) ? this._data : observableOf(this._data);\n  }\n\n  disconnect() {}\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  EmbeddedViewRef,\n  IterableChangeRecord,\n  IterableChanges,\n  ViewContainerRef,\n} from '@angular/core';\nimport {\n  _ViewRepeater,\n  _ViewRepeaterItemChanged,\n  _ViewRepeaterItemContext,\n  _ViewRepeaterItemContextFactory,\n  _ViewRepeaterItemValueResolver,\n  _ViewRepeaterOperation,\n} from './view-repeater';\n\n/**\n * A repeater that destroys views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will always construct a new embedded view for each item.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nexport class _DisposeViewRepeaterStrategy<T, R, C extends _ViewRepeaterItemContext<T>>\n  implements _ViewRepeater<T, R, C>\n{\n  applyChanges(\n    changes: IterableChanges<R>,\n    viewContainerRef: ViewContainerRef,\n    itemContextFactory: _ViewRepeaterItemContextFactory<T, R, C>,\n    itemValueResolver: _ViewRepeaterItemValueResolver<T, R>,\n    itemViewChanged?: _ViewRepeaterItemChanged<R, C>,\n  ) {\n    changes.forEachOperation(\n      (\n        record: IterableChangeRecord<R>,\n        adjustedPreviousIndex: number | null,\n        currentIndex: number | null,\n      ) => {\n        let view: EmbeddedViewRef<C> | undefined;\n        let operation: _ViewRepeaterOperation;\n        if (record.previousIndex == null) {\n          const insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n          view = viewContainerRef.createEmbeddedView(\n            insertContext.templateRef,\n            insertContext.context,\n            insertContext.index,\n          );\n          operation = _ViewRepeaterOperation.INSERTED;\n        } else if (currentIndex == null) {\n          viewContainerRef.remove(adjustedPreviousIndex!);\n          operation = _ViewRepeaterOperation.REMOVED;\n        } else {\n          view = viewContainerRef.get(adjustedPreviousIndex!) as EmbeddedViewRef<C>;\n          viewContainerRef.move(view!, currentIndex);\n          operation = _ViewRepeaterOperation.MOVED;\n        }\n\n        if (itemViewChanged) {\n          itemViewChanged({\n            context: view?.context,\n            operation,\n            record,\n          });\n        }\n      },\n    );\n  }\n\n  detach() {}\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  EmbeddedViewRef,\n  IterableChangeRecord,\n  IterableChanges,\n  ViewContainerRef,\n} from '@angular/core';\nimport {\n  _ViewRepeater,\n  _ViewRepeaterItemChanged,\n  _ViewRepeaterItemContext,\n  _ViewRepeaterItemContextFactory,\n  _ViewRepeaterItemInsertArgs,\n  _ViewRepeaterItemValueResolver,\n  _ViewRepeaterOperation,\n} from './view-repeater';\n\n/**\n * A repeater that caches views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will reuse one of the cached views instead of creating a new\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\n * inserts.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nexport class _RecycleViewRepeaterStrategy<T, R, C extends _ViewRepeaterItemContext<T>>\n  implements _ViewRepeater<T, R, C>\n{\n  /**\n   * The size of the cache used to store unused views.\n   * Setting the cache size to `0` will disable caching. Defaults to 20 views.\n   */\n  viewCacheSize: number = 20;\n\n  /**\n   * View cache that stores embedded view instances that have been previously stamped out,\n   * but don't are not currently rendered. The view repeater will reuse these views rather than\n   * creating brand new ones.\n   *\n   * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\n   */\n  private _viewCache: EmbeddedViewRef<C>[] = [];\n\n  /** Apply changes to the DOM. */\n  applyChanges(\n    changes: IterableChanges<R>,\n    viewContainerRef: ViewContainerRef,\n    itemContextFactory: _ViewRepeaterItemContextFactory<T, R, C>,\n    itemValueResolver: _ViewRepeaterItemValueResolver<T, R>,\n    itemViewChanged?: _ViewRepeaterItemChanged<R, C>,\n  ) {\n    // Rearrange the views to put them in the right location.\n    changes.forEachOperation(\n      (\n        record: IterableChangeRecord<R>,\n        adjustedPreviousIndex: number | null,\n        currentIndex: number | null,\n      ) => {\n        let view: EmbeddedViewRef<C> | undefined;\n        let operation: _ViewRepeaterOperation;\n        if (record.previousIndex == null) {\n          // Item added.\n          const viewArgsFactory = () =>\n            itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n          view = this._insertView(\n            viewArgsFactory,\n            currentIndex!,\n            viewContainerRef,\n            itemValueResolver(record),\n          );\n          operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;\n        } else if (currentIndex == null) {\n          // Item removed.\n          this._detachAndCacheView(adjustedPreviousIndex!, viewContainerRef);\n          operation = _ViewRepeaterOperation.REMOVED;\n        } else {\n          // Item moved.\n          view = this._moveView(\n            adjustedPreviousIndex!,\n            currentIndex!,\n            viewContainerRef,\n            itemValueResolver(record),\n          );\n          operation = _ViewRepeaterOperation.MOVED;\n        }\n\n        if (itemViewChanged) {\n          itemViewChanged({\n            context: view?.context,\n            operation,\n            record,\n          });\n        }\n      },\n    );\n  }\n\n  detach() {\n    for (const view of this._viewCache) {\n      view.destroy();\n    }\n    this._viewCache = [];\n  }\n\n  /**\n   * Inserts a view for a new item, either from the cache or by creating a new\n   * one. Returns `undefined` if the item was inserted into a cached view.\n   */\n  private _insertView(\n    viewArgsFactory: () => _ViewRepeaterItemInsertArgs<C>,\n    currentIndex: number,\n    viewContainerRef: ViewContainerRef,\n    value: T,\n  ): EmbeddedViewRef<C> | undefined {\n    const cachedView = this._insertViewFromCache(currentIndex!, viewContainerRef);\n    if (cachedView) {\n      cachedView.context.$implicit = value;\n      return undefined;\n    }\n\n    const viewArgs = viewArgsFactory();\n    return viewContainerRef.createEmbeddedView(\n      viewArgs.templateRef,\n      viewArgs.context,\n      viewArgs.index,\n    );\n  }\n\n  /** Detaches the view at the given index and inserts into the view cache. */\n  private _detachAndCacheView(index: number, viewContainerRef: ViewContainerRef) {\n    const detachedView = viewContainerRef.detach(index) as EmbeddedViewRef<C>;\n    this._maybeCacheView(detachedView, viewContainerRef);\n  }\n\n  /** Moves view at the previous index to the current index. */\n  private _moveView(\n    adjustedPreviousIndex: number,\n    currentIndex: number,\n    viewContainerRef: ViewContainerRef,\n    value: T,\n  ): EmbeddedViewRef<C> {\n    const view = viewContainerRef.get(adjustedPreviousIndex!) as EmbeddedViewRef<C>;\n    viewContainerRef.move(view, currentIndex);\n    view.context.$implicit = value;\n    return view;\n  }\n\n  /**\n   * Cache the given detached view. If the cache is full, the view will be\n   * destroyed.\n   */\n  private _maybeCacheView(view: EmbeddedViewRef<C>, viewContainerRef: ViewContainerRef) {\n    if (this._viewCache.length < this.viewCacheSize) {\n      this._viewCache.push(view);\n    } else {\n      const index = viewContainerRef.indexOf(view);\n\n      // The host component could remove views from the container outside of\n      // the view repeater. It's unlikely this will occur, but just in case,\n      // destroy the view on its own, otherwise destroy it through the\n      // container to ensure that all the references are removed.\n      if (index === -1) {\n        view.destroy();\n      } else {\n        viewContainerRef.remove(index);\n      }\n    }\n  }\n\n  /** Inserts a recycled view from the cache at the given index. */\n  private _insertViewFromCache(\n    index: number,\n    viewContainerRef: ViewContainerRef,\n  ): EmbeddedViewRef<C> | null {\n    const cachedView = this._viewCache.pop();\n    if (cachedView) {\n      viewContainerRef.insert(cachedView, index);\n    }\n    return cachedView || null;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Subject} from 'rxjs';\n\n/**\n * Class to be used to power selecting one or more options from a list.\n */\nexport class SelectionModel<T> {\n  /** Currently-selected values. */\n  private _selection = new Set<T>();\n\n  /** Keeps track of the deselected options that haven't been emitted by the change event. */\n  private _deselectedToEmit: T[] = [];\n\n  /** Keeps track of the selected options that haven't been emitted by the change event. */\n  private _selectedToEmit: T[] = [];\n\n  /** Cache for the array value of the selected items. */\n  private _selected: T[] | null;\n\n  /** Selected values. */\n  get selected(): T[] {\n    if (!this._selected) {\n      this._selected = Array.from(this._selection.values());\n    }\n\n    return this._selected;\n  }\n\n  /** Event emitted when the value has changed. */\n  readonly changed = new Subject<SelectionChange<T>>();\n\n  constructor(\n    private _multiple = false,\n    initiallySelectedValues?: T[],\n    private _emitChanges = true,\n    public compareWith?: (o1: T, o2: T) => boolean,\n  ) {\n    if (initiallySelectedValues && initiallySelectedValues.length) {\n      if (_multiple) {\n        initiallySelectedValues.forEach(value => this._markSelected(value));\n      } else {\n        this._markSelected(initiallySelectedValues[0]);\n      }\n\n      // Clear the array in order to avoid firing the change event for preselected values.\n      this._selectedToEmit.length = 0;\n    }\n  }\n\n  /**\n   * Selects a value or an array of values.\n   * @param values The values to select\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  select(...values: T[]): boolean | void {\n    this._verifyValueAssignment(values);\n    values.forEach(value => this._markSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n\n  /**\n   * Deselects a value or an array of values.\n   * @param values The values to deselect\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  deselect(...values: T[]): boolean | void {\n    this._verifyValueAssignment(values);\n    values.forEach(value => this._unmarkSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n\n  /**\n   * Sets the selected values\n   * @param values The new selected values\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  setSelection(...values: T[]): boolean | void {\n    this._verifyValueAssignment(values);\n    const oldValues = this.selected;\n    const newSelectedSet = new Set(values);\n    values.forEach(value => this._markSelected(value));\n    oldValues\n      .filter(value => !newSelectedSet.has(value))\n      .forEach(value => this._unmarkSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n\n  /**\n   * Toggles a value between selected and deselected.\n   * @param value The value to toggle\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  toggle(value: T): boolean | void {\n    return this.isSelected(value) ? this.deselect(value) : this.select(value);\n  }\n\n  /**\n   * Clears all of the selected values.\n   * @param flushEvent Whether to flush the changes in an event.\n   *   If false, the changes to the selection will be flushed along with the next event.\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  clear(flushEvent = true): boolean | void {\n    this._unmarkAll();\n    const changed = this._hasQueuedChanges();\n    if (flushEvent) {\n      this._emitChangeEvent();\n    }\n    return changed;\n  }\n\n  /**\n   * Determines whether a value is selected.\n   */\n  isSelected(value: T): boolean {\n    return this._selection.has(this._getConcreteValue(value));\n  }\n\n  /**\n   * Determines whether the model does not have a value.\n   */\n  isEmpty(): boolean {\n    return this._selection.size === 0;\n  }\n\n  /**\n   * Determines whether the model has a value.\n   */\n  hasValue(): boolean {\n    return !this.isEmpty();\n  }\n\n  /**\n   * Sorts the selected values based on a predicate function.\n   */\n  sort(predicate?: (a: T, b: T) => number): void {\n    if (this._multiple && this.selected) {\n      this._selected!.sort(predicate);\n    }\n  }\n\n  /**\n   * Gets whether multiple values can be selected.\n   */\n  isMultipleSelection() {\n    return this._multiple;\n  }\n\n  /** Emits a change event and clears the records of selected and deselected values. */\n  private _emitChangeEvent() {\n    // Clear the selected values so they can be re-cached.\n    this._selected = null;\n\n    if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n      this.changed.next({\n        source: this,\n        added: this._selectedToEmit,\n        removed: this._deselectedToEmit,\n      });\n\n      this._deselectedToEmit = [];\n      this._selectedToEmit = [];\n    }\n  }\n\n  /** Selects a value. */\n  private _markSelected(value: T) {\n    value = this._getConcreteValue(value);\n    if (!this.isSelected(value)) {\n      if (!this._multiple) {\n        this._unmarkAll();\n      }\n\n      if (!this.isSelected(value)) {\n        this._selection.add(value);\n      }\n\n      if (this._emitChanges) {\n        this._selectedToEmit.push(value);\n      }\n    }\n  }\n\n  /** Deselects a value. */\n  private _unmarkSelected(value: T) {\n    value = this._getConcreteValue(value);\n    if (this.isSelected(value)) {\n      this._selection.delete(value);\n\n      if (this._emitChanges) {\n        this._deselectedToEmit.push(value);\n      }\n    }\n  }\n\n  /** Clears out the selected values. */\n  private _unmarkAll() {\n    if (!this.isEmpty()) {\n      this._selection.forEach(value => this._unmarkSelected(value));\n    }\n  }\n\n  /**\n   * Verifies the value assignment and throws an error if the specified value array is\n   * including multiple values while the selection model is not supporting multiple values.\n   */\n  private _verifyValueAssignment(values: T[]) {\n    if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMultipleValuesInSingleSelectionError();\n    }\n  }\n\n  /** Whether there are queued up change to be emitted. */\n  private _hasQueuedChanges() {\n    return !!(this._deselectedToEmit.length || this._selectedToEmit.length);\n  }\n\n  /** Returns a value that is comparable to inputValue by applying compareWith function, returns the same inputValue otherwise. */\n  private _getConcreteValue(inputValue: T): T {\n    if (!this.compareWith) {\n      return inputValue;\n    } else {\n      for (let selectedValue of this._selection) {\n        if (this.compareWith!(inputValue, selectedValue)) {\n          return selectedValue;\n        }\n      }\n      return inputValue;\n    }\n  }\n}\n\n/**\n * Event emitted when the value of a MatSelectionModel has changed.\n * @docs-private\n */\nexport interface SelectionChange<T> {\n  /** Model that dispatched the event. */\n  source: SelectionModel<T>;\n  /** Options that were added to the model. */\n  added: T[];\n  /** Options that were removed from the model. */\n  removed: T[];\n}\n\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @docs-private\n */\nexport function getMultipleValuesInSingleSelectionError() {\n  return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, OnDestroy} from '@angular/core';\n\n// Users of the Dispatcher never need to see this type, but TypeScript requires it to be exported.\nexport type UniqueSelectionDispatcherListener = (id: string, name: string) => void;\n\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\n@Injectable({providedIn: 'root'})\nexport class UniqueSelectionDispatcher implements OnDestroy {\n  private _listeners: UniqueSelectionDispatcherListener[] = [];\n\n  /**\n   * Notify other items that selection for the given name has been set.\n   * @param id ID of the item.\n   * @param name Name of the item.\n   */\n  notify(id: string, name: string) {\n    for (let listener of this._listeners) {\n      listener(id, name);\n    }\n  }\n\n  /**\n   * Listen for future changes to item selection.\n   * @return Function used to deregister listener\n   */\n  listen(listener: UniqueSelectionDispatcherListener): () => void {\n    this._listeners.push(listener);\n    return () => {\n      this._listeners = this._listeners.filter((registered: UniqueSelectionDispatcherListener) => {\n        return listener !== registered;\n      });\n    };\n  }\n\n  ngOnDestroy() {\n    this._listeners = [];\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  InjectionToken,\n  IterableChangeRecord,\n  IterableChanges,\n  TemplateRef,\n  ViewContainerRef,\n} from '@angular/core';\n\n/**\n * The context for an embedded view in the repeater's view container.\n *\n * @template T The type for the embedded view's $implicit property.\n */\nexport interface _ViewRepeaterItemContext<T> {\n  $implicit?: T;\n}\n\n/**\n * The arguments needed to construct an embedded view for an item in a view\n * container.\n *\n * @template C The type for the context passed to each embedded view.\n */\nexport interface _ViewRepeaterItemInsertArgs<C> {\n  templateRef: TemplateRef<C>;\n  context?: C;\n  index?: number;\n}\n\n/**\n * A factory that derives the embedded view context for an item in a view\n * container.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nexport type _ViewRepeaterItemContextFactory<T, R, C extends _ViewRepeaterItemContext<T>> = (\n  record: IterableChangeRecord<R>,\n  adjustedPreviousIndex: number | null,\n  currentIndex: number | null,\n) => _ViewRepeaterItemInsertArgs<C>;\n\n/**\n * Extracts the value of an item from an {@link IterableChangeRecord}.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n */\nexport type _ViewRepeaterItemValueResolver<T, R> = (record: IterableChangeRecord<R>) => T;\n\n/** Indicates how a view was changed by a {@link _ViewRepeater}. */\nexport const enum _ViewRepeaterOperation {\n  /** The content of an existing view was replaced with another item. */\n  REPLACED,\n  /** A new view was created with `createEmbeddedView`. */\n  INSERTED,\n  /** The position of a view changed, but the content remains the same. */\n  MOVED,\n  /** A view was detached from the view container. */\n  REMOVED,\n}\n\n/**\n * Meta data describing the state of a view after it was updated by a\n * {@link _ViewRepeater}.\n *\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nexport interface _ViewRepeaterItemChange<R, C> {\n  /** The view's context after it was changed. */\n  context?: C;\n  /** Indicates how the view was changed. */\n  operation: _ViewRepeaterOperation;\n  /** The view's corresponding change record. */\n  record: IterableChangeRecord<R>;\n}\n\n/**\n * Type for a callback to be executed after a view has changed.\n *\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nexport type _ViewRepeaterItemChanged<R, C> = (change: _ViewRepeaterItemChange<R, C>) => void;\n\n/**\n * Describes a strategy for rendering items in a {@link ViewContainerRef}.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nexport interface _ViewRepeater<T, R, C extends _ViewRepeaterItemContext<T>> {\n  applyChanges(\n    changes: IterableChanges<R>,\n    viewContainerRef: ViewContainerRef,\n    itemContextFactory: _ViewRepeaterItemContextFactory<T, R, C>,\n    itemValueResolver: _ViewRepeaterItemValueResolver<T, R>,\n    itemViewChanged?: _ViewRepeaterItemChanged<R, C>,\n  ): void;\n\n  detach(): void;\n}\n\n/**\n * Injection token for {@link _ViewRepeater}. This token is for use by Angular Material only.\n * @docs-private\n */\nexport const _VIEW_REPEATER_STRATEGY = new InjectionToken<\n  _ViewRepeater<unknown, unknown, _ViewRepeaterItemContext<unknown>>\n>('_ViewRepeater');\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport type {CdkVirtualScrollViewport} from './virtual-scroll-viewport';\n\n/** The injection token used to specify the virtual scrolling strategy. */\nexport const VIRTUAL_SCROLL_STRATEGY = new InjectionToken<VirtualScrollStrategy>(\n  'VIRTUAL_SCROLL_STRATEGY',\n);\n\n/** A strategy that dictates which items should be rendered in the viewport. */\nexport interface VirtualScrollStrategy {\n  /** Emits when the index of the first element visible in the viewport changes. */\n  scrolledIndexChange: Observable<number>;\n\n  /**\n   * Attaches this scroll strategy to a viewport.\n   * @param viewport The viewport to attach this strategy to.\n   */\n  attach(viewport: CdkVirtualScrollViewport): void;\n\n  /** Detaches this scroll strategy from the currently attached viewport. */\n  detach(): void;\n\n  /** Called when the viewport is scrolled (debounced using requestAnimationFrame). */\n  onContentScrolled(): void;\n\n  /** Called when the length of the data changes. */\n  onDataLengthChanged(): void;\n\n  /** Called when the range of items rendered in the DOM has changed. */\n  onContentRendered(): void;\n\n  /** Called when the offset of the rendered items changed. */\n  onRenderedOffsetChanged(): void;\n\n  /**\n   * Scroll to the offset for the given index.\n   * @param index The index of the element to scroll to.\n   * @param behavior The ScrollBehavior to use when scrolling.\n   */\n  scrollToIndex(index: number, behavior: ScrollBehavior): void;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceNumberProperty, NumberInput} from '@angular/cdk/coercion';\nimport {Directive, forwardRef, Input, OnChanges} from '@angular/core';\nimport {Observable, Subject} from 'rxjs';\nimport {distinctUntilChanged} from 'rxjs/operators';\nimport {VIRTUAL_SCROLL_STRATEGY, VirtualScrollStrategy} from './virtual-scroll-strategy';\nimport {CdkVirtualScrollViewport} from './virtual-scroll-viewport';\n\n/** Virtual scrolling strategy for lists with items of known fixed size. */\nexport class FixedSizeVirtualScrollStrategy implements VirtualScrollStrategy {\n  private readonly _scrolledIndexChange = new Subject<number>();\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  scrolledIndexChange: Observable<number> = this._scrolledIndexChange.pipe(distinctUntilChanged());\n\n  /** The attached viewport. */\n  private _viewport: CdkVirtualScrollViewport | null = null;\n\n  /** The size of the items in the virtually scrolling list. */\n  private _itemSize: number;\n\n  /** The minimum amount of buffer rendered beyond the viewport (in pixels). */\n  private _minBufferPx: number;\n\n  /** The number of buffer items to render beyond the edge of the viewport (in pixels). */\n  private _maxBufferPx: number;\n\n  /**\n   * @param itemSize The size of the items in the virtually scrolling list.\n   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n   */\n  constructor(itemSize: number, minBufferPx: number, maxBufferPx: number) {\n    this._itemSize = itemSize;\n    this._minBufferPx = minBufferPx;\n    this._maxBufferPx = maxBufferPx;\n  }\n\n  /**\n   * Attaches this scroll strategy to a viewport.\n   * @param viewport The viewport to attach this strategy to.\n   */\n  attach(viewport: CdkVirtualScrollViewport) {\n    this._viewport = viewport;\n    this._updateTotalContentSize();\n    this._updateRenderedRange();\n  }\n\n  /** Detaches this scroll strategy from the currently attached viewport. */\n  detach() {\n    this._scrolledIndexChange.complete();\n    this._viewport = null;\n  }\n\n  /**\n   * Update the item size and buffer size.\n   * @param itemSize The size of the items in the virtually scrolling list.\n   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n   */\n  updateItemAndBufferSize(itemSize: number, minBufferPx: number, maxBufferPx: number) {\n    if (maxBufferPx < minBufferPx && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n    }\n    this._itemSize = itemSize;\n    this._minBufferPx = minBufferPx;\n    this._maxBufferPx = maxBufferPx;\n    this._updateTotalContentSize();\n    this._updateRenderedRange();\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onContentScrolled() {\n    this._updateRenderedRange();\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onDataLengthChanged() {\n    this._updateTotalContentSize();\n    this._updateRenderedRange();\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onContentRendered() {\n    /* no-op */\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onRenderedOffsetChanged() {\n    /* no-op */\n  }\n\n  /**\n   * Scroll to the offset for the given index.\n   * @param index The index of the element to scroll to.\n   * @param behavior The ScrollBehavior to use when scrolling.\n   */\n  scrollToIndex(index: number, behavior: ScrollBehavior): void {\n    if (this._viewport) {\n      this._viewport.scrollToOffset(index * this._itemSize, behavior);\n    }\n  }\n\n  /** Update the viewport's total content size. */\n  private _updateTotalContentSize() {\n    if (!this._viewport) {\n      return;\n    }\n\n    this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);\n  }\n\n  /** Update the viewport's rendered range. */\n  private _updateRenderedRange() {\n    if (!this._viewport) {\n      return;\n    }\n\n    const renderedRange = this._viewport.getRenderedRange();\n    const newRange = {start: renderedRange.start, end: renderedRange.end};\n    const viewportSize = this._viewport.getViewportSize();\n    const dataLength = this._viewport.getDataLength();\n    let scrollOffset = this._viewport.measureScrollOffset();\n    // Prevent NaN as result when dividing by zero.\n    let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;\n\n    // If user scrolls to the bottom of the list and data changes to a smaller list\n    if (newRange.end > dataLength) {\n      // We have to recalculate the first visible index based on new data length and viewport size.\n      const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);\n      const newVisibleIndex = Math.max(\n        0,\n        Math.min(firstVisibleIndex, dataLength - maxVisibleItems),\n      );\n\n      // If first visible index changed we must update scroll offset to handle start/end buffers\n      // Current range must also be adjusted to cover the new position (bottom of new list).\n      if (firstVisibleIndex != newVisibleIndex) {\n        firstVisibleIndex = newVisibleIndex;\n        scrollOffset = newVisibleIndex * this._itemSize;\n        newRange.start = Math.floor(firstVisibleIndex);\n      }\n\n      newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));\n    }\n\n    const startBuffer = scrollOffset - newRange.start * this._itemSize;\n    if (startBuffer < this._minBufferPx && newRange.start != 0) {\n      const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);\n      newRange.start = Math.max(0, newRange.start - expandStart);\n      newRange.end = Math.min(\n        dataLength,\n        Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize),\n      );\n    } else {\n      const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);\n      if (endBuffer < this._minBufferPx && newRange.end != dataLength) {\n        const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);\n        if (expandEnd > 0) {\n          newRange.end = Math.min(dataLength, newRange.end + expandEnd);\n          newRange.start = Math.max(\n            0,\n            Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize),\n          );\n        }\n      }\n    }\n\n    this._viewport.setRenderedRange(newRange);\n    this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);\n    this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\n  }\n}\n\n/**\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\n * `FixedSizeVirtualScrollStrategy` from the given directive.\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\n *     `FixedSizeVirtualScrollStrategy` from.\n */\nexport function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir: CdkFixedSizeVirtualScroll) {\n  return fixedSizeDir._scrollStrategy;\n}\n\n/** A virtual scroll strategy that supports fixed-size items. */\n@Directive({\n  selector: 'cdk-virtual-scroll-viewport[itemSize]',\n  standalone: true,\n  providers: [\n    {\n      provide: VIRTUAL_SCROLL_STRATEGY,\n      useFactory: _fixedSizeVirtualScrollStrategyFactory,\n      deps: [forwardRef(() => CdkFixedSizeVirtualScroll)],\n    },\n  ],\n})\nexport class CdkFixedSizeVirtualScroll implements OnChanges {\n  /** The size of the items in the list (in pixels). */\n  @Input()\n  get itemSize(): number {\n    return this._itemSize;\n  }\n  set itemSize(value: NumberInput) {\n    this._itemSize = coerceNumberProperty(value);\n  }\n  _itemSize = 20;\n\n  /**\n   * The minimum amount of buffer rendered beyond the viewport (in pixels).\n   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n   */\n  @Input()\n  get minBufferPx(): number {\n    return this._minBufferPx;\n  }\n  set minBufferPx(value: NumberInput) {\n    this._minBufferPx = coerceNumberProperty(value);\n  }\n  _minBufferPx = 100;\n\n  /**\n   * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\n   */\n  @Input()\n  get maxBufferPx(): number {\n    return this._maxBufferPx;\n  }\n  set maxBufferPx(value: NumberInput) {\n    this._maxBufferPx = coerceNumberProperty(value);\n  }\n  _maxBufferPx = 200;\n\n  /** The scroll strategy used by this directive. */\n  _scrollStrategy = new FixedSizeVirtualScrollStrategy(\n    this.itemSize,\n    this.minBufferPx,\n    this.maxBufferPx,\n  );\n\n  ngOnChanges() {\n    this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceElement} from '@angular/cdk/coercion';\nimport {Platform} from '@angular/cdk/platform';\nimport {ElementRef, Injectable, NgZone, OnDestroy, Optional, Inject} from '@angular/core';\nimport {fromEvent, of as observableOf, Subject, Subscription, Observable, Observer} from 'rxjs';\nimport {auditTime, filter} from 'rxjs/operators';\nimport type {CdkScrollable} from './scrollable';\nimport {DOCUMENT} from '@angular/common';\n\n/** Time in ms to throttle the scrolling events by default. */\nexport const DEFAULT_SCROLL_TIME = 20;\n\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\n@Injectable({providedIn: 'root'})\nexport class ScrollDispatcher implements OnDestroy {\n  /** Used to reference correct document/window */\n  protected _document: Document;\n\n  constructor(\n    private _ngZone: NgZone,\n    private _platform: Platform,\n    @Optional() @Inject(DOCUMENT) document: any,\n  ) {\n    this._document = document;\n  }\n\n  /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n  private readonly _scrolled = new Subject<CdkScrollable | void>();\n\n  /** Keeps track of the global `scroll` and `resize` subscriptions. */\n  _globalSubscription: Subscription | null = null;\n\n  /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\n  private _scrolledCount = 0;\n\n  /**\n   * Map of all the scrollable references that are registered with the service and their\n   * scroll event subscriptions.\n   */\n  scrollContainers: Map<CdkScrollable, Subscription> = new Map();\n\n  /**\n   * Registers a scrollable instance with the service and listens for its scrolled events. When the\n   * scrollable is scrolled, the service emits the event to its scrolled observable.\n   * @param scrollable Scrollable instance to be registered.\n   */\n  register(scrollable: CdkScrollable): void {\n    if (!this.scrollContainers.has(scrollable)) {\n      this.scrollContainers.set(\n        scrollable,\n        scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)),\n      );\n    }\n  }\n\n  /**\n   * De-registers a Scrollable reference and unsubscribes from its scroll event observable.\n   * @param scrollable Scrollable instance to be deregistered.\n   */\n  deregister(scrollable: CdkScrollable): void {\n    const scrollableReference = this.scrollContainers.get(scrollable);\n\n    if (scrollableReference) {\n      scrollableReference.unsubscribe();\n      this.scrollContainers.delete(scrollable);\n    }\n  }\n\n  /**\n   * Returns an observable that emits an event whenever any of the registered Scrollable\n   * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n   * to override the default \"throttle\" time.\n   *\n   * **Note:** in order to avoid hitting change detection for every scroll event,\n   * all of the events emitted from this stream will be run outside the Angular zone.\n   * If you need to update any data bindings as a result of a scroll event, you have\n   * to run the callback using `NgZone.run`.\n   */\n  scrolled(auditTimeInMs: number = DEFAULT_SCROLL_TIME): Observable<CdkScrollable | void> {\n    if (!this._platform.isBrowser) {\n      return observableOf<void>();\n    }\n\n    return new Observable((observer: Observer<CdkScrollable | void>) => {\n      if (!this._globalSubscription) {\n        this._addGlobalListener();\n      }\n\n      // In the case of a 0ms delay, use an observable without auditTime\n      // since it does add a perceptible delay in processing overhead.\n      const subscription =\n        auditTimeInMs > 0\n          ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer)\n          : this._scrolled.subscribe(observer);\n\n      this._scrolledCount++;\n\n      return () => {\n        subscription.unsubscribe();\n        this._scrolledCount--;\n\n        if (!this._scrolledCount) {\n          this._removeGlobalListener();\n        }\n      };\n    });\n  }\n\n  ngOnDestroy() {\n    this._removeGlobalListener();\n    this.scrollContainers.forEach((_, container) => this.deregister(container));\n    this._scrolled.complete();\n  }\n\n  /**\n   * Returns an observable that emits whenever any of the\n   * scrollable ancestors of an element are scrolled.\n   * @param elementOrElementRef Element whose ancestors to listen for.\n   * @param auditTimeInMs Time to throttle the scroll events.\n   */\n  ancestorScrolled(\n    elementOrElementRef: ElementRef | HTMLElement,\n    auditTimeInMs?: number,\n  ): Observable<CdkScrollable | void> {\n    const ancestors = this.getAncestorScrollContainers(elementOrElementRef);\n\n    return this.scrolled(auditTimeInMs).pipe(\n      filter(target => {\n        return !target || ancestors.indexOf(target) > -1;\n      }),\n    );\n  }\n\n  /** Returns all registered Scrollables that contain the provided element. */\n  getAncestorScrollContainers(elementOrElementRef: ElementRef | HTMLElement): CdkScrollable[] {\n    const scrollingContainers: CdkScrollable[] = [];\n\n    this.scrollContainers.forEach((_subscription: Subscription, scrollable: CdkScrollable) => {\n      if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {\n        scrollingContainers.push(scrollable);\n      }\n    });\n\n    return scrollingContainers;\n  }\n\n  /** Use defaultView of injected document if available or fallback to global window reference */\n  private _getWindow(): Window {\n    return this._document.defaultView || window;\n  }\n\n  /** Returns true if the element is contained within the provided Scrollable. */\n  private _scrollableContainsElement(\n    scrollable: CdkScrollable,\n    elementOrElementRef: ElementRef | HTMLElement,\n  ): boolean {\n    let element: HTMLElement | null = coerceElement(elementOrElementRef);\n    let scrollableElement = scrollable.getElementRef().nativeElement;\n\n    // Traverse through the element parents until we reach null, checking if any of the elements\n    // are the scrollable's element.\n    do {\n      if (element == scrollableElement) {\n        return true;\n      }\n    } while ((element = element!.parentElement));\n\n    return false;\n  }\n\n  /** Sets up the global scroll listeners. */\n  private _addGlobalListener() {\n    this._globalSubscription = this._ngZone.runOutsideAngular(() => {\n      const window = this._getWindow();\n      return fromEvent(window.document, 'scroll').subscribe(() => this._scrolled.next());\n    });\n  }\n\n  /** Cleans up the global scroll listener. */\n  private _removeGlobalListener() {\n    if (this._globalSubscription) {\n      this._globalSubscription.unsubscribe();\n      this._globalSubscription = null;\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {\n  getRtlScrollAxisType,\n  RtlScrollAxisType,\n  supportsScrollBehavior,\n} from '@angular/cdk/platform';\nimport {Directive, ElementRef, NgZone, OnDestroy, OnInit, Optional} from '@angular/core';\nimport {fromEvent, Observable, Subject, Observer} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\nimport {ScrollDispatcher} from './scroll-dispatcher';\n\nexport type _Without<T> = {[P in keyof T]?: never};\nexport type _XOR<T, U> = (_Without<T> & U) | (_Without<U> & T);\nexport type _Top = {top?: number};\nexport type _Bottom = {bottom?: number};\nexport type _Left = {left?: number};\nexport type _Right = {right?: number};\nexport type _Start = {start?: number};\nexport type _End = {end?: number};\nexport type _XAxis = _XOR<_XOR<_Left, _Right>, _XOR<_Start, _End>>;\nexport type _YAxis = _XOR<_Top, _Bottom>;\n\n/**\n * An extended version of ScrollToOptions that allows expressing scroll offsets relative to the\n * top, bottom, left, right, start, or end of the viewport rather than just the top and left.\n * Please note: the top and bottom properties are mutually exclusive, as are the left, right,\n * start, and end properties.\n */\nexport type ExtendedScrollToOptions = _XAxis & _YAxis & ScrollOptions;\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\n@Directive({\n  selector: '[cdk-scrollable], [cdkScrollable]',\n  standalone: true,\n})\nexport class CdkScrollable implements OnInit, OnDestroy {\n  protected readonly _destroyed = new Subject<void>();\n\n  protected _elementScrolled: Observable<Event> = new Observable((observer: Observer<Event>) =>\n    this.ngZone.runOutsideAngular(() =>\n      fromEvent(this.elementRef.nativeElement, 'scroll')\n        .pipe(takeUntil(this._destroyed))\n        .subscribe(observer),\n    ),\n  );\n\n  constructor(\n    protected elementRef: ElementRef<HTMLElement>,\n    protected scrollDispatcher: ScrollDispatcher,\n    protected ngZone: NgZone,\n    @Optional() protected dir?: Directionality,\n  ) {}\n\n  ngOnInit() {\n    this.scrollDispatcher.register(this);\n  }\n\n  ngOnDestroy() {\n    this.scrollDispatcher.deregister(this);\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /** Returns observable that emits when a scroll event is fired on the host element. */\n  elementScrolled(): Observable<Event> {\n    return this._elementScrolled;\n  }\n\n  /** Gets the ElementRef for the viewport. */\n  getElementRef(): ElementRef<HTMLElement> {\n    return this.elementRef;\n  }\n\n  /**\n   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n   * left and right always refer to the left and right side of the scrolling container irrespective\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n   * in an RTL context.\n   * @param options specified the offsets to scroll to.\n   */\n  scrollTo(options: ExtendedScrollToOptions): void {\n    const el = this.elementRef.nativeElement;\n    const isRtl = this.dir && this.dir.value == 'rtl';\n\n    // Rewrite start & end offsets as right or left offsets.\n    if (options.left == null) {\n      options.left = isRtl ? options.end : options.start;\n    }\n\n    if (options.right == null) {\n      options.right = isRtl ? options.start : options.end;\n    }\n\n    // Rewrite the bottom offset as a top offset.\n    if (options.bottom != null) {\n      (options as _Without<_Bottom> & _Top).top =\n        el.scrollHeight - el.clientHeight - options.bottom;\n    }\n\n    // Rewrite the right offset as a left offset.\n    if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {\n      if (options.left != null) {\n        (options as _Without<_Left> & _Right).right =\n          el.scrollWidth - el.clientWidth - options.left;\n      }\n\n      if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {\n        options.left = options.right;\n      } else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {\n        options.left = options.right ? -options.right : options.right;\n      }\n    } else {\n      if (options.right != null) {\n        (options as _Without<_Right> & _Left).left =\n          el.scrollWidth - el.clientWidth - options.right;\n      }\n    }\n\n    this._applyScrollToOptions(options);\n  }\n\n  private _applyScrollToOptions(options: ScrollToOptions): void {\n    const el = this.elementRef.nativeElement;\n\n    if (supportsScrollBehavior()) {\n      el.scrollTo(options);\n    } else {\n      if (options.top != null) {\n        el.scrollTop = options.top;\n      }\n      if (options.left != null) {\n        el.scrollLeft = options.left;\n      }\n    }\n  }\n\n  /**\n   * Measures the scroll offset relative to the specified edge of the viewport. This method can be\n   * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\n   * about what scrollLeft means in RTL. The values returned by this method are normalized such that\n   * left and right always refer to the left and right side of the scrolling container irrespective\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n   * in an RTL context.\n   * @param from The edge to measure from.\n   */\n  measureScrollOffset(from: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end'): number {\n    const LEFT = 'left';\n    const RIGHT = 'right';\n    const el = this.elementRef.nativeElement;\n    if (from == 'top') {\n      return el.scrollTop;\n    }\n    if (from == 'bottom') {\n      return el.scrollHeight - el.clientHeight - el.scrollTop;\n    }\n\n    // Rewrite start & end as left or right offsets.\n    const isRtl = this.dir && this.dir.value == 'rtl';\n    if (from == 'start') {\n      from = isRtl ? RIGHT : LEFT;\n    } else if (from == 'end') {\n      from = isRtl ? LEFT : RIGHT;\n    }\n\n    if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {\n      // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\n      // 0 when scrolled all the way right.\n      if (from == LEFT) {\n        return el.scrollWidth - el.clientWidth - el.scrollLeft;\n      } else {\n        return el.scrollLeft;\n      }\n    } else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {\n      // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\n      // 0 when scrolled all the way right.\n      if (from == LEFT) {\n        return el.scrollLeft + el.scrollWidth - el.clientWidth;\n      } else {\n        return -el.scrollLeft;\n      }\n    } else {\n      // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\n      // (scrollWidth - clientWidth) when scrolled all the way right.\n      if (from == LEFT) {\n        return el.scrollLeft;\n      } else {\n        return el.scrollWidth - el.clientWidth - el.scrollLeft;\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Platform} from '@angular/cdk/platform';\nimport {Injectable, NgZone, OnDestroy, Optional, Inject} from '@angular/core';\nimport {Observable, Subject} from 'rxjs';\nimport {auditTime} from 'rxjs/operators';\nimport {DOCUMENT} from '@angular/common';\n\n/** Time in ms to throttle the resize events by default. */\nexport const DEFAULT_RESIZE_TIME = 20;\n\n/** Object that holds the scroll position of the viewport in each direction. */\nexport interface ViewportScrollPosition {\n  top: number;\n  left: number;\n}\n\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * @docs-private\n */\n@Injectable({providedIn: 'root'})\nexport class ViewportRuler implements OnDestroy {\n  /** Cached viewport dimensions. */\n  private _viewportSize: {width: number; height: number} | null;\n\n  /** Stream of viewport change events. */\n  private readonly _change = new Subject<Event>();\n\n  /** Event listener that will be used to handle the viewport change events. */\n  private _changeListener = (event: Event) => {\n    this._change.next(event);\n  };\n\n  /** Used to reference correct document/window */\n  protected _document: Document;\n\n  constructor(\n    private _platform: Platform,\n    ngZone: NgZone,\n    @Optional() @Inject(DOCUMENT) document: any,\n  ) {\n    this._document = document;\n\n    ngZone.runOutsideAngular(() => {\n      if (_platform.isBrowser) {\n        const window = this._getWindow();\n\n        // Note that bind the events ourselves, rather than going through something like RxJS's\n        // `fromEvent` so that we can ensure that they're bound outside of the NgZone.\n        window.addEventListener('resize', this._changeListener);\n        window.addEventListener('orientationchange', this._changeListener);\n      }\n\n      // Clear the cached position so that the viewport is re-measured next time it is required.\n      // We don't need to keep track of the subscription, because it is completed on destroy.\n      this.change().subscribe(() => (this._viewportSize = null));\n    });\n  }\n\n  ngOnDestroy() {\n    if (this._platform.isBrowser) {\n      const window = this._getWindow();\n      window.removeEventListener('resize', this._changeListener);\n      window.removeEventListener('orientationchange', this._changeListener);\n    }\n\n    this._change.complete();\n  }\n\n  /** Returns the viewport's width and height. */\n  getViewportSize(): Readonly<{width: number; height: number}> {\n    if (!this._viewportSize) {\n      this._updateViewportSize();\n    }\n\n    const output = {width: this._viewportSize!.width, height: this._viewportSize!.height};\n\n    // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n    if (!this._platform.isBrowser) {\n      this._viewportSize = null!;\n    }\n\n    return output;\n  }\n\n  /** Gets a ClientRect for the viewport's bounds. */\n  getViewportRect() {\n    // Use the document element's bounding rect rather than the window scroll properties\n    // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n    // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n    // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n    // can disagree when the page is pinch-zoomed (on devices that support touch).\n    // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n    // We use the documentElement instead of the body because, by default (without a css reset)\n    // browsers typically give the document body an 8px margin, which is not included in\n    // getBoundingClientRect().\n    const scrollPosition = this.getViewportScrollPosition();\n    const {width, height} = this.getViewportSize();\n\n    return {\n      top: scrollPosition.top,\n      left: scrollPosition.left,\n      bottom: scrollPosition.top + height,\n      right: scrollPosition.left + width,\n      height,\n      width,\n    };\n  }\n\n  /** Gets the (top, left) scroll position of the viewport. */\n  getViewportScrollPosition(): ViewportScrollPosition {\n    // While we can get a reference to the fake document\n    // during SSR, it doesn't have getBoundingClientRect.\n    if (!this._platform.isBrowser) {\n      return {top: 0, left: 0};\n    }\n\n    // The top-left-corner of the viewport is determined by the scroll position of the document\n    // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n    // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n    // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n    // `document.documentElement` works consistently, where the `top` and `left` values will\n    // equal negative the scroll position.\n    const document = this._document;\n    const window = this._getWindow();\n    const documentElement = document.documentElement!;\n    const documentRect = documentElement.getBoundingClientRect();\n\n    const top =\n      -documentRect.top ||\n      document.body.scrollTop ||\n      window.scrollY ||\n      documentElement.scrollTop ||\n      0;\n\n    const left =\n      -documentRect.left ||\n      document.body.scrollLeft ||\n      window.scrollX ||\n      documentElement.scrollLeft ||\n      0;\n\n    return {top, left};\n  }\n\n  /**\n   * Returns a stream that emits whenever the size of the viewport changes.\n   * This stream emits outside of the Angular zone.\n   * @param throttleTime Time in milliseconds to throttle the stream.\n   */\n  change(throttleTime: number = DEFAULT_RESIZE_TIME): Observable<Event> {\n    return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\n  }\n\n  /** Use defaultView of injected document if available or fallback to global window reference */\n  private _getWindow(): Window {\n    return this._document.defaultView || window;\n  }\n\n  /** Updates the cached viewport size. */\n  private _updateViewportSize() {\n    const window = this._getWindow();\n    this._viewportSize = this._platform.isBrowser\n      ? {width: window.innerWidth, height: window.innerHeight}\n      : {width: 0, height: 0};\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {Directive, ElementRef, InjectionToken, NgZone, Optional} from '@angular/core';\nimport {ScrollDispatcher} from './scroll-dispatcher';\nimport {CdkScrollable} from './scrollable';\n\nexport const VIRTUAL_SCROLLABLE = new InjectionToken<CdkVirtualScrollable>('VIRTUAL_SCROLLABLE');\n\n/**\n * Extending the {@link CdkScrollable} to be used as scrolling container for virtual scrolling.\n */\n@Directive()\nexport abstract class CdkVirtualScrollable extends CdkScrollable {\n  constructor(\n    elementRef: ElementRef<HTMLElement>,\n    scrollDispatcher: ScrollDispatcher,\n    ngZone: NgZone,\n    @Optional() dir?: Directionality,\n  ) {\n    super(elementRef, scrollDispatcher, ngZone, dir);\n  }\n\n  /**\n   * Measure the viewport size for the provided orientation.\n   *\n   * @param orientation The orientation to measure the size from.\n   */\n  measureViewportSize(orientation: 'horizontal' | 'vertical') {\n    const viewportEl = this.elementRef.nativeElement;\n    return orientation === 'horizontal' ? viewportEl.clientWidth : viewportEl.clientHeight;\n  }\n\n  /**\n   * Measure the bounding ClientRect size including the scroll offset.\n   *\n   * @param from The edge to measure from.\n   */\n  abstract measureBoundingClientRectWithScrollOffset(\n    from: 'left' | 'top' | 'right' | 'bottom',\n  ): number;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {ListRange} from '@angular/cdk/collections';\nimport {\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ElementRef,\n  inject,\n  Inject,\n  Input,\n  NgZone,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {Platform} from '@angular/cdk/platform';\nimport {\n  animationFrameScheduler,\n  asapScheduler,\n  Observable,\n  Subject,\n  Observer,\n  Subscription,\n} from 'rxjs';\nimport {auditTime, startWith, takeUntil} from 'rxjs/operators';\nimport {ScrollDispatcher} from './scroll-dispatcher';\nimport {CdkScrollable, ExtendedScrollToOptions} from './scrollable';\nimport {VIRTUAL_SCROLL_STRATEGY, VirtualScrollStrategy} from './virtual-scroll-strategy';\nimport {ViewportRuler} from './viewport-ruler';\nimport {CdkVirtualScrollRepeater} from './virtual-scroll-repeater';\nimport {CdkVirtualScrollable, VIRTUAL_SCROLLABLE} from './virtual-scrollable';\n\n/** Checks if the given ranges are equal. */\nfunction rangesEqual(r1: ListRange, r2: ListRange): boolean {\n  return r1.start == r2.start && r1.end == r2.end;\n}\n\n/**\n * Scheduler to be used for scroll events. Needs to fall back to\n * something that doesn't rely on requestAnimationFrame on environments\n * that don't support it (e.g. server-side rendering).\n */\nconst SCROLL_SCHEDULER =\n  typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;\n\n/** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */\n@Component({\n  selector: 'cdk-virtual-scroll-viewport',\n  templateUrl: 'virtual-scroll-viewport.html',\n  styleUrls: ['virtual-scroll-viewport.css'],\n  host: {\n    'class': 'cdk-virtual-scroll-viewport',\n    '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === \"horizontal\"',\n    '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== \"horizontal\"',\n  },\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  standalone: true,\n  providers: [\n    {\n      provide: CdkScrollable,\n      useFactory: (\n        virtualScrollable: CdkVirtualScrollable | null,\n        viewport: CdkVirtualScrollViewport,\n      ) => virtualScrollable || viewport,\n      deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport],\n    },\n  ],\n})\nexport class CdkVirtualScrollViewport extends CdkVirtualScrollable implements OnInit, OnDestroy {\n  private _platform = inject(Platform);\n\n  /** Emits when the viewport is detached from a CdkVirtualForOf. */\n  private readonly _detachedSubject = new Subject<void>();\n\n  /** Emits when the rendered range changes. */\n  private readonly _renderedRangeSubject = new Subject<ListRange>();\n\n  /** The direction the viewport scrolls. */\n  @Input()\n  get orientation() {\n    return this._orientation;\n  }\n\n  set orientation(orientation: 'horizontal' | 'vertical') {\n    if (this._orientation !== orientation) {\n      this._orientation = orientation;\n      this._calculateSpacerSize();\n    }\n  }\n  private _orientation: 'horizontal' | 'vertical' = 'vertical';\n\n  /**\n   * Whether rendered items should persist in the DOM after scrolling out of view. By default, items\n   * will be removed.\n   */\n  @Input({transform: booleanAttribute}) appendOnly: boolean = false;\n\n  // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\n  // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\n  // depending on how the strategy calculates the scrolled index, it may come at a cost to\n  // performance.\n  /** Emits when the index of the first element visible in the viewport changes. */\n  @Output()\n  readonly scrolledIndexChange: Observable<number> = new Observable((observer: Observer<number>) =>\n    this._scrollStrategy.scrolledIndexChange.subscribe(index =>\n      Promise.resolve().then(() => this.ngZone.run(() => observer.next(index))),\n    ),\n  );\n\n  /** The element that wraps the rendered content. */\n  @ViewChild('contentWrapper', {static: true}) _contentWrapper: ElementRef<HTMLElement>;\n\n  /** A stream that emits whenever the rendered range changes. */\n  readonly renderedRangeStream: Observable<ListRange> = this._renderedRangeSubject;\n\n  /**\n   * The total size of all content (in pixels), including content that is not currently rendered.\n   */\n  private _totalContentSize = 0;\n\n  /** A string representing the `style.width` property value to be used for the spacer element. */\n  _totalContentWidth = '';\n\n  /** A string representing the `style.height` property value to be used for the spacer element. */\n  _totalContentHeight = '';\n\n  /**\n   * The CSS transform applied to the rendered subset of items so that they appear within the bounds\n   * of the visible viewport.\n   */\n  private _renderedContentTransform: string;\n\n  /** The currently rendered range of indices. */\n  private _renderedRange: ListRange = {start: 0, end: 0};\n\n  /** The length of the data bound to this viewport (in number of items). */\n  private _dataLength = 0;\n\n  /** The size of the viewport (in pixels). */\n  private _viewportSize = 0;\n\n  /** the currently attached CdkVirtualScrollRepeater. */\n  private _forOf: CdkVirtualScrollRepeater<any> | null;\n\n  /** The last rendered content offset that was set. */\n  private _renderedContentOffset = 0;\n\n  /**\n   * Whether the last rendered content offset was to the end of the content (and therefore needs to\n   * be rewritten as an offset to the start of the content).\n   */\n  private _renderedContentOffsetNeedsRewrite = false;\n\n  /** Whether there is a pending change detection cycle. */\n  private _isChangeDetectionPending = false;\n\n  /** A list of functions to run after the next change detection cycle. */\n  private _runAfterChangeDetection: Function[] = [];\n\n  /** Subscription to changes in the viewport size. */\n  private _viewportChanges = Subscription.EMPTY;\n\n  constructor(\n    public override elementRef: ElementRef<HTMLElement>,\n    private _changeDetectorRef: ChangeDetectorRef,\n    ngZone: NgZone,\n    @Optional()\n    @Inject(VIRTUAL_SCROLL_STRATEGY)\n    private _scrollStrategy: VirtualScrollStrategy,\n    @Optional() dir: Directionality,\n    scrollDispatcher: ScrollDispatcher,\n    viewportRuler: ViewportRuler,\n    @Optional() @Inject(VIRTUAL_SCROLLABLE) public scrollable: CdkVirtualScrollable,\n  ) {\n    super(elementRef, scrollDispatcher, ngZone, dir);\n\n    if (!_scrollStrategy && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\n    }\n\n    this._viewportChanges = viewportRuler.change().subscribe(() => {\n      this.checkViewportSize();\n    });\n\n    if (!this.scrollable) {\n      // No scrollable is provided, so the virtual-scroll-viewport needs to become a scrollable\n      this.elementRef.nativeElement.classList.add('cdk-virtual-scrollable');\n      this.scrollable = this;\n    }\n  }\n\n  override ngOnInit() {\n    // Scrolling depends on the element dimensions which we can't get during SSR.\n    if (!this._platform.isBrowser) {\n      return;\n    }\n\n    if (this.scrollable === this) {\n      super.ngOnInit();\n    }\n    // It's still too early to measure the viewport at this point. Deferring with a promise allows\n    // the Viewport to be rendered with the correct size before we measure. We run this outside the\n    // zone to avoid causing more change detection cycles. We handle the change detection loop\n    // ourselves instead.\n    this.ngZone.runOutsideAngular(() =>\n      Promise.resolve().then(() => {\n        this._measureViewportSize();\n        this._scrollStrategy.attach(this);\n\n        this.scrollable\n          .elementScrolled()\n          .pipe(\n            // Start off with a fake scroll event so we properly detect our initial position.\n            startWith(null),\n            // Collect multiple events into one until the next animation frame. This way if\n            // there are multiple scroll events in the same frame we only need to recheck\n            // our layout once.\n            auditTime(0, SCROLL_SCHEDULER),\n            // Usually `elementScrolled` is completed when the scrollable is destroyed, but\n            // that may not be the case if a `CdkVirtualScrollableElement` is used so we have\n            // to unsubscribe here just in case.\n            takeUntil(this._destroyed),\n          )\n          .subscribe(() => this._scrollStrategy.onContentScrolled());\n\n        this._markChangeDetectionNeeded();\n      }),\n    );\n  }\n\n  override ngOnDestroy() {\n    this.detach();\n    this._scrollStrategy.detach();\n\n    // Complete all subjects\n    this._renderedRangeSubject.complete();\n    this._detachedSubject.complete();\n    this._viewportChanges.unsubscribe();\n\n    super.ngOnDestroy();\n  }\n\n  /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */\n  attach(forOf: CdkVirtualScrollRepeater<any>) {\n    if (this._forOf && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('CdkVirtualScrollViewport is already attached.');\n    }\n\n    // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\n    // changes. Run outside the zone to avoid triggering change detection, since we're managing the\n    // change detection loop ourselves.\n    this.ngZone.runOutsideAngular(() => {\n      this._forOf = forOf;\n      this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe(data => {\n        const newLength = data.length;\n        if (newLength !== this._dataLength) {\n          this._dataLength = newLength;\n          this._scrollStrategy.onDataLengthChanged();\n        }\n        this._doChangeDetection();\n      });\n    });\n  }\n\n  /** Detaches the current `CdkVirtualForOf`. */\n  detach() {\n    this._forOf = null;\n    this._detachedSubject.next();\n  }\n\n  /** Gets the length of the data bound to this viewport (in number of items). */\n  getDataLength(): number {\n    return this._dataLength;\n  }\n\n  /** Gets the size of the viewport (in pixels). */\n  getViewportSize(): number {\n    return this._viewportSize;\n  }\n\n  // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\n  // cycle happens. I'm being careful to only call it after the render cycle is complete and before\n  // setting it to something else, but its error prone and should probably be split into\n  // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\n\n  /** Get the current rendered range of items. */\n  getRenderedRange(): ListRange {\n    return this._renderedRange;\n  }\n\n  measureBoundingClientRectWithScrollOffset(from: 'left' | 'top' | 'right' | 'bottom'): number {\n    return this.getElementRef().nativeElement.getBoundingClientRect()[from];\n  }\n\n  /**\n   * Sets the total size of all content (in pixels), including content that is not currently\n   * rendered.\n   */\n  setTotalContentSize(size: number) {\n    if (this._totalContentSize !== size) {\n      this._totalContentSize = size;\n      this._calculateSpacerSize();\n      this._markChangeDetectionNeeded();\n    }\n  }\n\n  /** Sets the currently rendered range of indices. */\n  setRenderedRange(range: ListRange) {\n    if (!rangesEqual(this._renderedRange, range)) {\n      if (this.appendOnly) {\n        range = {start: 0, end: Math.max(this._renderedRange.end, range.end)};\n      }\n      this._renderedRangeSubject.next((this._renderedRange = range));\n      this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());\n    }\n  }\n\n  /**\n   * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\n   */\n  getOffsetToRenderedContentStart(): number | null {\n    return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\n  }\n\n  /**\n   * Sets the offset from the start of the viewport to either the start or end of the rendered data\n   * (in pixels).\n   */\n  setRenderedContentOffset(offset: number, to: 'to-start' | 'to-end' = 'to-start') {\n    // In appendOnly, we always start from the top\n    offset = this.appendOnly && to === 'to-start' ? 0 : offset;\n\n    // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\n    // in the negative direction.\n    const isRtl = this.dir && this.dir.value == 'rtl';\n    const isHorizontal = this.orientation == 'horizontal';\n    const axis = isHorizontal ? 'X' : 'Y';\n    const axisDirection = isHorizontal && isRtl ? -1 : 1;\n    let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;\n    this._renderedContentOffset = offset;\n    if (to === 'to-end') {\n      transform += ` translate${axis}(-100%)`;\n      // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\n      // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\n      // expand upward).\n      this._renderedContentOffsetNeedsRewrite = true;\n    }\n    if (this._renderedContentTransform != transform) {\n      // We know this value is safe because we parse `offset` with `Number()` before passing it\n      // into the string.\n      this._renderedContentTransform = transform;\n      this._markChangeDetectionNeeded(() => {\n        if (this._renderedContentOffsetNeedsRewrite) {\n          this._renderedContentOffset -= this.measureRenderedContentSize();\n          this._renderedContentOffsetNeedsRewrite = false;\n          this.setRenderedContentOffset(this._renderedContentOffset);\n        } else {\n          this._scrollStrategy.onRenderedOffsetChanged();\n        }\n      });\n    }\n  }\n\n  /**\n   * Scrolls to the given offset from the start of the viewport. Please note that this is not always\n   * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\n   * direction, this would be the equivalent of setting a fictional `scrollRight` property.\n   * @param offset The offset to scroll to.\n   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n   */\n  scrollToOffset(offset: number, behavior: ScrollBehavior = 'auto') {\n    const options: ExtendedScrollToOptions = {behavior};\n    if (this.orientation === 'horizontal') {\n      options.start = offset;\n    } else {\n      options.top = offset;\n    }\n    this.scrollable.scrollTo(options);\n  }\n\n  /**\n   * Scrolls to the offset for the given index.\n   * @param index The index of the element to scroll to.\n   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n   */\n  scrollToIndex(index: number, behavior: ScrollBehavior = 'auto') {\n    this._scrollStrategy.scrollToIndex(index, behavior);\n  }\n\n  /**\n   * Gets the current scroll offset from the start of the scrollable (in pixels).\n   * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\n   *     in horizontal mode.\n   */\n  override measureScrollOffset(\n    from?: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end',\n  ): number {\n    // This is to break the call cycle\n    let measureScrollOffset: InstanceType<typeof CdkVirtualScrollable>['measureScrollOffset'];\n    if (this.scrollable == this) {\n      measureScrollOffset = (_from: NonNullable<typeof from>) => super.measureScrollOffset(_from);\n    } else {\n      measureScrollOffset = (_from: NonNullable<typeof from>) =>\n        this.scrollable.measureScrollOffset(_from);\n    }\n\n    return Math.max(\n      0,\n      measureScrollOffset(from ?? (this.orientation === 'horizontal' ? 'start' : 'top')) -\n        this.measureViewportOffset(),\n    );\n  }\n\n  /**\n   * Measures the offset of the viewport from the scrolling container\n   * @param from The edge to measure from.\n   */\n  measureViewportOffset(from?: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end') {\n    let fromRect: 'left' | 'top' | 'right' | 'bottom';\n    const LEFT = 'left';\n    const RIGHT = 'right';\n    const isRtl = this.dir?.value == 'rtl';\n    if (from == 'start') {\n      fromRect = isRtl ? RIGHT : LEFT;\n    } else if (from == 'end') {\n      fromRect = isRtl ? LEFT : RIGHT;\n    } else if (from) {\n      fromRect = from;\n    } else {\n      fromRect = this.orientation === 'horizontal' ? 'left' : 'top';\n    }\n\n    const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);\n    const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];\n\n    return viewportClientRect - scrollerClientRect;\n  }\n\n  /** Measure the combined size of all of the rendered items. */\n  measureRenderedContentSize(): number {\n    const contentEl = this._contentWrapper.nativeElement;\n    return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\n  }\n\n  /**\n   * Measure the total combined size of the given range. Throws if the range includes items that are\n   * not rendered.\n   */\n  measureRangeSize(range: ListRange): number {\n    if (!this._forOf) {\n      return 0;\n    }\n    return this._forOf.measureRangeSize(range, this.orientation);\n  }\n\n  /** Update the viewport dimensions and re-render. */\n  checkViewportSize() {\n    // TODO: Cleanup later when add logic for handling content resize\n    this._measureViewportSize();\n    this._scrollStrategy.onDataLengthChanged();\n  }\n\n  /** Measure the viewport size. */\n  private _measureViewportSize() {\n    this._viewportSize = this.scrollable.measureViewportSize(this.orientation);\n  }\n\n  /** Queue up change detection to run. */\n  private _markChangeDetectionNeeded(runAfter?: Function) {\n    if (runAfter) {\n      this._runAfterChangeDetection.push(runAfter);\n    }\n\n    // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\n    // properties sequentially we only have to run `_doChangeDetection` once at the end.\n    if (!this._isChangeDetectionPending) {\n      this._isChangeDetectionPending = true;\n      this.ngZone.runOutsideAngular(() =>\n        Promise.resolve().then(() => {\n          this._doChangeDetection();\n        }),\n      );\n    }\n  }\n\n  /** Run change detection. */\n  private _doChangeDetection() {\n    this._isChangeDetectionPending = false;\n\n    // Apply the content transform. The transform can't be set via an Angular binding because\n    // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\n    // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\n    // the `Number` function first to coerce it to a numeric value.\n    this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\n    // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\n    // from the root, since the repeated items are content projected in. Calling `detectChanges`\n    // instead does not properly check the projected content.\n    this.ngZone.run(() => this._changeDetectorRef.markForCheck());\n\n    const runAfterChangeDetection = this._runAfterChangeDetection;\n    this._runAfterChangeDetection = [];\n    for (const fn of runAfterChangeDetection) {\n      fn();\n    }\n  }\n\n  /** Calculates the `style.width` and `style.height` for the spacer element. */\n  private _calculateSpacerSize() {\n    this._totalContentHeight =\n      this.orientation === 'horizontal' ? '' : `${this._totalContentSize}px`;\n    this._totalContentWidth =\n      this.orientation === 'horizontal' ? `${this._totalContentSize}px` : '';\n  }\n}\n", "<!--\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\n  position.\n-->\n<div #contentWrapper class=\"cdk-virtual-scroll-content-wrapper\">\n  <ng-content></ng-content>\n</div>\n<!--\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\n  so that the scrollbar captures the size of the entire data set.\n-->\n<div class=\"cdk-virtual-scroll-spacer\"\n     [style.width]=\"_totalContentWidth\" [style.height]=\"_totalContentHeight\"></div>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ArrayDataSource,\n  CollectionViewer,\n  DataSource,\n  ListRange,\n  isDataSource,\n  _RecycleViewRepeaterStrategy,\n  _VIEW_REPEATER_STRATEGY,\n  _ViewRepeaterItemInsertArgs,\n} from '@angular/cdk/collections';\nimport {\n  Directive,\n  DoCheck,\n  EmbeddedViewRef,\n  Inject,\n  Input,\n  IterableChangeRecord,\n  IterableChanges,\n  IterableDiffer,\n  IterableDiffers,\n  NgIterable,\n  NgZone,\n  OnDestroy,\n  SkipSelf,\n  TemplateRef,\n  TrackByFunction,\n  ViewContainerRef,\n} from '@angular/core';\nimport {NumberInput, coerceNumberProperty} from '@angular/cdk/coercion';\nimport {Observable, Subject, of as observableOf, isObservable} from 'rxjs';\nimport {pairwise, shareReplay, startWith, switchMap, takeUntil} from 'rxjs/operators';\nimport {CdkVirtualScrollRepeater} from './virtual-scroll-repeater';\nimport {CdkVirtualScrollViewport} from './virtual-scroll-viewport';\n\n/** The context for an item rendered by `CdkVirtualForOf` */\nexport type CdkVirtualForOfContext<T> = {\n  /** The item value. */\n  $implicit: T;\n  /** The DataSource, Observable, or NgIterable that was passed to *cdkVirtualFor. */\n  cdkVirtualForOf: DataSource<T> | Observable<T[]> | NgIterable<T>;\n  /** The index of the item in the DataSource. */\n  index: number;\n  /** The number of items in the DataSource. */\n  count: number;\n  /** Whether this is the first item in the DataSource. */\n  first: boolean;\n  /** Whether this is the last item in the DataSource. */\n  last: boolean;\n  /** Whether the index is even. */\n  even: boolean;\n  /** Whether the index is odd. */\n  odd: boolean;\n};\n\n/** Helper to extract the offset of a DOM Node in a certain direction. */\nfunction getOffset(orientation: 'horizontal' | 'vertical', direction: 'start' | 'end', node: Node) {\n  const el = node as Element;\n  if (!el.getBoundingClientRect) {\n    return 0;\n  }\n  const rect = el.getBoundingClientRect();\n\n  if (orientation === 'horizontal') {\n    return direction === 'start' ? rect.left : rect.right;\n  }\n\n  return direction === 'start' ? rect.top : rect.bottom;\n}\n\n/**\n * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling\n * container.\n */\n@Directive({\n  selector: '[cdkVirtualFor][cdkVirtualForOf]',\n  providers: [{provide: _VIEW_REPEATER_STRATEGY, useClass: _RecycleViewRepeaterStrategy}],\n  standalone: true,\n})\nexport class CdkVirtualForOf<T>\n  implements CdkVirtualScrollRepeater<T>, CollectionViewer, DoCheck, OnDestroy\n{\n  /** Emits when the rendered view of the data changes. */\n  readonly viewChange = new Subject<ListRange>();\n\n  /** Subject that emits when a new DataSource instance is given. */\n  private readonly _dataSourceChanges = new Subject<DataSource<T>>();\n\n  /** The DataSource to display. */\n  @Input()\n  get cdkVirtualForOf(): DataSource<T> | Observable<T[]> | NgIterable<T> | null | undefined {\n    return this._cdkVirtualForOf;\n  }\n  set cdkVirtualForOf(value: DataSource<T> | Observable<T[]> | NgIterable<T> | null | undefined) {\n    this._cdkVirtualForOf = value;\n    if (isDataSource(value)) {\n      this._dataSourceChanges.next(value);\n    } else {\n      // If value is an an NgIterable, convert it to an array.\n      this._dataSourceChanges.next(\n        new ArrayDataSource<T>(isObservable(value) ? value : Array.from(value || [])),\n      );\n    }\n  }\n\n  _cdkVirtualForOf: DataSource<T> | Observable<T[]> | NgIterable<T> | null | undefined;\n\n  /**\n   * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\n   * the item and produces a value to be used as the item's identity when tracking changes.\n   */\n  @Input()\n  get cdkVirtualForTrackBy(): TrackByFunction<T> | undefined {\n    return this._cdkVirtualForTrackBy;\n  }\n  set cdkVirtualForTrackBy(fn: TrackByFunction<T> | undefined) {\n    this._needsUpdate = true;\n    this._cdkVirtualForTrackBy = fn\n      ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item)\n      : undefined;\n  }\n  private _cdkVirtualForTrackBy: TrackByFunction<T> | undefined;\n\n  /** The template used to stamp out new elements. */\n  @Input()\n  set cdkVirtualForTemplate(value: TemplateRef<CdkVirtualForOfContext<T>>) {\n    if (value) {\n      this._needsUpdate = true;\n      this._template = value;\n    }\n  }\n\n  /**\n   * The size of the cache used to store templates that are not being used for re-use later.\n   * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\n   */\n  @Input()\n  get cdkVirtualForTemplateCacheSize(): number {\n    return this._viewRepeater.viewCacheSize;\n  }\n  set cdkVirtualForTemplateCacheSize(size: NumberInput) {\n    this._viewRepeater.viewCacheSize = coerceNumberProperty(size);\n  }\n\n  /** Emits whenever the data in the current DataSource changes. */\n  readonly dataStream: Observable<readonly T[]> = this._dataSourceChanges.pipe(\n    // Start off with null `DataSource`.\n    startWith(null),\n    // Bundle up the previous and current data sources so we can work with both.\n    pairwise(),\n    // Use `_changeDataSource` to disconnect from the previous data source and connect to the\n    // new one, passing back a stream of data changes which we run through `switchMap` to give\n    // us a data stream that emits the latest data from whatever the current `DataSource` is.\n    switchMap(([prev, cur]) => this._changeDataSource(prev, cur)),\n    // Replay the last emitted data when someone subscribes.\n    shareReplay(1),\n  );\n\n  /** The differ used to calculate changes to the data. */\n  private _differ: IterableDiffer<T> | null = null;\n\n  /** The most recent data emitted from the DataSource. */\n  private _data: readonly T[];\n\n  /** The currently rendered items. */\n  private _renderedItems: T[];\n\n  /** The currently rendered range of indices. */\n  private _renderedRange: ListRange;\n\n  /** Whether the rendered data should be updated during the next ngDoCheck cycle. */\n  private _needsUpdate = false;\n\n  private readonly _destroyed = new Subject<void>();\n\n  constructor(\n    /** The view container to add items to. */\n    private _viewContainerRef: ViewContainerRef,\n    /** The template to use when stamping out new items. */\n    private _template: TemplateRef<CdkVirtualForOfContext<T>>,\n    /** The set of available differs. */\n    private _differs: IterableDiffers,\n    /** The strategy used to render items in the virtual scroll viewport. */\n    @Inject(_VIEW_REPEATER_STRATEGY)\n    private _viewRepeater: _RecycleViewRepeaterStrategy<T, T, CdkVirtualForOfContext<T>>,\n    /** The virtual scrolling viewport that these items are being rendered in. */\n    @SkipSelf() private _viewport: CdkVirtualScrollViewport,\n    ngZone: NgZone,\n  ) {\n    this.dataStream.subscribe(data => {\n      this._data = data;\n      this._onRenderedDataChange();\n    });\n    this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe(range => {\n      this._renderedRange = range;\n      if (this.viewChange.observers.length) {\n        ngZone.run(() => this.viewChange.next(this._renderedRange));\n      }\n      this._onRenderedDataChange();\n    });\n    this._viewport.attach(this);\n  }\n\n  /**\n   * Measures the combined size (width for horizontal orientation, height for vertical) of all items\n   * in the specified range. Throws an error if the range includes items that are not currently\n   * rendered.\n   */\n  measureRangeSize(range: ListRange, orientation: 'horizontal' | 'vertical'): number {\n    if (range.start >= range.end) {\n      return 0;\n    }\n    if (\n      (range.start < this._renderedRange.start || range.end > this._renderedRange.end) &&\n      (typeof ngDevMode === 'undefined' || ngDevMode)\n    ) {\n      throw Error(`Error: attempted to measure an item that isn't rendered.`);\n    }\n\n    // The index into the list of rendered views for the first item in the range.\n    const renderedStartIndex = range.start - this._renderedRange.start;\n    // The length of the range we're measuring.\n    const rangeLen = range.end - range.start;\n\n    // Loop over all the views, find the first and land node and compute the size by subtracting\n    // the top of the first node from the bottom of the last one.\n    let firstNode: HTMLElement | undefined;\n    let lastNode: HTMLElement | undefined;\n\n    // Find the first node by starting from the beginning and going forwards.\n    for (let i = 0; i < rangeLen; i++) {\n      const view = this._viewContainerRef.get(i + renderedStartIndex) as EmbeddedViewRef<\n        CdkVirtualForOfContext<T>\n      > | null;\n      if (view && view.rootNodes.length) {\n        firstNode = lastNode = view.rootNodes[0];\n        break;\n      }\n    }\n\n    // Find the last node by starting from the end and going backwards.\n    for (let i = rangeLen - 1; i > -1; i--) {\n      const view = this._viewContainerRef.get(i + renderedStartIndex) as EmbeddedViewRef<\n        CdkVirtualForOfContext<T>\n      > | null;\n      if (view && view.rootNodes.length) {\n        lastNode = view.rootNodes[view.rootNodes.length - 1];\n        break;\n      }\n    }\n\n    return firstNode && lastNode\n      ? getOffset(orientation, 'end', lastNode) - getOffset(orientation, 'start', firstNode)\n      : 0;\n  }\n\n  ngDoCheck() {\n    if (this._differ && this._needsUpdate) {\n      // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of\n      // this list being rendered (can use simpler algorithm) vs needs update due to data actually\n      // changing (need to do this diff).\n      const changes = this._differ.diff(this._renderedItems);\n      if (!changes) {\n        this._updateContext();\n      } else {\n        this._applyChanges(changes);\n      }\n      this._needsUpdate = false;\n    }\n  }\n\n  ngOnDestroy() {\n    this._viewport.detach();\n\n    this._dataSourceChanges.next(undefined!);\n    this._dataSourceChanges.complete();\n    this.viewChange.complete();\n\n    this._destroyed.next();\n    this._destroyed.complete();\n    this._viewRepeater.detach();\n  }\n\n  /** React to scroll state changes in the viewport. */\n  private _onRenderedDataChange() {\n    if (!this._renderedRange) {\n      return;\n    }\n    this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);\n    if (!this._differ) {\n      // Use a wrapper function for the `trackBy` so any new values are\n      // picked up automatically without having to recreate the differ.\n      this._differ = this._differs.find(this._renderedItems).create((index, item) => {\n        return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;\n      });\n    }\n    this._needsUpdate = true;\n  }\n\n  /** Swap out one `DataSource` for another. */\n  private _changeDataSource(\n    oldDs: DataSource<T> | null,\n    newDs: DataSource<T> | null,\n  ): Observable<readonly T[]> {\n    if (oldDs) {\n      oldDs.disconnect(this);\n    }\n\n    this._needsUpdate = true;\n    return newDs ? newDs.connect(this) : observableOf();\n  }\n\n  /** Update the `CdkVirtualForOfContext` for all views. */\n  private _updateContext() {\n    const count = this._data.length;\n    let i = this._viewContainerRef.length;\n    while (i--) {\n      const view = this._viewContainerRef.get(i) as EmbeddedViewRef<CdkVirtualForOfContext<T>>;\n      view.context.index = this._renderedRange.start + i;\n      view.context.count = count;\n      this._updateComputedContextProperties(view.context);\n      view.detectChanges();\n    }\n  }\n\n  /** Apply changes to the DOM. */\n  private _applyChanges(changes: IterableChanges<T>) {\n    this._viewRepeater.applyChanges(\n      changes,\n      this._viewContainerRef,\n      (\n        record: IterableChangeRecord<T>,\n        _adjustedPreviousIndex: number | null,\n        currentIndex: number | null,\n      ) => this._getEmbeddedViewArgs(record, currentIndex!),\n      record => record.item,\n    );\n\n    // Update $implicit for any items that had an identity change.\n    changes.forEachIdentityChange((record: IterableChangeRecord<T>) => {\n      const view = this._viewContainerRef.get(record.currentIndex!) as EmbeddedViewRef<\n        CdkVirtualForOfContext<T>\n      >;\n      view.context.$implicit = record.item;\n    });\n\n    // Update the context variables on all items.\n    const count = this._data.length;\n    let i = this._viewContainerRef.length;\n    while (i--) {\n      const view = this._viewContainerRef.get(i) as EmbeddedViewRef<CdkVirtualForOfContext<T>>;\n      view.context.index = this._renderedRange.start + i;\n      view.context.count = count;\n      this._updateComputedContextProperties(view.context);\n    }\n  }\n\n  /** Update the computed properties on the `CdkVirtualForOfContext`. */\n  private _updateComputedContextProperties(context: CdkVirtualForOfContext<any>) {\n    context.first = context.index === 0;\n    context.last = context.index === context.count - 1;\n    context.even = context.index % 2 === 0;\n    context.odd = !context.even;\n  }\n\n  private _getEmbeddedViewArgs(\n    record: IterableChangeRecord<T>,\n    index: number,\n  ): _ViewRepeaterItemInsertArgs<CdkVirtualForOfContext<T>> {\n    // Note that it's important that we insert the item directly at the proper index,\n    // rather than inserting it and the moving it in place, because if there's a directive\n    // on the same node that injects the `ViewContainerRef`, Angular will insert another\n    // comment node which can throw off the move when it's being repeated for all items.\n    return {\n      templateRef: this._template,\n      context: {\n        $implicit: record.item,\n        // It's guaranteed that the iterable is not \"undefined\" or \"null\" because we only\n        // generate views for elements if the \"cdkVirtualForOf\" iterable has elements.\n        cdkVirtualForOf: this._cdkVirtualForOf!,\n        index: -1,\n        count: -1,\n        first: false,\n        last: false,\n        odd: false,\n        even: false,\n      },\n      index,\n    };\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {Directive, ElementRef, NgZone, Optional} from '@angular/core';\nimport {ScrollDispatcher} from './scroll-dispatcher';\nimport {CdkVirtualScrollable, VIRTUAL_SCROLLABLE} from './virtual-scrollable';\n\n/**\n * Provides a virtual scrollable for the element it is attached to.\n */\n@Directive({\n  selector: '[cdkVirtualScrollingElement]',\n  providers: [{provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableElement}],\n  standalone: true,\n  host: {\n    'class': 'cdk-virtual-scrollable',\n  },\n})\nexport class CdkVirtualScrollableElement extends CdkVirtualScrollable {\n  constructor(\n    elementRef: ElementRef,\n    scrollDispatcher: ScrollDispatcher,\n    ngZone: NgZone,\n    @Optional() dir: Directionality,\n  ) {\n    super(elementRef, scrollDispatcher, ngZone, dir);\n  }\n\n  override measureBoundingClientRectWithScrollOffset(\n    from: 'left' | 'top' | 'right' | 'bottom',\n  ): number {\n    return (\n      this.getElementRef().nativeElement.getBoundingClientRect()[from] -\n      this.measureScrollOffset(from)\n    );\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {Directive, ElementRef, NgZone, Optional} from '@angular/core';\nimport {fromEvent, Observable, Observer} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\nimport {ScrollDispatcher} from './scroll-dispatcher';\nimport {CdkVirtualScrollable, VIRTUAL_SCROLLABLE} from './virtual-scrollable';\n\n/**\n * Provides as virtual scrollable for the global / window scrollbar.\n */\n@Directive({\n  selector: 'cdk-virtual-scroll-viewport[scrollWindow]',\n  providers: [{provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableWindow}],\n  standalone: true,\n})\nexport class CdkVirtualScrollableWindow extends CdkVirtualScrollable {\n  protected override _elementScrolled: Observable<Event> = new Observable(\n    (observer: Observer<Event>) =>\n      this.ngZone.runOutsideAngular(() =>\n        fromEvent(document, 'scroll').pipe(takeUntil(this._destroyed)).subscribe(observer),\n      ),\n  );\n\n  constructor(scrollDispatcher: ScrollDispatcher, ngZone: NgZone, @Optional() dir: Directionality) {\n    super(new ElementRef(document.documentElement), scrollDispatcher, ngZone, dir);\n  }\n\n  override measureBoundingClientRectWithScrollOffset(\n    from: 'left' | 'top' | 'right' | 'bottom',\n  ): number {\n    return this.getElementRef().nativeElement.getBoundingClientRect()[from];\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BidiModule} from '@angular/cdk/bidi';\nimport {NgModule} from '@angular/core';\nimport {CdkFixedSizeVirtualScroll} from './fixed-size-virtual-scroll';\nimport {CdkScrollable} from './scrollable';\nimport {CdkVirtualForOf} from './virtual-for-of';\nimport {CdkVirtualScrollViewport} from './virtual-scroll-viewport';\nimport {CdkVirtualScrollableElement} from './virtual-scrollable-element';\nimport {CdkVirtualScrollableWindow} from './virtual-scrollable-window';\n\n@NgModule({\n  exports: [CdkScrollable],\n  imports: [CdkScrollable],\n})\nexport class CdkScrollableModule {}\n\n/**\n * @docs-primary-export\n */\n@NgModule({\n  imports: [\n    BidiModule,\n    CdkScrollableModule,\n    CdkVirtualScrollViewport,\n    CdkFixedSizeVirtualScroll,\n    CdkVirtualForOf,\n    CdkVirtualScrollableWindow,\n    CdkVirtualScrollableElement,\n  ],\n  exports: [\n    BidiModule,\n    CdkScrollableModule,\n    CdkFixedSizeVirtualScroll,\n    CdkVirtualForOf,\n    CdkVirtualScrollViewport,\n    CdkVirtualScrollableWindow,\n    CdkVirtualScrollableElement,\n  ],\n})\nexport class ScrollingModule {}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * @docs-private\n */\nexport function throwNullPortalError() {\n  throw Error('Must provide a portal to attach');\n}\n\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * @docs-private\n */\nexport function throwPortalAlreadyAttachedError() {\n  throw Error('Host already has a portal attached');\n}\n\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * @docs-private\n */\nexport function throwPortalOutletAlreadyDisposedError() {\n  throw Error('This PortalOutlet has already been disposed');\n}\n\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * @docs-private\n */\nexport function throwUnknownPortalTypeError() {\n  throw Error(\n    'Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n      'a ComponentPortal or a TemplatePortal.',\n  );\n}\n\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * @docs-private\n */\nexport function throwNullPortalOutletError() {\n  throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * @docs-private\n */\nexport function throwNoPortalAttachedError() {\n  throw Error('Attempting to detach a portal that is not attached to a host');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  TemplateRef,\n  ViewContainerRef,\n  ElementRef,\n  ComponentRef,\n  EmbeddedViewRef,\n  Injector,\n  ComponentFactoryResolver,\n} from '@angular/core';\nimport {\n  throwNullPortalOutletError,\n  throwPortalAlreadyAttachedError,\n  throwNoPortalAttachedError,\n  throwNullPortalError,\n  throwPortalOutletAlreadyDisposedError,\n  throwUnknownPortalTypeError,\n} from './portal-errors';\n\n/** Interface that can be used to generically type a class. */\nexport interface ComponentType<T> {\n  new (...args: any[]): T;\n}\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\nexport abstract class Portal<T> {\n  private _attachedHost: PortalOutlet | null;\n\n  /** Attach this portal to a host. */\n  attach(host: PortalOutlet): T {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (host == null) {\n        throwNullPortalOutletError();\n      }\n\n      if (host.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n    }\n\n    this._attachedHost = host;\n    return <T>host.attach(this);\n  }\n\n  /** Detach this portal from its host */\n  detach(): void {\n    let host = this._attachedHost;\n\n    if (host != null) {\n      this._attachedHost = null;\n      host.detach();\n    } else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throwNoPortalAttachedError();\n    }\n  }\n\n  /** Whether this portal is attached to a host. */\n  get isAttached(): boolean {\n    return this._attachedHost != null;\n  }\n\n  /**\n   * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n   * the PortalOutlet when it is performing an `attach()` or `detach()`.\n   */\n  setAttachedHost(host: PortalOutlet | null) {\n    this._attachedHost = host;\n  }\n}\n\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nexport class ComponentPortal<T> extends Portal<ComponentRef<T>> {\n  /** The type of the component that will be instantiated for attachment. */\n  component: ComponentType<T>;\n\n  /**\n   * Where the attached component should live in Angular's *logical* component tree.\n   * This is different from where the component *renders*, which is determined by the PortalOutlet.\n   * The origin is necessary when the host is outside of the Angular application context.\n   */\n  viewContainerRef?: ViewContainerRef | null;\n\n  /** Injector used for the instantiation of the component. */\n  injector?: Injector | null;\n\n  /**\n   * Alternate `ComponentFactoryResolver` to use when resolving the associated component.\n   * Defaults to using the resolver from the outlet that the portal is attached to.\n   */\n  componentFactoryResolver?: ComponentFactoryResolver | null;\n\n  /**\n   * List of DOM nodes that should be projected through `<ng-content>` of the attached component.\n   */\n  projectableNodes?: Node[][] | null;\n\n  constructor(\n    component: ComponentType<T>,\n    viewContainerRef?: ViewContainerRef | null,\n    injector?: Injector | null,\n    componentFactoryResolver?: ComponentFactoryResolver | null,\n    projectableNodes?: Node[][] | null,\n  ) {\n    super();\n    this.component = component;\n    this.viewContainerRef = viewContainerRef;\n    this.injector = injector;\n    this.componentFactoryResolver = componentFactoryResolver;\n    this.projectableNodes = projectableNodes;\n  }\n}\n\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nexport class TemplatePortal<C = any> extends Portal<EmbeddedViewRef<C>> {\n  constructor(\n    /** The embedded template that will be used to instantiate an embedded View in the host. */\n    public templateRef: TemplateRef<C>,\n    /** Reference to the ViewContainer into which the template will be stamped out. */\n    public viewContainerRef: ViewContainerRef,\n    /** Contextual data to be passed in to the embedded view. */\n    public context?: C,\n    /** The injector to use for the embedded view. */\n    public injector?: Injector,\n  ) {\n    super();\n  }\n\n  get origin(): ElementRef {\n    return this.templateRef.elementRef;\n  }\n\n  /**\n   * Attach the portal to the provided `PortalOutlet`.\n   * When a context is provided it will override the `context` property of the `TemplatePortal`\n   * instance.\n   */\n  override attach(host: PortalOutlet, context: C | undefined = this.context): EmbeddedViewRef<C> {\n    this.context = context;\n    return super.attach(host);\n  }\n\n  override detach(): void {\n    this.context = undefined;\n    return super.detach();\n  }\n}\n\n/**\n * A `DomPortal` is a portal whose DOM element will be taken from its current position\n * in the DOM and moved into a portal outlet, when it is attached. On detach, the content\n * will be restored to its original position.\n */\nexport class DomPortal<T = HTMLElement> extends Portal<T> {\n  /** DOM node hosting the portal's content. */\n  readonly element: T;\n\n  constructor(element: T | ElementRef<T>) {\n    super();\n    this.element = element instanceof ElementRef ? element.nativeElement : element;\n  }\n}\n\n/** A `PortalOutlet` is an space that can contain a single `Portal`. */\nexport interface PortalOutlet {\n  /** Attaches a portal to this outlet. */\n  attach(portal: Portal<any>): any;\n\n  /** Detaches the currently attached portal from this outlet. */\n  detach(): any;\n\n  /** Performs cleanup before the outlet is destroyed. */\n  dispose(): void;\n\n  /** Whether there is currently a portal attached to this outlet. */\n  hasAttached(): boolean;\n}\n\n/**\n * @deprecated Use `PortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nexport type PortalHost = PortalOutlet;\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\nexport abstract class BasePortalOutlet implements PortalOutlet {\n  /** The portal currently attached to the host. */\n  protected _attachedPortal: Portal<any> | null;\n\n  /** A function that will permanently dispose this host. */\n  private _disposeFn: (() => void) | null;\n\n  /** Whether this host has already been permanently disposed. */\n  private _isDisposed: boolean = false;\n\n  /** Whether this host has an attached portal. */\n  hasAttached(): boolean {\n    return !!this._attachedPortal;\n  }\n\n  attach<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n  attach<T>(portal: TemplatePortal<T>): EmbeddedViewRef<T>;\n  attach(portal: any): any;\n\n  /** Attaches a portal. */\n  attach(portal: Portal<any>): any {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!portal) {\n        throwNullPortalError();\n      }\n\n      if (this.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n\n      if (this._isDisposed) {\n        throwPortalOutletAlreadyDisposedError();\n      }\n    }\n\n    if (portal instanceof ComponentPortal) {\n      this._attachedPortal = portal;\n      return this.attachComponentPortal(portal);\n    } else if (portal instanceof TemplatePortal) {\n      this._attachedPortal = portal;\n      return this.attachTemplatePortal(portal);\n      // @breaking-change 10.0.0 remove null check for `this.attachDomPortal`.\n    } else if (this.attachDomPortal && portal instanceof DomPortal) {\n      this._attachedPortal = portal;\n      return this.attachDomPortal(portal);\n    }\n\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throwUnknownPortalTypeError();\n    }\n  }\n\n  abstract attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n\n  abstract attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C>;\n\n  // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.\n  readonly attachDomPortal: null | ((portal: DomPortal) => any) = null;\n\n  /** Detaches a previously attached portal. */\n  detach(): void {\n    if (this._attachedPortal) {\n      this._attachedPortal.setAttachedHost(null);\n      this._attachedPortal = null;\n    }\n\n    this._invokeDisposeFn();\n  }\n\n  /** Permanently dispose of this portal host. */\n  dispose(): void {\n    if (this.hasAttached()) {\n      this.detach();\n    }\n\n    this._invokeDisposeFn();\n    this._isDisposed = true;\n  }\n\n  /** @docs-private */\n  setDisposeFn(fn: () => void) {\n    this._disposeFn = fn;\n  }\n\n  private _invokeDisposeFn() {\n    if (this._disposeFn) {\n      this._disposeFn();\n      this._disposeFn = null;\n    }\n  }\n}\n\n/**\n * @deprecated Use `BasePortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nexport abstract class BasePortalHost extends BasePortalOutlet {}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ApplicationRef,\n  ComponentFactoryResolver,\n  ComponentRef,\n  EmbeddedViewRef,\n  Injector,\n} from '@angular/core';\nimport {BasePortalOutlet, ComponentPortal, DomPortal, TemplatePortal} from './portal';\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nexport class DomPortalOutlet extends BasePortalOutlet {\n  private _document: Document;\n\n  /**\n   * @param outletElement Element into which the content is projected.\n   * @param _componentFactoryResolver Used to resolve the component factory.\n   *   Only required when attaching component portals.\n   * @param _appRef Reference to the application. Only used in component portals when there\n   *   is no `ViewContainerRef` available.\n   * @param _defaultInjector Injector to use as a fallback when the portal being attached doesn't\n   *   have one. Only used for component portals.\n   * @param _document Reference to the document. Used when attaching a DOM portal. Will eventually\n   *   become a required parameter.\n   */\n  constructor(\n    /** Element into which the content is projected. */\n    public outletElement: Element,\n    private _componentFactoryResolver?: ComponentFactoryResolver,\n    private _appRef?: ApplicationRef,\n    private _defaultInjector?: Injector,\n\n    /**\n     * @deprecated `_document` Parameter to be made required.\n     * @breaking-change 10.0.0\n     */\n    _document?: any,\n  ) {\n    super();\n    this._document = _document;\n  }\n\n  /**\n   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n   * @param portal Portal to be attached\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    const resolver = (portal.componentFactoryResolver || this._componentFactoryResolver)!;\n\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !resolver) {\n      throw Error('Cannot attach component portal to outlet without a ComponentFactoryResolver.');\n    }\n\n    const componentFactory = resolver.resolveComponentFactory(portal.component);\n    let componentRef: ComponentRef<T>;\n\n    // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n    // for the component (in terms of Angular's component tree, not rendering).\n    // When the ViewContainerRef is missing, we use the factory to create the component directly\n    // and then manually attach the view to the application.\n    if (portal.viewContainerRef) {\n      componentRef = portal.viewContainerRef.createComponent(\n        componentFactory,\n        portal.viewContainerRef.length,\n        portal.injector || portal.viewContainerRef.injector,\n        portal.projectableNodes || undefined,\n      );\n\n      this.setDisposeFn(() => componentRef.destroy());\n    } else {\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && !this._appRef) {\n        throw Error('Cannot attach component portal to outlet without an ApplicationRef.');\n      }\n\n      componentRef = componentFactory.create(\n        portal.injector || this._defaultInjector || Injector.NULL,\n      );\n      this._appRef!.attachView(componentRef.hostView);\n      this.setDisposeFn(() => {\n        // Verify that the ApplicationRef has registered views before trying to detach a host view.\n        // This check also protects the `detachView` from being called on a destroyed ApplicationRef.\n        if (this._appRef!.viewCount > 0) {\n          this._appRef!.detachView(componentRef.hostView);\n        }\n        componentRef.destroy();\n      });\n    }\n    // At this point the component has been instantiated, so we move it to the location in the DOM\n    // where we want it to be rendered.\n    this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n    this._attachedPortal = portal;\n\n    return componentRef;\n  }\n\n  /**\n   * Attaches a template portal to the DOM as an embedded view.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n    let viewContainer = portal.viewContainerRef;\n    let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context, {\n      injector: portal.injector,\n    });\n\n    // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n    // But for the DomPortalOutlet the view can be added everywhere in the DOM\n    // (e.g Overlay Container) To move the view to the specified host element. We just\n    // re-append the existing root nodes.\n    viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode));\n\n    // Note that we want to detect changes after the nodes have been moved so that\n    // any directives inside the portal that are looking at the DOM inside a lifecycle\n    // hook won't be invoked too early.\n    viewRef.detectChanges();\n\n    this.setDisposeFn(() => {\n      let index = viewContainer.indexOf(viewRef);\n      if (index !== -1) {\n        viewContainer.remove(index);\n      }\n    });\n\n    this._attachedPortal = portal;\n\n    // TODO(jelbourn): Return locals from view.\n    return viewRef;\n  }\n\n  /**\n   * Attaches a DOM portal by transferring its content into the outlet.\n   * @param portal Portal to be attached.\n   * @deprecated To be turned into a method.\n   * @breaking-change 10.0.0\n   */\n  override attachDomPortal = (portal: DomPortal) => {\n    // @breaking-change 10.0.0 Remove check and error once the\n    // `_document` constructor parameter is required.\n    if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('Cannot attach DOM portal without _document constructor parameter');\n    }\n\n    const element = portal.element;\n    if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('DOM portal content must be attached to a parent node.');\n    }\n\n    // Anchor used to save the element's previous position so\n    // that we can restore it when the portal is detached.\n    const anchorNode = this._document.createComment('dom-portal');\n\n    element.parentNode!.insertBefore(anchorNode, element);\n    this.outletElement.appendChild(element);\n    this._attachedPortal = portal;\n\n    super.setDisposeFn(() => {\n      // We can't use `replaceWith` here because IE doesn't support it.\n      if (anchorNode.parentNode) {\n        anchorNode.parentNode.replaceChild(element, anchorNode);\n      }\n    });\n  };\n\n  /**\n   * Clears out a portal from the DOM.\n   */\n  override dispose(): void {\n    super.dispose();\n    this.outletElement.remove();\n  }\n\n  /** Gets the root HTMLElement for an instantiated component. */\n  private _getComponentRootNode(componentRef: ComponentRef<any>): HTMLElement {\n    return (componentRef.hostView as EmbeddedViewRef<any>).rootNodes[0] as HTMLElement;\n  }\n}\n\n/**\n * @deprecated Use `DomPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nexport class DomPortalHost extends DomPortalOutlet {}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ComponentFactoryResolver,\n  ComponentRef,\n  Directive,\n  EmbeddedViewRef,\n  EventEmitter,\n  NgModule,\n  OnDestroy,\n  OnInit,\n  Output,\n  TemplateRef,\n  ViewContainerRef,\n  Inject,\n} from '@angular/core';\nimport {DOCUMENT} from '@angular/common';\nimport {BasePortalOutlet, ComponentPortal, Portal, TemplatePortal, DomPortal} from './portal';\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\n@Directive({\n  selector: '[cdkPortal]',\n  exportAs: 'cdkPortal',\n})\nexport class CdkPortal extends TemplatePortal {\n  constructor(templateRef: TemplateRef<any>, viewContainerRef: ViewContainerRef) {\n    super(templateRef, viewContainerRef);\n  }\n}\n\n/**\n * @deprecated Use `CdkPortal` instead.\n * @breaking-change 9.0.0\n */\n@Directive({\n  selector: '[cdk-portal], [portal]',\n  exportAs: 'cdkPortal',\n  providers: [\n    {\n      provide: CdkPortal,\n      useExisting: TemplatePortalDirective,\n    },\n  ],\n})\nexport class TemplatePortalDirective extends CdkPortal {}\n\n/**\n * Possible attached references to the CdkPortalOutlet.\n */\nexport type CdkPortalOutletAttachedRef = ComponentRef<any> | EmbeddedViewRef<any> | null;\n\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\n@Directive({\n  selector: '[cdkPortalOutlet]',\n  exportAs: 'cdkPortalOutlet',\n  inputs: ['portal: cdkPortalOutlet'],\n})\nexport class CdkPortalOutlet extends BasePortalOutlet implements OnInit, OnDestroy {\n  private _document: Document;\n\n  /** Whether the portal component is initialized. */\n  private _isInitialized = false;\n\n  /** Reference to the currently-attached component/view ref. */\n  private _attachedRef: CdkPortalOutletAttachedRef;\n\n  constructor(\n    private _componentFactoryResolver: ComponentFactoryResolver,\n    private _viewContainerRef: ViewContainerRef,\n\n    /**\n     * @deprecated `_document` parameter to be made required.\n     * @breaking-change 9.0.0\n     */\n    @Inject(DOCUMENT) _document?: any,\n  ) {\n    super();\n    this._document = _document;\n  }\n\n  /** Portal associated with the Portal outlet. */\n  get portal(): Portal<any> | null {\n    return this._attachedPortal;\n  }\n\n  set portal(portal: Portal<any> | null | undefined | '') {\n    // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n    // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n    // and attach a portal programmatically in the parent component. When Angular does the first CD\n    // round, it will fire the setter with empty string, causing the user's content to be cleared.\n    if (this.hasAttached() && !portal && !this._isInitialized) {\n      return;\n    }\n\n    if (this.hasAttached()) {\n      super.detach();\n    }\n\n    if (portal) {\n      super.attach(portal);\n    }\n\n    this._attachedPortal = portal || null;\n  }\n\n  /** Emits when a portal is attached to the outlet. */\n  @Output() readonly attached: EventEmitter<CdkPortalOutletAttachedRef> =\n    new EventEmitter<CdkPortalOutletAttachedRef>();\n\n  /** Component or view reference that is attached to the portal. */\n  get attachedRef(): CdkPortalOutletAttachedRef {\n    return this._attachedRef;\n  }\n\n  ngOnInit() {\n    this._isInitialized = true;\n  }\n\n  ngOnDestroy() {\n    super.dispose();\n    this._attachedRef = this._attachedPortal = null;\n  }\n\n  /**\n   * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n   *\n   * @param portal Portal to be attached to the portal outlet.\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    portal.setAttachedHost(this);\n\n    // If the portal specifies an origin, use that as the logical location of the component\n    // in the application tree. Otherwise use the location of this PortalOutlet.\n    const viewContainerRef =\n      portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;\n\n    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n    const componentFactory = resolver.resolveComponentFactory(portal.component);\n    const ref = viewContainerRef.createComponent(\n      componentFactory,\n      viewContainerRef.length,\n      portal.injector || viewContainerRef.injector,\n      portal.projectableNodes || undefined,\n    );\n\n    // If we're using a view container that's different from the injected one (e.g. when the portal\n    // specifies its own) we need to move the component into the outlet, otherwise it'll be rendered\n    // inside of the alternate view container.\n    if (viewContainerRef !== this._viewContainerRef) {\n      this._getRootNode().appendChild((ref.hostView as EmbeddedViewRef<any>).rootNodes[0]);\n    }\n\n    super.setDisposeFn(() => ref.destroy());\n    this._attachedPortal = portal;\n    this._attachedRef = ref;\n    this.attached.emit(ref);\n\n    return ref;\n  }\n\n  /**\n   * Attach the given TemplatePortal to this PortalHost as an embedded View.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n    portal.setAttachedHost(this);\n    const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context, {\n      injector: portal.injector,\n    });\n    super.setDisposeFn(() => this._viewContainerRef.clear());\n\n    this._attachedPortal = portal;\n    this._attachedRef = viewRef;\n    this.attached.emit(viewRef);\n\n    return viewRef;\n  }\n\n  /**\n   * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.\n   * @param portal Portal to be attached.\n   * @deprecated To be turned into a method.\n   * @breaking-change 10.0.0\n   */\n  override attachDomPortal = (portal: DomPortal) => {\n    // @breaking-change 9.0.0 Remove check and error once the\n    // `_document` constructor parameter is required.\n    if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('Cannot attach DOM portal without _document constructor parameter');\n    }\n\n    const element = portal.element;\n    if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('DOM portal content must be attached to a parent node.');\n    }\n\n    // Anchor used to save the element's previous position so\n    // that we can restore it when the portal is detached.\n    const anchorNode = this._document.createComment('dom-portal');\n\n    portal.setAttachedHost(this);\n    element.parentNode!.insertBefore(anchorNode, element);\n    this._getRootNode().appendChild(element);\n    this._attachedPortal = portal;\n\n    super.setDisposeFn(() => {\n      if (anchorNode.parentNode) {\n        anchorNode.parentNode!.replaceChild(element, anchorNode);\n      }\n    });\n  };\n\n  /** Gets the root node of the portal outlet. */\n  private _getRootNode(): HTMLElement {\n    const nativeElement: Node = this._viewContainerRef.element.nativeElement;\n\n    // The directive could be set on a template which will result in a comment\n    // node being the root. Use the comment's parent node if that is the case.\n    return (\n      nativeElement.nodeType === nativeElement.ELEMENT_NODE\n        ? nativeElement\n        : nativeElement.parentNode!\n    ) as HTMLElement;\n  }\n}\n\n/**\n * @deprecated Use `CdkPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\n@Directive({\n  selector: '[cdkPortalHost], [portalHost]',\n  exportAs: 'cdkPortalHost',\n  inputs: ['portal: cdkPortalHost'],\n  providers: [\n    {\n      provide: CdkPortalOutlet,\n      useExisting: PortalHostDirective,\n    },\n  ],\n})\nexport class PortalHostDirective extends CdkPortalOutlet {}\n\n@NgModule({\n  exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n  declarations: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n})\nexport class PortalModule {}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n * @deprecated Use `Injector.create` instead.\n * @breaking-change 11.0.0\n */\nexport class PortalInjector implements Injector {\n  constructor(private _parentInjector: Injector, private _customTokens: WeakMap<any, any>) {}\n\n  get(token: any, notFoundValue?: any): any {\n    const value = this._customTokens.get(token);\n\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n\n    return this._parentInjector.get<any>(token, notFoundValue);\n  }\n}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ScrollStrategy} from './scroll-strategy';\nimport {ViewportRuler} from '@angular/cdk/scrolling';\nimport {coerceCssPixelValue} from '@angular/cdk/coercion';\nimport {supportsScrollBehavior} from '@angular/cdk/platform';\n\nconst scrollBehaviorSupported = supportsScrollBehavior();\n\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nexport class BlockScrollStrategy implements ScrollStrategy {\n  private _previousHTMLStyles = {top: '', left: ''};\n  private _previousScrollPosition: {top: number; left: number};\n  private _isEnabled = false;\n  private _document: Document;\n\n  constructor(private _viewportRuler: ViewportRuler, document: any) {\n    this._document = document;\n  }\n\n  /** Attaches this scroll strategy to an overlay. */\n  attach() {}\n\n  /** Blocks page-level scroll while the attached overlay is open. */\n  enable() {\n    if (this._canBeEnabled()) {\n      const root = this._document.documentElement!;\n\n      this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n\n      // Cache the previous inline styles in case the user had set them.\n      this._previousHTMLStyles.left = root.style.left || '';\n      this._previousHTMLStyles.top = root.style.top || '';\n\n      // Note: we're using the `html` node, instead of the `body`, because the `body` may\n      // have the user agent margin, whereas the `html` is guaranteed not to have one.\n      root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);\n      root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);\n      root.classList.add('cdk-global-scrollblock');\n      this._isEnabled = true;\n    }\n  }\n\n  /** Unblocks page-level scroll while the attached overlay is open. */\n  disable() {\n    if (this._isEnabled) {\n      const html = this._document.documentElement!;\n      const body = this._document.body!;\n      const htmlStyle = html.style;\n      const bodyStyle = body.style;\n      const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';\n      const previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';\n\n      this._isEnabled = false;\n\n      htmlStyle.left = this._previousHTMLStyles.left;\n      htmlStyle.top = this._previousHTMLStyles.top;\n      html.classList.remove('cdk-global-scrollblock');\n\n      // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n      // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n      // Note that we don't mutate the property if the browser doesn't support `scroll-behavior`,\n      // because it can throw off feature detections in `supportsScrollBehavior` which\n      // checks for `'scrollBehavior' in documentElement.style`.\n      if (scrollBehaviorSupported) {\n        htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';\n      }\n\n      window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n\n      if (scrollBehaviorSupported) {\n        htmlStyle.scrollBehavior = previousHtmlScrollBehavior;\n        bodyStyle.scrollBehavior = previousBodyScrollBehavior;\n      }\n    }\n  }\n\n  private _canBeEnabled(): boolean {\n    // Since the scroll strategies can't be singletons, we have to use a global CSS class\n    // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n    // scrolling multiple times.\n    const html = this._document.documentElement!;\n\n    if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n      return false;\n    }\n\n    const body = this._document.body;\n    const viewport = this._viewportRuler.getViewportSize();\n    return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport type {OverlayRef} from '../overlay-ref';\n\n/**\n * Describes a strategy that will be used by an overlay to handle scroll events while it is open.\n */\nexport interface ScrollStrategy {\n  /** Enable this scroll strategy (called when the attached overlay is attached to a portal). */\n  enable: () => void;\n\n  /** Disable this scroll strategy (called when the attached overlay is detached from a portal). */\n  disable: () => void;\n\n  /** Attaches this `ScrollStrategy` to an overlay. */\n  attach: (overlayRef: OverlayRef) => void;\n\n  /** Detaches the scroll strategy from the current overlay. */\n  detach?: () => void;\n}\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n */\nexport function getMatScrollStrategyAlreadyAttachedError(): Error {\n  return Error(`Scroll strategy has already been attached.`);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {NgZone} from '@angular/core';\nimport {ScrollStrategy, getMatScrollStrategyAlreadyAttachedError} from './scroll-strategy';\nimport {Subscription} from 'rxjs';\nimport {ScrollDispatcher, ViewportRuler} from '@angular/cdk/scrolling';\nimport {filter} from 'rxjs/operators';\nimport type {OverlayRef} from '../overlay-ref';\n\n/**\n * Config options for the CloseScrollStrategy.\n */\nexport interface CloseScrollStrategyConfig {\n  /** Amount of pixels the user has to scroll before the overlay is closed. */\n  threshold?: number;\n}\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nexport class CloseScrollStrategy implements ScrollStrategy {\n  private _scrollSubscription: Subscription | null = null;\n  private _overlayRef: OverlayRef;\n  private _initialScrollPosition: number;\n\n  constructor(\n    private _scrollDispatcher: ScrollDispatcher,\n    private _ngZone: NgZone,\n    private _viewportRuler: ViewportRuler,\n    private _config?: CloseScrollStrategyConfig,\n  ) {}\n\n  /** Attaches this scroll strategy to an overlay. */\n  attach(overlayRef: OverlayRef) {\n    if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatScrollStrategyAlreadyAttachedError();\n    }\n\n    this._overlayRef = overlayRef;\n  }\n\n  /** Enables the closing of the attached overlay on scroll. */\n  enable() {\n    if (this._scrollSubscription) {\n      return;\n    }\n\n    const stream = this._scrollDispatcher.scrolled(0).pipe(\n      filter(scrollable => {\n        return (\n          !scrollable ||\n          !this._overlayRef.overlayElement.contains(scrollable.getElementRef().nativeElement)\n        );\n      }),\n    );\n\n    if (this._config && this._config.threshold && this._config.threshold > 1) {\n      this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n\n      this._scrollSubscription = stream.subscribe(() => {\n        const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n\n        if (Math.abs(scrollPosition - this._initialScrollPosition) > this._config!.threshold!) {\n          this._detach();\n        } else {\n          this._overlayRef.updatePosition();\n        }\n      });\n    } else {\n      this._scrollSubscription = stream.subscribe(this._detach);\n    }\n  }\n\n  /** Disables the closing the attached overlay on scroll. */\n  disable() {\n    if (this._scrollSubscription) {\n      this._scrollSubscription.unsubscribe();\n      this._scrollSubscription = null;\n    }\n  }\n\n  detach() {\n    this.disable();\n    this._overlayRef = null!;\n  }\n\n  /** Detaches the overlay ref and disables the scroll strategy. */\n  private _detach = () => {\n    this.disable();\n\n    if (this._overlayRef.hasAttached()) {\n      this._ngZone.run(() => this._overlayRef.detach());\n    }\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ScrollStrategy} from './scroll-strategy';\n\n/** Scroll strategy that doesn't do anything. */\nexport class NoopScrollStrategy implements ScrollStrategy {\n  /** Does nothing, as this scroll strategy is a no-op. */\n  enable() {}\n  /** Does nothing, as this scroll strategy is a no-op. */\n  disable() {}\n  /** Does nothing, as this scroll strategy is a no-op. */\n  attach() {}\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// TODO(jelbourn): move this to live with the rest of the scrolling code\n// TODO(jelbourn): someday replace this with IntersectionObservers\n\n/** Equivalent of `ClientRect` without some of the properties we don't care about. */\ntype Dimensions = Omit<ClientRect, 'x' | 'y' | 'toJSON'>;\n\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is scrolled out of view\n * @docs-private\n */\nexport function isElementScrolledOutsideView(element: Dimensions, scrollContainers: Dimensions[]) {\n  return scrollContainers.some(containerBounds => {\n    const outsideAbove = element.bottom < containerBounds.top;\n    const outsideBelow = element.top > containerBounds.bottom;\n    const outsideLeft = element.right < containerBounds.left;\n    const outsideRight = element.left > containerBounds.right;\n\n    return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n  });\n}\n\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is clipped\n * @docs-private\n */\nexport function isElementClippedByScrolling(element: Dimensions, scrollContainers: Dimensions[]) {\n  return scrollContainers.some(scrollContainerRect => {\n    const clippedAbove = element.top < scrollContainerRect.top;\n    const clippedBelow = element.bottom > scrollContainerRect.bottom;\n    const clippedLeft = element.left < scrollContainerRect.left;\n    const clippedRight = element.right > scrollContainerRect.right;\n\n    return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n  });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgZone} from '@angular/core';\nimport {Subscription} from 'rxjs';\nimport {ScrollStrategy, getMatScrollStrategyAlreadyAttachedError} from './scroll-strategy';\nimport {ScrollDispatcher, ViewportRuler} from '@angular/cdk/scrolling';\nimport {isElementScrolledOutsideView} from '../position/scroll-clip';\nimport type {OverlayRef} from '../overlay-ref';\n\n/**\n * Config options for the RepositionScrollStrategy.\n */\nexport interface RepositionScrollStrategyConfig {\n  /** Time in milliseconds to throttle the scroll events. */\n  scrollThrottle?: number;\n\n  /** Whether to close the overlay once the user has scrolled away completely. */\n  autoClose?: boolean;\n}\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nexport class RepositionScrollStrategy implements ScrollStrategy {\n  private _scrollSubscription: Subscription | null = null;\n  private _overlayRef: OverlayRef;\n\n  constructor(\n    private _scrollDispatcher: ScrollDispatcher,\n    private _viewportRuler: ViewportRuler,\n    private _ngZone: NgZone,\n    private _config?: RepositionScrollStrategyConfig,\n  ) {}\n\n  /** Attaches this scroll strategy to an overlay. */\n  attach(overlayRef: OverlayRef) {\n    if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatScrollStrategyAlreadyAttachedError();\n    }\n\n    this._overlayRef = overlayRef;\n  }\n\n  /** Enables repositioning of the attached overlay on scroll. */\n  enable() {\n    if (!this._scrollSubscription) {\n      const throttle = this._config ? this._config.scrollThrottle : 0;\n\n      this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(() => {\n        this._overlayRef.updatePosition();\n\n        // TODO(crisbeto): make `close` on by default once all components can handle it.\n        if (this._config && this._config.autoClose) {\n          const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();\n          const {width, height} = this._viewportRuler.getViewportSize();\n\n          // TODO(crisbeto): include all ancestor scroll containers here once\n          // we have a way of exposing the trigger element to the scroll strategy.\n          const parentRects = [{width, height, bottom: height, right: width, top: 0, left: 0}];\n\n          if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n            this.disable();\n            this._ngZone.run(() => this._overlayRef.detach());\n          }\n        }\n      });\n    }\n  }\n\n  /** Disables repositioning of the attached overlay on scroll. */\n  disable() {\n    if (this._scrollSubscription) {\n      this._scrollSubscription.unsubscribe();\n      this._scrollSubscription = null;\n    }\n  }\n\n  detach() {\n    this.disable();\n    this._overlayRef = null!;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ScrollDispatcher, ViewportRuler} from '@angular/cdk/scrolling';\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable, NgZone} from '@angular/core';\nimport {BlockScrollStrategy} from './block-scroll-strategy';\nimport {CloseScrollStrategy, CloseScrollStrategyConfig} from './close-scroll-strategy';\nimport {NoopScrollStrategy} from './noop-scroll-strategy';\nimport {\n  RepositionScrollStrategy,\n  RepositionScrollStrategyConfig,\n} from './reposition-scroll-strategy';\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\n@Injectable({providedIn: 'root'})\nexport class ScrollStrategyOptions {\n  private _document: Document;\n\n  constructor(\n    private _scrollDispatcher: ScrollDispatcher,\n    private _viewportRuler: ViewportRuler,\n    private _ngZone: NgZone,\n    @Inject(DOCUMENT) document: any,\n  ) {\n    this._document = document;\n  }\n\n  /** Do nothing on scroll. */\n  noop = () => new NoopScrollStrategy();\n\n  /**\n   * Close the overlay as soon as the user scrolls.\n   * @param config Configuration to be used inside the scroll strategy.\n   */\n  close = (config?: CloseScrollStrategyConfig) =>\n    new CloseScrollStrategy(this._scrollDispatcher, this._ngZone, this._viewportRuler, config);\n\n  /** Block scrolling. */\n  block = () => new BlockScrollStrategy(this._viewportRuler, this._document);\n\n  /**\n   * Update the overlay's position on scroll.\n   * @param config Configuration to be used inside the scroll strategy.\n   * Allows debouncing the reposition calls.\n   */\n  reposition = (config?: RepositionScrollStrategyConfig) =>\n    new RepositionScrollStrategy(this._scrollDispatcher, this._viewportRuler, this._ngZone, config);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {PositionStrategy} from './position/position-strategy';\nimport {Direction, Directionality} from '@angular/cdk/bidi';\nimport {ScrollStrategy, NoopScrollStrategy} from './scroll/index';\n\n/** Initial configuration used when creating an overlay. */\nexport class OverlayConfig {\n  /** Strategy with which to position the overlay. */\n  positionStrategy?: PositionStrategy;\n\n  /** Strategy to be used when handling scroll events while the overlay is open. */\n  scrollStrategy?: ScrollStrategy = new NoopScrollStrategy();\n\n  /** Custom class to add to the overlay pane. */\n  panelClass?: string | string[] = '';\n\n  /** Whether the overlay has a backdrop. */\n  hasBackdrop?: boolean = false;\n\n  /** Custom class to add to the backdrop */\n  backdropClass?: string | string[] = 'cdk-overlay-dark-backdrop';\n\n  /** The width of the overlay panel. If a number is provided, pixel units are assumed. */\n  width?: number | string;\n\n  /** The height of the overlay panel. If a number is provided, pixel units are assumed. */\n  height?: number | string;\n\n  /** The min-width of the overlay panel. If a number is provided, pixel units are assumed. */\n  minWidth?: number | string;\n\n  /** The min-height of the overlay panel. If a number is provided, pixel units are assumed. */\n  minHeight?: number | string;\n\n  /** The max-width of the overlay panel. If a number is provided, pixel units are assumed. */\n  maxWidth?: number | string;\n\n  /** The max-height of the overlay panel. If a number is provided, pixel units are assumed. */\n  maxHeight?: number | string;\n\n  /**\n   * Direction of the text in the overlay panel. If a `Directionality` instance\n   * is passed in, the overlay will handle changes to its value automatically.\n   */\n  direction?: Direction | Directionality;\n\n  /**\n   * Whether the overlay should be disposed of when the user goes backwards/forwards in history.\n   * Note that this usually doesn't include clicking on links (unless the user is using\n   * the `HashLocationStrategy`).\n   */\n  disposeOnNavigation?: boolean = false;\n\n  constructor(config?: OverlayConfig) {\n    if (config) {\n      // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,\n      // loses the array generic type in the `for of`. But we *also* have to use `Array` because\n      // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`\n      const configKeys = Object.keys(config) as Iterable<keyof OverlayConfig> &\n        (keyof OverlayConfig)[];\n      for (const key of configKeys) {\n        if (config[key] !== undefined) {\n          // TypeScript, as of version 3.5, sees the left-hand-side of this expression\n          // as \"I don't know *which* key this is, so the only valid value is the intersection\n          // of all the possible values.\" In this case, that happens to be `undefined`. TypeScript\n          // is not smart enough to see that the right-hand-side is actually an access of the same\n          // exact type with the same exact key, meaning that the value type must be identical.\n          // So we use `any` to work around this.\n          this[key] = config[key] as any;\n        }\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\nexport type HorizontalConnectionPos = 'start' | 'center' | 'end';\n\n/** Vertical dimension of a connection point on the perimeter of the origin or overlay element. */\nexport type VerticalConnectionPos = 'top' | 'center' | 'bottom';\n\n/** A connection point on the origin element. */\nexport interface OriginConnectionPosition {\n  originX: HorizontalConnectionPos;\n  originY: VerticalConnectionPos;\n}\n\n/** A connection point on the overlay element. */\nexport interface OverlayConnectionPosition {\n  overlayX: HorizontalConnectionPos;\n  overlayY: VerticalConnectionPos;\n}\n\n/** The points of the origin element and the overlay element to connect. */\nexport class ConnectionPositionPair {\n  /** X-axis attachment point for connected overlay origin. Can be 'start', 'end', or 'center'. */\n  originX: HorizontalConnectionPos;\n  /** Y-axis attachment point for connected overlay origin. Can be 'top', 'bottom', or 'center'. */\n  originY: VerticalConnectionPos;\n  /** X-axis attachment point for connected overlay. Can be 'start', 'end', or 'center'. */\n  overlayX: HorizontalConnectionPos;\n  /** Y-axis attachment point for connected overlay. Can be 'top', 'bottom', or 'center'. */\n  overlayY: VerticalConnectionPos;\n\n  constructor(\n    origin: OriginConnectionPosition,\n    overlay: OverlayConnectionPosition,\n    /** Offset along the X axis. */\n    public offsetX?: number,\n    /** Offset along the Y axis. */\n    public offsetY?: number,\n    /** Class(es) to be applied to the panel while this position is active. */\n    public panelClass?: string | string[],\n  ) {\n    this.originX = origin.originX;\n    this.originY = origin.originY;\n    this.overlayX = overlay.overlayX;\n    this.overlayY = overlay.overlayY;\n  }\n}\n\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  @docs-private\n */\nexport class ScrollingVisibility {\n  isOriginClipped: boolean;\n  isOriginOutsideView: boolean;\n  isOverlayClipped: boolean;\n  isOverlayOutsideView: boolean;\n}\n\n/** The change event emitted by the strategy when a fallback position is used. */\nexport class ConnectedOverlayPositionChange {\n  constructor(\n    /** The position used as a result of this change. */\n    public connectionPair: ConnectionPositionPair,\n    /** @docs-private */\n    public scrollableViewProperties: ScrollingVisibility,\n  ) {}\n}\n\n/**\n * Validates whether a vertical position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nexport function validateVerticalPosition(property: string, value: VerticalConnectionPos) {\n  if (value !== 'top' && value !== 'bottom' && value !== 'center') {\n    throw Error(\n      `ConnectedPosition: Invalid ${property} \"${value}\". ` +\n        `Expected \"top\", \"bottom\" or \"center\".`,\n    );\n  }\n}\n\n/**\n * Validates whether a horizontal position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nexport function validateHorizontalPosition(property: string, value: HorizontalConnectionPos) {\n  if (value !== 'start' && value !== 'end' && value !== 'center') {\n    throw Error(\n      `ConnectedPosition: Invalid ${property} \"${value}\". ` +\n        `Expected \"start\", \"end\" or \"center\".`,\n    );\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable, OnDestroy} from '@angular/core';\nimport type {OverlayRef} from '../overlay-ref';\n\n/**\n * Service for dispatching events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\n@Injectable({providedIn: 'root'})\nexport abstract class BaseOverlayDispatcher implements OnDestroy {\n  /** Currently attached overlays in the order they were attached. */\n  _attachedOverlays: OverlayRef[] = [];\n\n  protected _document: Document;\n  protected _isAttached: boolean;\n\n  constructor(@Inject(DOCUMENT) document: any) {\n    this._document = document;\n  }\n\n  ngOnDestroy(): void {\n    this.detach();\n  }\n\n  /** Add a new overlay to the list of attached overlay refs. */\n  add(overlayRef: OverlayRef): void {\n    // Ensure that we don't get the same overlay multiple times.\n    this.remove(overlayRef);\n    this._attachedOverlays.push(overlayRef);\n  }\n\n  /** Remove an overlay from the list of attached overlay refs. */\n  remove(overlayRef: OverlayRef): void {\n    const index = this._attachedOverlays.indexOf(overlayRef);\n\n    if (index > -1) {\n      this._attachedOverlays.splice(index, 1);\n    }\n\n    // Remove the global listener once there are no more overlays.\n    if (this._attachedOverlays.length === 0) {\n      this.detach();\n    }\n  }\n\n  /** Detaches the global event listener. */\n  protected abstract detach(): void;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable, NgZone, Optional} from '@angular/core';\nimport {BaseOverlayDispatcher} from './base-overlay-dispatcher';\nimport type {OverlayRef} from '../overlay-ref';\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\n@Injectable({providedIn: 'root'})\nexport class OverlayKeyboardDispatcher extends BaseOverlayDispatcher {\n  constructor(\n    @Inject(DOCUMENT) document: any,\n    /** @breaking-change 14.0.0 _ngZone will be required. */\n    @Optional() private _ngZone?: NgZone,\n  ) {\n    super(document);\n  }\n\n  /** Add a new overlay to the list of attached overlay refs. */\n  override add(overlayRef: OverlayRef): void {\n    super.add(overlayRef);\n\n    // Lazily start dispatcher once first overlay is added\n    if (!this._isAttached) {\n      /** @breaking-change 14.0.0 _ngZone will be required. */\n      if (this._ngZone) {\n        this._ngZone.runOutsideAngular(() =>\n          this._document.body.addEventListener('keydown', this._keydownListener),\n        );\n      } else {\n        this._document.body.addEventListener('keydown', this._keydownListener);\n      }\n      this._isAttached = true;\n    }\n  }\n\n  /** Detaches the global keyboard event listener. */\n  protected detach() {\n    if (this._isAttached) {\n      this._document.body.removeEventListener('keydown', this._keydownListener);\n      this._isAttached = false;\n    }\n  }\n\n  /** Keyboard event listener that will be attached to the body. */\n  private _keydownListener = (event: KeyboardEvent) => {\n    const overlays = this._attachedOverlays;\n\n    for (let i = overlays.length - 1; i > -1; i--) {\n      // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.\n      // We want to target the most recent overlay, rather than trying to match where the event came\n      // from, because some components might open an overlay, but keep focus on a trigger element\n      // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,\n      // because we don't want overlays that don't handle keyboard events to block the ones below\n      // them that do.\n      if (overlays[i]._keydownEvents.observers.length > 0) {\n        const keydownEvents = overlays[i]._keydownEvents;\n        /** @breaking-change 14.0.0 _ngZone will be required. */\n        if (this._ngZone) {\n          this._ngZone.run(() => keydownEvents.next(event));\n        } else {\n          keydownEvents.next(event);\n        }\n        break;\n      }\n    }\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable, NgZone, Optional} from '@angular/core';\nimport {Platform, _getEventTarget} from '@angular/cdk/platform';\nimport {BaseOverlayDispatcher} from './base-overlay-dispatcher';\nimport type {OverlayRef} from '../overlay-ref';\n\n/**\n * Service for dispatching mouse click events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\n@Injectable({providedIn: 'root'})\nexport class OverlayOutsideClickDispatcher extends BaseOverlayDispatcher {\n  private _cursorOriginalValue: string;\n  private _cursorStyleIsSet = false;\n  private _pointerDownEventTarget: EventTarget | null;\n\n  constructor(\n    @Inject(DOCUMENT) document: any,\n    private _platform: Platform,\n    /** @breaking-change 14.0.0 _ngZone will be required. */\n    @Optional() private _ngZone?: NgZone,\n  ) {\n    super(document);\n  }\n\n  /** Add a new overlay to the list of attached overlay refs. */\n  override add(overlayRef: OverlayRef): void {\n    super.add(overlayRef);\n\n    // Safari on iOS does not generate click events for non-interactive\n    // elements. However, we want to receive a click for any element outside\n    // the overlay. We can force a \"clickable\" state by setting\n    // `cursor: pointer` on the document body. See:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event#Safari_Mobile\n    // https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html\n    if (!this._isAttached) {\n      const body = this._document.body;\n\n      /** @breaking-change 14.0.0 _ngZone will be required. */\n      if (this._ngZone) {\n        this._ngZone.runOutsideAngular(() => this._addEventListeners(body));\n      } else {\n        this._addEventListeners(body);\n      }\n\n      // click event is not fired on iOS. To make element \"clickable\" we are\n      // setting the cursor to pointer\n      if (this._platform.IOS && !this._cursorStyleIsSet) {\n        this._cursorOriginalValue = body.style.cursor;\n        body.style.cursor = 'pointer';\n        this._cursorStyleIsSet = true;\n      }\n\n      this._isAttached = true;\n    }\n  }\n\n  /** Detaches the global keyboard event listener. */\n  protected detach() {\n    if (this._isAttached) {\n      const body = this._document.body;\n      body.removeEventListener('pointerdown', this._pointerDownListener, true);\n      body.removeEventListener('click', this._clickListener, true);\n      body.removeEventListener('auxclick', this._clickListener, true);\n      body.removeEventListener('contextmenu', this._clickListener, true);\n      if (this._platform.IOS && this._cursorStyleIsSet) {\n        body.style.cursor = this._cursorOriginalValue;\n        this._cursorStyleIsSet = false;\n      }\n      this._isAttached = false;\n    }\n  }\n\n  private _addEventListeners(body: HTMLElement): void {\n    body.addEventListener('pointerdown', this._pointerDownListener, true);\n    body.addEventListener('click', this._clickListener, true);\n    body.addEventListener('auxclick', this._clickListener, true);\n    body.addEventListener('contextmenu', this._clickListener, true);\n  }\n\n  /** Store pointerdown event target to track origin of click. */\n  private _pointerDownListener = (event: PointerEvent) => {\n    this._pointerDownEventTarget = _getEventTarget(event);\n  };\n\n  /** Click event listener that will be attached to the body propagate phase. */\n  private _clickListener = (event: MouseEvent) => {\n    const target = _getEventTarget(event);\n    // In case of a click event, we want to check the origin of the click\n    // (e.g. in case where a user starts a click inside the overlay and\n    // releases the click outside of it).\n    // This is done by using the event target of the preceding pointerdown event.\n    // Every click event caused by a pointer device has a preceding pointerdown\n    // event, unless the click was programmatically triggered (e.g. in a unit test).\n    const origin =\n      event.type === 'click' && this._pointerDownEventTarget\n        ? this._pointerDownEventTarget\n        : target;\n    // Reset the stored pointerdown event target, to avoid having it interfere\n    // in subsequent events.\n    this._pointerDownEventTarget = null;\n\n    // We copy the array because the original may be modified asynchronously if the\n    // outsidePointerEvents listener decides to detach overlays resulting in index errors inside\n    // the for loop.\n    const overlays = this._attachedOverlays.slice();\n\n    // Dispatch the mouse event to the top overlay which has subscribers to its mouse events.\n    // We want to target all overlays for which the click could be considered as outside click.\n    // As soon as we reach an overlay for which the click is not outside click we break off\n    // the loop.\n    for (let i = overlays.length - 1; i > -1; i--) {\n      const overlayRef = overlays[i];\n      if (overlayRef._outsidePointerEvents.observers.length < 1 || !overlayRef.hasAttached()) {\n        continue;\n      }\n\n      // If it's a click inside the overlay, just break - we should do nothing\n      // If it's an outside click (both origin and target of the click) dispatch the mouse event,\n      // and proceed with the next overlay\n      if (\n        overlayRef.overlayElement.contains(target as Node) ||\n        overlayRef.overlayElement.contains(origin as Node)\n      ) {\n        break;\n      }\n\n      const outsidePointerEvents = overlayRef._outsidePointerEvents;\n      /** @breaking-change 14.0.0 _ngZone will be required. */\n      if (this._ngZone) {\n        this._ngZone.run(() => outsidePointerEvents.next(event));\n      } else {\n        outsidePointerEvents.next(event);\n      }\n    }\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable, OnDestroy} from '@angular/core';\nimport {Platform, _isTestEnvironment} from '@angular/cdk/platform';\n\n/** Container inside which all overlays will render. */\n@Injectable({providedIn: 'root'})\nexport class OverlayContainer implements OnDestroy {\n  protected _containerElement: HTMLElement;\n  protected _document: Document;\n\n  constructor(@Inject(DOCUMENT) document: any, protected _platform: Platform) {\n    this._document = document;\n  }\n\n  ngOnDestroy() {\n    this._containerElement?.remove();\n  }\n\n  /**\n   * This method returns the overlay container element. It will lazily\n   * create the element the first time it is called to facilitate using\n   * the container in non-browser environments.\n   * @returns the container element\n   */\n  getContainerElement(): HTMLElement {\n    if (!this._containerElement) {\n      this._createContainer();\n    }\n\n    return this._containerElement;\n  }\n\n  /**\n   * Create the overlay container element, which is simply a div\n   * with the 'cdk-overlay-container' class on the document body.\n   */\n  protected _createContainer(): void {\n    const containerClass = 'cdk-overlay-container';\n\n    // TODO(crisbeto): remove the testing check once we have an overlay testing\n    // module or Angular starts tearing down the testing `NgModule`. See:\n    // https://github.com/angular/angular/issues/18831\n    if (this._platform.isBrowser || _isTestEnvironment()) {\n      const oppositePlatformContainers = this._document.querySelectorAll(\n        `.${containerClass}[platform=\"server\"], ` + `.${containerClass}[platform=\"test\"]`,\n      );\n\n      // Remove any old containers from the opposite platform.\n      // This can happen when transitioning from the server to the client.\n      for (let i = 0; i < oppositePlatformContainers.length; i++) {\n        oppositePlatformContainers[i].remove();\n      }\n    }\n\n    const container = this._document.createElement('div');\n    container.classList.add(containerClass);\n\n    // A long time ago we kept adding new overlay containers whenever a new app was instantiated,\n    // but at some point we added logic which clears the duplicate ones in order to avoid leaks.\n    // The new logic was a little too aggressive since it was breaking some legitimate use cases.\n    // To mitigate the problem we made it so that only containers from a different platform are\n    // cleared, but the side-effect was that people started depending on the overly-aggressive\n    // logic to clean up their tests for them. Until we can introduce an overlay-specific testing\n    // module which does the cleanup, we try to detect that we're in a test environment and we\n    // always clear the container. See #17006.\n    // TODO(crisbeto): remove the test environment check once we have an overlay testing module.\n    if (_isTestEnvironment()) {\n      container.setAttribute('platform', 'test');\n    } else if (!this._platform.isBrowser) {\n      container.setAttribute('platform', 'server');\n    }\n\n    this._document.body.appendChild(container);\n    this._containerElement = container;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Direction, Directionality} from '@angular/cdk/bidi';\nimport {ComponentPortal, Portal, PortalOutlet, TemplatePortal} from '@angular/cdk/portal';\nimport {ComponentRef, EmbeddedViewRef, NgZone} from '@angular/core';\nimport {Location} from '@angular/common';\nimport {Observable, Subject, merge, SubscriptionLike, Subscription} from 'rxjs';\nimport {take, takeUntil} from 'rxjs/operators';\nimport {OverlayKeyboardDispatcher} from './dispatchers/overlay-keyboard-dispatcher';\nimport {OverlayOutsideClickDispatcher} from './dispatchers/overlay-outside-click-dispatcher';\nimport {OverlayConfig} from './overlay-config';\nimport {coerceCssPixelValue, coerceArray} from '@angular/cdk/coercion';\nimport {PositionStrategy} from './position/position-strategy';\nimport {ScrollStrategy} from './scroll';\n\n/** An object where all of its properties cannot be written. */\nexport type ImmutableObject<T> = {\n  readonly [P in keyof T]: T[P];\n};\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nexport class OverlayRef implements PortalOutlet {\n  private _backdropElement: HTMLElement | null = null;\n  private _backdropTimeout: number | undefined;\n  private readonly _backdropClick = new Subject<MouseEvent>();\n  private readonly _attachments = new Subject<void>();\n  private readonly _detachments = new Subject<void>();\n  private _positionStrategy: PositionStrategy | undefined;\n  private _scrollStrategy: ScrollStrategy | undefined;\n  private _locationChanges: SubscriptionLike = Subscription.EMPTY;\n  private _backdropClickHandler = (event: MouseEvent) => this._backdropClick.next(event);\n  private _backdropTransitionendHandler = (event: TransitionEvent) => {\n    this._disposeBackdrop(event.target as HTMLElement | null);\n  };\n\n  /**\n   * Reference to the parent of the `_host` at the time it was detached. Used to restore\n   * the `_host` to its original position in the DOM when it gets re-attached.\n   */\n  private _previousHostParent: HTMLElement;\n\n  /** Stream of keydown events dispatched to this overlay. */\n  readonly _keydownEvents = new Subject<KeyboardEvent>();\n\n  /** Stream of mouse outside events dispatched to this overlay. */\n  readonly _outsidePointerEvents = new Subject<MouseEvent>();\n\n  constructor(\n    private _portalOutlet: PortalOutlet,\n    private _host: HTMLElement,\n    private _pane: HTMLElement,\n    private _config: ImmutableObject<OverlayConfig>,\n    private _ngZone: NgZone,\n    private _keyboardDispatcher: OverlayKeyboardDispatcher,\n    private _document: Document,\n    private _location: Location,\n    private _outsideClickDispatcher: OverlayOutsideClickDispatcher,\n    private _animationsDisabled = false,\n  ) {\n    if (_config.scrollStrategy) {\n      this._scrollStrategy = _config.scrollStrategy;\n      this._scrollStrategy.attach(this);\n    }\n\n    this._positionStrategy = _config.positionStrategy;\n  }\n\n  /** The overlay's HTML element */\n  get overlayElement(): HTMLElement {\n    return this._pane;\n  }\n\n  /** The overlay's backdrop HTML element. */\n  get backdropElement(): HTMLElement | null {\n    return this._backdropElement;\n  }\n\n  /**\n   * Wrapper around the panel element. Can be used for advanced\n   * positioning where a wrapper with specific styling is\n   * required around the overlay pane.\n   */\n  get hostElement(): HTMLElement {\n    return this._host;\n  }\n\n  attach<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n  attach<T>(portal: TemplatePortal<T>): EmbeddedViewRef<T>;\n  attach(portal: any): any;\n\n  /**\n   * Attaches content, given via a Portal, to the overlay.\n   * If the overlay is configured to have a backdrop, it will be created.\n   *\n   * @param portal Portal instance to which to attach the overlay.\n   * @returns The portal attachment result.\n   */\n  attach(portal: Portal<any>): any {\n    // Insert the host into the DOM before attaching the portal, otherwise\n    // the animations module will skip animations on repeat attachments.\n    if (!this._host.parentElement && this._previousHostParent) {\n      this._previousHostParent.appendChild(this._host);\n    }\n\n    const attachResult = this._portalOutlet.attach(portal);\n\n    if (this._positionStrategy) {\n      this._positionStrategy.attach(this);\n    }\n\n    this._updateStackingOrder();\n    this._updateElementSize();\n    this._updateElementDirection();\n\n    if (this._scrollStrategy) {\n      this._scrollStrategy.enable();\n    }\n\n    // Update the position once the zone is stable so that the overlay will be fully rendered\n    // before attempting to position it, as the position may depend on the size of the rendered\n    // content.\n    this._ngZone.onStable.pipe(take(1)).subscribe(() => {\n      // The overlay could've been detached before the zone has stabilized.\n      if (this.hasAttached()) {\n        this.updatePosition();\n      }\n    });\n\n    // Enable pointer events for the overlay pane element.\n    this._togglePointerEvents(true);\n\n    if (this._config.hasBackdrop) {\n      this._attachBackdrop();\n    }\n\n    if (this._config.panelClass) {\n      this._toggleClasses(this._pane, this._config.panelClass, true);\n    }\n\n    // Only emit the `attachments` event once all other setup is done.\n    this._attachments.next();\n\n    // Track this overlay by the keyboard dispatcher\n    this._keyboardDispatcher.add(this);\n\n    if (this._config.disposeOnNavigation) {\n      this._locationChanges = this._location.subscribe(() => this.dispose());\n    }\n\n    this._outsideClickDispatcher.add(this);\n\n    // TODO(crisbeto): the null check is here, because the portal outlet returns `any`.\n    // We should be guaranteed for the result to be `ComponentRef | EmbeddedViewRef`, but\n    // `instanceof EmbeddedViewRef` doesn't appear to work at the moment.\n    if (typeof attachResult?.onDestroy === 'function') {\n      // In most cases we control the portal and we know when it is being detached so that\n      // we can finish the disposal process. The exception is if the user passes in a custom\n      // `ViewContainerRef` that isn't destroyed through the overlay API. Note that we use\n      // `detach` here instead of `dispose`, because we don't know if the user intends to\n      // reattach the overlay at a later point. It also has the advantage of waiting for animations.\n      attachResult.onDestroy(() => {\n        if (this.hasAttached()) {\n          // We have to delay the `detach` call, because detaching immediately prevents\n          // other destroy hooks from running. This is likely a framework bug similar to\n          // https://github.com/angular/angular/issues/46119\n          this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach()));\n        }\n      });\n    }\n\n    return attachResult;\n  }\n\n  /**\n   * Detaches an overlay from a portal.\n   * @returns The portal detachment result.\n   */\n  detach(): any {\n    if (!this.hasAttached()) {\n      return;\n    }\n\n    this.detachBackdrop();\n\n    // When the overlay is detached, the pane element should disable pointer events.\n    // This is necessary because otherwise the pane element will cover the page and disable\n    // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n    this._togglePointerEvents(false);\n\n    if (this._positionStrategy && this._positionStrategy.detach) {\n      this._positionStrategy.detach();\n    }\n\n    if (this._scrollStrategy) {\n      this._scrollStrategy.disable();\n    }\n\n    const detachmentResult = this._portalOutlet.detach();\n\n    // Only emit after everything is detached.\n    this._detachments.next();\n\n    // Remove this overlay from keyboard dispatcher tracking.\n    this._keyboardDispatcher.remove(this);\n\n    // Keeping the host element in the DOM can cause scroll jank, because it still gets\n    // rendered, even though it's transparent and unclickable which is why we remove it.\n    this._detachContentWhenStable();\n    this._locationChanges.unsubscribe();\n    this._outsideClickDispatcher.remove(this);\n    return detachmentResult;\n  }\n\n  /** Cleans up the overlay from the DOM. */\n  dispose(): void {\n    const isAttached = this.hasAttached();\n\n    if (this._positionStrategy) {\n      this._positionStrategy.dispose();\n    }\n\n    this._disposeScrollStrategy();\n    this._disposeBackdrop(this._backdropElement);\n    this._locationChanges.unsubscribe();\n    this._keyboardDispatcher.remove(this);\n    this._portalOutlet.dispose();\n    this._attachments.complete();\n    this._backdropClick.complete();\n    this._keydownEvents.complete();\n    this._outsidePointerEvents.complete();\n    this._outsideClickDispatcher.remove(this);\n    this._host?.remove();\n\n    this._previousHostParent = this._pane = this._host = null!;\n\n    if (isAttached) {\n      this._detachments.next();\n    }\n\n    this._detachments.complete();\n  }\n\n  /** Whether the overlay has attached content. */\n  hasAttached(): boolean {\n    return this._portalOutlet.hasAttached();\n  }\n\n  /** Gets an observable that emits when the backdrop has been clicked. */\n  backdropClick(): Observable<MouseEvent> {\n    return this._backdropClick;\n  }\n\n  /** Gets an observable that emits when the overlay has been attached. */\n  attachments(): Observable<void> {\n    return this._attachments;\n  }\n\n  /** Gets an observable that emits when the overlay has been detached. */\n  detachments(): Observable<void> {\n    return this._detachments;\n  }\n\n  /** Gets an observable of keydown events targeted to this overlay. */\n  keydownEvents(): Observable<KeyboardEvent> {\n    return this._keydownEvents;\n  }\n\n  /** Gets an observable of pointer events targeted outside this overlay. */\n  outsidePointerEvents(): Observable<MouseEvent> {\n    return this._outsidePointerEvents;\n  }\n\n  /** Gets the current overlay configuration, which is immutable. */\n  getConfig(): OverlayConfig {\n    return this._config;\n  }\n\n  /** Updates the position of the overlay based on the position strategy. */\n  updatePosition(): void {\n    if (this._positionStrategy) {\n      this._positionStrategy.apply();\n    }\n  }\n\n  /** Switches to a new position strategy and updates the overlay position. */\n  updatePositionStrategy(strategy: PositionStrategy): void {\n    if (strategy === this._positionStrategy) {\n      return;\n    }\n\n    if (this._positionStrategy) {\n      this._positionStrategy.dispose();\n    }\n\n    this._positionStrategy = strategy;\n\n    if (this.hasAttached()) {\n      strategy.attach(this);\n      this.updatePosition();\n    }\n  }\n\n  /** Update the size properties of the overlay. */\n  updateSize(sizeConfig: OverlaySizeConfig): void {\n    this._config = {...this._config, ...sizeConfig};\n    this._updateElementSize();\n  }\n\n  /** Sets the LTR/RTL direction for the overlay. */\n  setDirection(dir: Direction | Directionality): void {\n    this._config = {...this._config, direction: dir};\n    this._updateElementDirection();\n  }\n\n  /** Add a CSS class or an array of classes to the overlay pane. */\n  addPanelClass(classes: string | string[]): void {\n    if (this._pane) {\n      this._toggleClasses(this._pane, classes, true);\n    }\n  }\n\n  /** Remove a CSS class or an array of classes from the overlay pane. */\n  removePanelClass(classes: string | string[]): void {\n    if (this._pane) {\n      this._toggleClasses(this._pane, classes, false);\n    }\n  }\n\n  /**\n   * Returns the layout direction of the overlay panel.\n   */\n  getDirection(): Direction {\n    const direction = this._config.direction;\n\n    if (!direction) {\n      return 'ltr';\n    }\n\n    return typeof direction === 'string' ? direction : direction.value;\n  }\n\n  /** Switches to a new scroll strategy. */\n  updateScrollStrategy(strategy: ScrollStrategy): void {\n    if (strategy === this._scrollStrategy) {\n      return;\n    }\n\n    this._disposeScrollStrategy();\n    this._scrollStrategy = strategy;\n\n    if (this.hasAttached()) {\n      strategy.attach(this);\n      strategy.enable();\n    }\n  }\n\n  /** Updates the text direction of the overlay panel. */\n  private _updateElementDirection() {\n    this._host.setAttribute('dir', this.getDirection());\n  }\n\n  /** Updates the size of the overlay element based on the overlay config. */\n  private _updateElementSize() {\n    if (!this._pane) {\n      return;\n    }\n\n    const style = this._pane.style;\n\n    style.width = coerceCssPixelValue(this._config.width);\n    style.height = coerceCssPixelValue(this._config.height);\n    style.minWidth = coerceCssPixelValue(this._config.minWidth);\n    style.minHeight = coerceCssPixelValue(this._config.minHeight);\n    style.maxWidth = coerceCssPixelValue(this._config.maxWidth);\n    style.maxHeight = coerceCssPixelValue(this._config.maxHeight);\n  }\n\n  /** Toggles the pointer events for the overlay pane element. */\n  private _togglePointerEvents(enablePointer: boolean) {\n    this._pane.style.pointerEvents = enablePointer ? '' : 'none';\n  }\n\n  /** Attaches a backdrop for this overlay. */\n  private _attachBackdrop() {\n    const showingClass = 'cdk-overlay-backdrop-showing';\n\n    this._backdropElement = this._document.createElement('div');\n    this._backdropElement.classList.add('cdk-overlay-backdrop');\n\n    if (this._animationsDisabled) {\n      this._backdropElement.classList.add('cdk-overlay-backdrop-noop-animation');\n    }\n\n    if (this._config.backdropClass) {\n      this._toggleClasses(this._backdropElement, this._config.backdropClass, true);\n    }\n\n    // Insert the backdrop before the pane in the DOM order,\n    // in order to handle stacked overlays properly.\n    this._host.parentElement!.insertBefore(this._backdropElement, this._host);\n\n    // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n    // action desired when such a click occurs (usually closing the overlay).\n    this._backdropElement.addEventListener('click', this._backdropClickHandler);\n\n    // Add class to fade-in the backdrop after one frame.\n    if (!this._animationsDisabled && typeof requestAnimationFrame !== 'undefined') {\n      this._ngZone.runOutsideAngular(() => {\n        requestAnimationFrame(() => {\n          if (this._backdropElement) {\n            this._backdropElement.classList.add(showingClass);\n          }\n        });\n      });\n    } else {\n      this._backdropElement.classList.add(showingClass);\n    }\n  }\n\n  /**\n   * Updates the stacking order of the element, moving it to the top if necessary.\n   * This is required in cases where one overlay was detached, while another one,\n   * that should be behind it, was destroyed. The next time both of them are opened,\n   * the stacking will be wrong, because the detached element's pane will still be\n   * in its original DOM position.\n   */\n  private _updateStackingOrder() {\n    if (this._host.nextSibling) {\n      this._host.parentNode!.appendChild(this._host);\n    }\n  }\n\n  /** Detaches the backdrop (if any) associated with the overlay. */\n  detachBackdrop(): void {\n    const backdropToDetach = this._backdropElement;\n\n    if (!backdropToDetach) {\n      return;\n    }\n\n    if (this._animationsDisabled) {\n      this._disposeBackdrop(backdropToDetach);\n      return;\n    }\n\n    backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n\n    this._ngZone.runOutsideAngular(() => {\n      backdropToDetach!.addEventListener('transitionend', this._backdropTransitionendHandler);\n    });\n\n    // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n    // In this case we make it unclickable and we try to remove it after a delay.\n    backdropToDetach.style.pointerEvents = 'none';\n\n    // Run this outside the Angular zone because there's nothing that Angular cares about.\n    // If it were to run inside the Angular zone, every test that used Overlay would have to be\n    // either async or fakeAsync.\n    this._backdropTimeout = this._ngZone.runOutsideAngular(() =>\n      setTimeout(() => {\n        this._disposeBackdrop(backdropToDetach);\n      }, 500),\n    );\n  }\n\n  /** Toggles a single CSS class or an array of classes on an element. */\n  private _toggleClasses(element: HTMLElement, cssClasses: string | string[], isAdd: boolean) {\n    const classes = coerceArray(cssClasses || []).filter(c => !!c);\n\n    if (classes.length) {\n      isAdd ? element.classList.add(...classes) : element.classList.remove(...classes);\n    }\n  }\n\n  /** Detaches the overlay content next time the zone stabilizes. */\n  private _detachContentWhenStable() {\n    // Normally we wouldn't have to explicitly run this outside the `NgZone`, however\n    // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will\n    // be patched to run inside the zone, which will throw us into an infinite loop.\n    this._ngZone.runOutsideAngular(() => {\n      // We can't remove the host here immediately, because the overlay pane's content\n      // might still be animating. This stream helps us avoid interrupting the animation\n      // by waiting for the pane to become empty.\n      const subscription = this._ngZone.onStable\n        .pipe(takeUntil(merge(this._attachments, this._detachments)))\n        .subscribe(() => {\n          // Needs a couple of checks for the pane and host, because\n          // they may have been removed by the time the zone stabilizes.\n          if (!this._pane || !this._host || this._pane.children.length === 0) {\n            if (this._pane && this._config.panelClass) {\n              this._toggleClasses(this._pane, this._config.panelClass, false);\n            }\n\n            if (this._host && this._host.parentElement) {\n              this._previousHostParent = this._host.parentElement;\n              this._host.remove();\n            }\n\n            subscription.unsubscribe();\n          }\n        });\n    });\n  }\n\n  /** Disposes of a scroll strategy. */\n  private _disposeScrollStrategy() {\n    const scrollStrategy = this._scrollStrategy;\n\n    if (scrollStrategy) {\n      scrollStrategy.disable();\n\n      if (scrollStrategy.detach) {\n        scrollStrategy.detach();\n      }\n    }\n  }\n\n  /** Removes a backdrop element from the DOM. */\n  private _disposeBackdrop(backdrop: HTMLElement | null) {\n    if (backdrop) {\n      backdrop.removeEventListener('click', this._backdropClickHandler);\n      backdrop.removeEventListener('transitionend', this._backdropTransitionendHandler);\n      backdrop.remove();\n\n      // It is possible that a new portal has been attached to this overlay since we started\n      // removing the backdrop. If that is the case, only clear the backdrop reference if it\n      // is still the same instance that we started to remove.\n      if (this._backdropElement === backdrop) {\n        this._backdropElement = null;\n      }\n    }\n\n    if (this._backdropTimeout) {\n      clearTimeout(this._backdropTimeout);\n      this._backdropTimeout = undefined;\n    }\n  }\n}\n\n/** Size properties for an overlay. */\nexport interface OverlaySizeConfig {\n  width?: number | string;\n  height?: number | string;\n  minWidth?: number | string;\n  minHeight?: number | string;\n  maxWidth?: number | string;\n  maxHeight?: number | string;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {PositionStrategy} from './position-strategy';\nimport {ElementRef} from '@angular/core';\nimport {ViewportRuler, CdkScrollable, ViewportScrollPosition} from '@angular/cdk/scrolling';\nimport {\n  ConnectedOverlayPositionChange,\n  ConnectionPositionPair,\n  ScrollingVisibility,\n  validateHorizontalPosition,\n  validateVerticalPosition,\n} from './connected-position';\nimport {Observable, Subscription, Subject} from 'rxjs';\nimport {isElementScrolledOutsideView, isElementClippedByScrolling} from './scroll-clip';\nimport {coerceCssPixelValue, coerceArray} from '@angular/cdk/coercion';\nimport {Platform} from '@angular/cdk/platform';\nimport {OverlayContainer} from '../overlay-container';\nimport {OverlayRef} from '../overlay-ref';\n\n// TODO: refactor clipping detection into a separate thing (part of scrolling module)\n// TODO: doesn't handle both flexible width and height when it has to scroll along both axis.\n\n/** Class to be added to the overlay bounding box. */\nconst boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';\n\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n\n/** Possible values that can be set as the origin of a FlexibleConnectedPositionStrategy. */\nexport type FlexibleConnectedPositionStrategyOrigin =\n  | ElementRef\n  | Element\n  | (Point & {\n      width?: number;\n      height?: number;\n    });\n\n/** Equivalent of `ClientRect` without some of the properties we don't care about. */\ntype Dimensions = Omit<ClientRect, 'x' | 'y' | 'toJSON'>;\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nexport class FlexibleConnectedPositionStrategy implements PositionStrategy {\n  /** The overlay to which this strategy is attached. */\n  private _overlayRef: OverlayRef;\n\n  /** Whether we're performing the very first positioning of the overlay. */\n  private _isInitialRender: boolean;\n\n  /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */\n  private _lastBoundingBoxSize = {width: 0, height: 0};\n\n  /** Whether the overlay was pushed in a previous positioning. */\n  private _isPushed = false;\n\n  /** Whether the overlay can be pushed on-screen on the initial open. */\n  private _canPush = true;\n\n  /** Whether the overlay can grow via flexible width/height after the initial open. */\n  private _growAfterOpen = false;\n\n  /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n  private _hasFlexibleDimensions = true;\n\n  /** Whether the overlay position is locked. */\n  private _positionLocked = false;\n\n  /** Cached origin dimensions */\n  private _originRect: Dimensions;\n\n  /** Cached overlay dimensions */\n  private _overlayRect: Dimensions;\n\n  /** Cached viewport dimensions */\n  private _viewportRect: Dimensions;\n\n  /** Cached container dimensions */\n  private _containerRect: Dimensions;\n\n  /** Amount of space that must be maintained between the overlay and the edge of the viewport. */\n  private _viewportMargin = 0;\n\n  /** The Scrollable containers used to check scrollable view properties on position change. */\n  private _scrollables: CdkScrollable[] = [];\n\n  /** Ordered list of preferred positions, from most to least desirable. */\n  _preferredPositions: ConnectionPositionPair[] = [];\n\n  /** The origin element against which the overlay will be positioned. */\n  _origin: FlexibleConnectedPositionStrategyOrigin;\n\n  /** The overlay pane element. */\n  private _pane: HTMLElement;\n\n  /** Whether the strategy has been disposed of already. */\n  private _isDisposed: boolean;\n\n  /**\n   * Parent element for the overlay panel used to constrain the overlay panel's size to fit\n   * within the viewport.\n   */\n  private _boundingBox: HTMLElement | null;\n\n  /** The last position to have been calculated as the best fit position. */\n  private _lastPosition: ConnectedPosition | null;\n\n  /** Subject that emits whenever the position changes. */\n  private readonly _positionChanges = new Subject<ConnectedOverlayPositionChange>();\n\n  /** Subscription to viewport size changes. */\n  private _resizeSubscription = Subscription.EMPTY;\n\n  /** Default offset for the overlay along the x axis. */\n  private _offsetX = 0;\n\n  /** Default offset for the overlay along the y axis. */\n  private _offsetY = 0;\n\n  /** Selector to be used when finding the elements on which to set the transform origin. */\n  private _transformOriginSelector: string;\n\n  /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */\n  private _appliedPanelClasses: string[] = [];\n\n  /** Amount by which the overlay was pushed in each axis during the last time it was positioned. */\n  private _previousPushAmount: {x: number; y: number} | null;\n\n  /** Observable sequence of position changes. */\n  positionChanges: Observable<ConnectedOverlayPositionChange> = this._positionChanges;\n\n  /** Ordered list of preferred positions, from most to least desirable. */\n  get positions(): ConnectionPositionPair[] {\n    return this._preferredPositions;\n  }\n\n  constructor(\n    connectedTo: FlexibleConnectedPositionStrategyOrigin,\n    private _viewportRuler: ViewportRuler,\n    private _document: Document,\n    private _platform: Platform,\n    private _overlayContainer: OverlayContainer,\n  ) {\n    this.setOrigin(connectedTo);\n  }\n\n  /** Attaches this position strategy to an overlay. */\n  attach(overlayRef: OverlayRef): void {\n    if (\n      this._overlayRef &&\n      overlayRef !== this._overlayRef &&\n      (typeof ngDevMode === 'undefined' || ngDevMode)\n    ) {\n      throw Error('This position strategy is already attached to an overlay');\n    }\n\n    this._validatePositions();\n\n    overlayRef.hostElement.classList.add(boundingBoxClass);\n\n    this._overlayRef = overlayRef;\n    this._boundingBox = overlayRef.hostElement;\n    this._pane = overlayRef.overlayElement;\n    this._isDisposed = false;\n    this._isInitialRender = true;\n    this._lastPosition = null;\n    this._resizeSubscription.unsubscribe();\n    this._resizeSubscription = this._viewportRuler.change().subscribe(() => {\n      // When the window is resized, we want to trigger the next reposition as if it\n      // was an initial render, in order for the strategy to pick a new optimal position,\n      // otherwise position locking will cause it to stay at the old one.\n      this._isInitialRender = true;\n      this.apply();\n    });\n  }\n\n  /**\n   * Updates the position of the overlay element, using whichever preferred position relative\n   * to the origin best fits on-screen.\n   *\n   * The selection of a position goes as follows:\n   *  - If any positions fit completely within the viewport as-is,\n   *      choose the first position that does so.\n   *  - If flexible dimensions are enabled and at least one satisfies the given minimum width/height,\n   *      choose the position with the greatest available size modified by the positions' weight.\n   *  - If pushing is enabled, take the position that went off-screen the least and push it\n   *      on-screen.\n   *  - If none of the previous criteria were met, use the position that goes off-screen the least.\n   * @docs-private\n   */\n  apply(): void {\n    // We shouldn't do anything if the strategy was disposed or we're on the server.\n    if (this._isDisposed || !this._platform.isBrowser) {\n      return;\n    }\n\n    // If the position has been applied already (e.g. when the overlay was opened) and the\n    // consumer opted into locking in the position, re-use the old position, in order to\n    // prevent the overlay from jumping around.\n    if (!this._isInitialRender && this._positionLocked && this._lastPosition) {\n      this.reapplyLastPosition();\n      return;\n    }\n\n    this._clearPanelClasses();\n    this._resetOverlayElementStyles();\n    this._resetBoundingBoxStyles();\n\n    // We need the bounding rects for the origin, the overlay and the container to determine how to position\n    // the overlay relative to the origin.\n    // We use the viewport rect to determine whether a position would go off-screen.\n    this._viewportRect = this._getNarrowedViewportRect();\n    this._originRect = this._getOriginRect();\n    this._overlayRect = this._pane.getBoundingClientRect();\n    this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();\n\n    const originRect = this._originRect;\n    const overlayRect = this._overlayRect;\n    const viewportRect = this._viewportRect;\n    const containerRect = this._containerRect;\n\n    // Positions where the overlay will fit with flexible dimensions.\n    const flexibleFits: FlexibleFit[] = [];\n\n    // Fallback if none of the preferred positions fit within the viewport.\n    let fallback: FallbackPosition | undefined;\n\n    // Go through each of the preferred positions looking for a good fit.\n    // If a good fit is found, it will be applied immediately.\n    for (let pos of this._preferredPositions) {\n      // Get the exact (x, y) coordinate for the point-of-origin on the origin element.\n      let originPoint = this._getOriginPoint(originRect, containerRect, pos);\n\n      // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the\n      // overlay in this position. We use the top-left corner for calculations and later translate\n      // this into an appropriate (top, left, bottom, right) style.\n      let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\n\n      // Calculate how well the overlay would fit into the viewport with this point.\n      let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);\n\n      // If the overlay, without any further work, fits into the viewport, use this position.\n      if (overlayFit.isCompletelyWithinViewport) {\n        this._isPushed = false;\n        this._applyPosition(pos, originPoint);\n        return;\n      }\n\n      // If the overlay has flexible dimensions, we can use this position\n      // so long as there's enough space for the minimum dimensions.\n      if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {\n        // Save positions where the overlay will fit with flexible dimensions. We will use these\n        // if none of the positions fit *without* flexible dimensions.\n        flexibleFits.push({\n          position: pos,\n          origin: originPoint,\n          overlayRect,\n          boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos),\n        });\n\n        continue;\n      }\n\n      // If the current preferred position does not fit on the screen, remember the position\n      // if it has more visible area on-screen than we've seen and move onto the next preferred\n      // position.\n      if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {\n        fallback = {overlayFit, overlayPoint, originPoint, position: pos, overlayRect};\n      }\n    }\n\n    // If there are any positions where the overlay would fit with flexible dimensions, choose the\n    // one that has the greatest area available modified by the position's weight\n    if (flexibleFits.length) {\n      let bestFit: FlexibleFit | null = null;\n      let bestScore = -1;\n      for (const fit of flexibleFits) {\n        const score =\n          fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);\n        if (score > bestScore) {\n          bestScore = score;\n          bestFit = fit;\n        }\n      }\n\n      this._isPushed = false;\n      this._applyPosition(bestFit!.position, bestFit!.origin);\n      return;\n    }\n\n    // When none of the preferred positions fit within the viewport, take the position\n    // that went off-screen the least and attempt to push it on-screen.\n    if (this._canPush) {\n      // TODO(jelbourn): after pushing, the opening \"direction\" of the overlay might not make sense.\n      this._isPushed = true;\n      this._applyPosition(fallback!.position, fallback!.originPoint);\n      return;\n    }\n\n    // All options for getting the overlay within the viewport have been exhausted, so go with the\n    // position that went off-screen the least.\n    this._applyPosition(fallback!.position, fallback!.originPoint);\n  }\n\n  detach(): void {\n    this._clearPanelClasses();\n    this._lastPosition = null;\n    this._previousPushAmount = null;\n    this._resizeSubscription.unsubscribe();\n  }\n\n  /** Cleanup after the element gets destroyed. */\n  dispose(): void {\n    if (this._isDisposed) {\n      return;\n    }\n\n    // We can't use `_resetBoundingBoxStyles` here, because it resets\n    // some properties to zero, rather than removing them.\n    if (this._boundingBox) {\n      extendStyles(this._boundingBox.style, {\n        top: '',\n        left: '',\n        right: '',\n        bottom: '',\n        height: '',\n        width: '',\n        alignItems: '',\n        justifyContent: '',\n      } as CSSStyleDeclaration);\n    }\n\n    if (this._pane) {\n      this._resetOverlayElementStyles();\n    }\n\n    if (this._overlayRef) {\n      this._overlayRef.hostElement.classList.remove(boundingBoxClass);\n    }\n\n    this.detach();\n    this._positionChanges.complete();\n    this._overlayRef = this._boundingBox = null!;\n    this._isDisposed = true;\n  }\n\n  /**\n   * This re-aligns the overlay element with the trigger in its last calculated position,\n   * even if a position higher in the \"preferred positions\" list would now fit. This\n   * allows one to re-align the panel without changing the orientation of the panel.\n   */\n  reapplyLastPosition(): void {\n    if (this._isDisposed || !this._platform.isBrowser) {\n      return;\n    }\n\n    const lastPosition = this._lastPosition;\n\n    if (lastPosition) {\n      this._originRect = this._getOriginRect();\n      this._overlayRect = this._pane.getBoundingClientRect();\n      this._viewportRect = this._getNarrowedViewportRect();\n      this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();\n\n      const originPoint = this._getOriginPoint(this._originRect, this._containerRect, lastPosition);\n      this._applyPosition(lastPosition, originPoint);\n    } else {\n      this.apply();\n    }\n  }\n\n  /**\n   * Sets the list of Scrollable containers that host the origin element so that\n   * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n   * Scrollable must be an ancestor element of the strategy's origin element.\n   */\n  withScrollableContainers(scrollables: CdkScrollable[]): this {\n    this._scrollables = scrollables;\n    return this;\n  }\n\n  /**\n   * Adds new preferred positions.\n   * @param positions List of positions options for this overlay.\n   */\n  withPositions(positions: ConnectedPosition[]): this {\n    this._preferredPositions = positions;\n\n    // If the last calculated position object isn't part of the positions anymore, clear\n    // it in order to avoid it being picked up if the consumer tries to re-apply.\n    if (positions.indexOf(this._lastPosition!) === -1) {\n      this._lastPosition = null;\n    }\n\n    this._validatePositions();\n\n    return this;\n  }\n\n  /**\n   * Sets a minimum distance the overlay may be positioned to the edge of the viewport.\n   * @param margin Required margin between the overlay and the viewport edge in pixels.\n   */\n  withViewportMargin(margin: number): this {\n    this._viewportMargin = margin;\n    return this;\n  }\n\n  /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */\n  withFlexibleDimensions(flexibleDimensions = true): this {\n    this._hasFlexibleDimensions = flexibleDimensions;\n    return this;\n  }\n\n  /** Sets whether the overlay can grow after the initial open via flexible width/height. */\n  withGrowAfterOpen(growAfterOpen = true): this {\n    this._growAfterOpen = growAfterOpen;\n    return this;\n  }\n\n  /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */\n  withPush(canPush = true): this {\n    this._canPush = canPush;\n    return this;\n  }\n\n  /**\n   * Sets whether the overlay's position should be locked in after it is positioned\n   * initially. When an overlay is locked in, it won't attempt to reposition itself\n   * when the position is re-applied (e.g. when the user scrolls away).\n   * @param isLocked Whether the overlay should locked in.\n   */\n  withLockedPosition(isLocked = true): this {\n    this._positionLocked = isLocked;\n    return this;\n  }\n\n  /**\n   * Sets the origin, relative to which to position the overlay.\n   * Using an element origin is useful for building components that need to be positioned\n   * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be\n   * used for cases like contextual menus which open relative to the user's pointer.\n   * @param origin Reference to the new origin.\n   */\n  setOrigin(origin: FlexibleConnectedPositionStrategyOrigin): this {\n    this._origin = origin;\n    return this;\n  }\n\n  /**\n   * Sets the default offset for the overlay's connection point on the x-axis.\n   * @param offset New offset in the X axis.\n   */\n  withDefaultOffsetX(offset: number): this {\n    this._offsetX = offset;\n    return this;\n  }\n\n  /**\n   * Sets the default offset for the overlay's connection point on the y-axis.\n   * @param offset New offset in the Y axis.\n   */\n  withDefaultOffsetY(offset: number): this {\n    this._offsetY = offset;\n    return this;\n  }\n\n  /**\n   * Configures that the position strategy should set a `transform-origin` on some elements\n   * inside the overlay, depending on the current position that is being applied. This is\n   * useful for the cases where the origin of an animation can change depending on the\n   * alignment of the overlay.\n   * @param selector CSS selector that will be used to find the target\n   *    elements onto which to set the transform origin.\n   */\n  withTransformOriginOn(selector: string): this {\n    this._transformOriginSelector = selector;\n    return this;\n  }\n\n  /**\n   * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n   */\n  private _getOriginPoint(\n    originRect: Dimensions,\n    containerRect: Dimensions,\n    pos: ConnectedPosition,\n  ): Point {\n    let x: number;\n    if (pos.originX == 'center') {\n      // Note: when centering we should always use the `left`\n      // offset, otherwise the position will be wrong in RTL.\n      x = originRect.left + originRect.width / 2;\n    } else {\n      const startX = this._isRtl() ? originRect.right : originRect.left;\n      const endX = this._isRtl() ? originRect.left : originRect.right;\n      x = pos.originX == 'start' ? startX : endX;\n    }\n\n    // When zooming in Safari the container rectangle contains negative values for the position\n    // and we need to re-add them to the calculated coordinates.\n    if (containerRect.left < 0) {\n      x -= containerRect.left;\n    }\n\n    let y: number;\n    if (pos.originY == 'center') {\n      y = originRect.top + originRect.height / 2;\n    } else {\n      y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n    }\n\n    // Normally the containerRect's top value would be zero, however when the overlay is attached to an input\n    // (e.g. in an autocomplete), mobile browsers will shift everything in order to put the input in the middle\n    // of the screen and to make space for the virtual keyboard. We need to account for this offset,\n    // otherwise our positioning will be thrown off.\n    // Additionally, when zooming in Safari this fixes the vertical position.\n    if (containerRect.top < 0) {\n      y -= containerRect.top;\n    }\n\n    return {x, y};\n  }\n\n  /**\n   * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n   * origin point to which the overlay should be connected.\n   */\n  private _getOverlayPoint(\n    originPoint: Point,\n    overlayRect: Dimensions,\n    pos: ConnectedPosition,\n  ): Point {\n    // Calculate the (overlayStartX, overlayStartY), the start of the\n    // potential overlay position relative to the origin point.\n    let overlayStartX: number;\n    if (pos.overlayX == 'center') {\n      overlayStartX = -overlayRect.width / 2;\n    } else if (pos.overlayX === 'start') {\n      overlayStartX = this._isRtl() ? -overlayRect.width : 0;\n    } else {\n      overlayStartX = this._isRtl() ? 0 : -overlayRect.width;\n    }\n\n    let overlayStartY: number;\n    if (pos.overlayY == 'center') {\n      overlayStartY = -overlayRect.height / 2;\n    } else {\n      overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n    }\n\n    // The (x, y) coordinates of the overlay.\n    return {\n      x: originPoint.x + overlayStartX,\n      y: originPoint.y + overlayStartY,\n    };\n  }\n\n  /** Gets how well an overlay at the given point will fit within the viewport. */\n  private _getOverlayFit(\n    point: Point,\n    rawOverlayRect: Dimensions,\n    viewport: Dimensions,\n    position: ConnectedPosition,\n  ): OverlayFit {\n    // Round the overlay rect when comparing against the\n    // viewport, because the viewport is always rounded.\n    const overlay = getRoundedBoundingClientRect(rawOverlayRect);\n    let {x, y} = point;\n    let offsetX = this._getOffset(position, 'x');\n    let offsetY = this._getOffset(position, 'y');\n\n    // Account for the offsets since they could push the overlay out of the viewport.\n    if (offsetX) {\n      x += offsetX;\n    }\n\n    if (offsetY) {\n      y += offsetY;\n    }\n\n    // How much the overlay would overflow at this position, on each side.\n    let leftOverflow = 0 - x;\n    let rightOverflow = x + overlay.width - viewport.width;\n    let topOverflow = 0 - y;\n    let bottomOverflow = y + overlay.height - viewport.height;\n\n    // Visible parts of the element on each axis.\n    let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);\n    let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);\n    let visibleArea = visibleWidth * visibleHeight;\n\n    return {\n      visibleArea,\n      isCompletelyWithinViewport: overlay.width * overlay.height === visibleArea,\n      fitsInViewportVertically: visibleHeight === overlay.height,\n      fitsInViewportHorizontally: visibleWidth == overlay.width,\n    };\n  }\n\n  /**\n   * Whether the overlay can fit within the viewport when it may resize either its width or height.\n   * @param fit How well the overlay fits in the viewport at some position.\n   * @param point The (x, y) coordinates of the overlay at some position.\n   * @param viewport The geometry of the viewport.\n   */\n  private _canFitWithFlexibleDimensions(fit: OverlayFit, point: Point, viewport: Dimensions) {\n    if (this._hasFlexibleDimensions) {\n      const availableHeight = viewport.bottom - point.y;\n      const availableWidth = viewport.right - point.x;\n      const minHeight = getPixelValue(this._overlayRef.getConfig().minHeight);\n      const minWidth = getPixelValue(this._overlayRef.getConfig().minWidth);\n\n      const verticalFit =\n        fit.fitsInViewportVertically || (minHeight != null && minHeight <= availableHeight);\n      const horizontalFit =\n        fit.fitsInViewportHorizontally || (minWidth != null && minWidth <= availableWidth);\n\n      return verticalFit && horizontalFit;\n    }\n    return false;\n  }\n\n  /**\n   * Gets the point at which the overlay can be \"pushed\" on-screen. If the overlay is larger than\n   * the viewport, the top-left corner will be pushed on-screen (with overflow occurring on the\n   * right and bottom).\n   *\n   * @param start Starting point from which the overlay is pushed.\n   * @param rawOverlayRect Dimensions of the overlay.\n   * @param scrollPosition Current viewport scroll position.\n   * @returns The point at which to position the overlay after pushing. This is effectively a new\n   *     originPoint.\n   */\n  private _pushOverlayOnScreen(\n    start: Point,\n    rawOverlayRect: Dimensions,\n    scrollPosition: ViewportScrollPosition,\n  ): Point {\n    // If the position is locked and we've pushed the overlay already, reuse the previous push\n    // amount, rather than pushing it again. If we were to continue pushing, the element would\n    // remain in the viewport, which goes against the expectations when position locking is enabled.\n    if (this._previousPushAmount && this._positionLocked) {\n      return {\n        x: start.x + this._previousPushAmount.x,\n        y: start.y + this._previousPushAmount.y,\n      };\n    }\n\n    // Round the overlay rect when comparing against the\n    // viewport, because the viewport is always rounded.\n    const overlay = getRoundedBoundingClientRect(rawOverlayRect);\n    const viewport = this._viewportRect;\n\n    // Determine how much the overlay goes outside the viewport on each\n    // side, which we'll use to decide which direction to push it.\n    const overflowRight = Math.max(start.x + overlay.width - viewport.width, 0);\n    const overflowBottom = Math.max(start.y + overlay.height - viewport.height, 0);\n    const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);\n    const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);\n\n    // Amount by which to push the overlay in each axis such that it remains on-screen.\n    let pushX = 0;\n    let pushY = 0;\n\n    // If the overlay fits completely within the bounds of the viewport, push it from whichever\n    // direction is goes off-screen. Otherwise, push the top-left corner such that its in the\n    // viewport and allow for the trailing end of the overlay to go out of bounds.\n    if (overlay.width <= viewport.width) {\n      pushX = overflowLeft || -overflowRight;\n    } else {\n      pushX = start.x < this._viewportMargin ? viewport.left - scrollPosition.left - start.x : 0;\n    }\n\n    if (overlay.height <= viewport.height) {\n      pushY = overflowTop || -overflowBottom;\n    } else {\n      pushY = start.y < this._viewportMargin ? viewport.top - scrollPosition.top - start.y : 0;\n    }\n\n    this._previousPushAmount = {x: pushX, y: pushY};\n\n    return {\n      x: start.x + pushX,\n      y: start.y + pushY,\n    };\n  }\n\n  /**\n   * Applies a computed position to the overlay and emits a position change.\n   * @param position The position preference\n   * @param originPoint The point on the origin element where the overlay is connected.\n   */\n  private _applyPosition(position: ConnectedPosition, originPoint: Point) {\n    this._setTransformOrigin(position);\n    this._setOverlayElementStyles(originPoint, position);\n    this._setBoundingBoxStyles(originPoint, position);\n\n    if (position.panelClass) {\n      this._addPanelClasses(position.panelClass);\n    }\n\n    // Save the last connected position in case the position needs to be re-calculated.\n    this._lastPosition = position;\n\n    // Notify that the position has been changed along with its change properties.\n    // We only emit if we've got any subscriptions, because the scroll visibility\n    // calculations can be somewhat expensive.\n    if (this._positionChanges.observers.length) {\n      const scrollableViewProperties = this._getScrollVisibility();\n      const changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);\n      this._positionChanges.next(changeEvent);\n    }\n\n    this._isInitialRender = false;\n  }\n\n  /** Sets the transform origin based on the configured selector and the passed-in position.  */\n  private _setTransformOrigin(position: ConnectedPosition) {\n    if (!this._transformOriginSelector) {\n      return;\n    }\n\n    const elements: NodeListOf<HTMLElement> = this._boundingBox!.querySelectorAll(\n      this._transformOriginSelector,\n    );\n    let xOrigin: 'left' | 'right' | 'center';\n    let yOrigin: 'top' | 'bottom' | 'center' = position.overlayY;\n\n    if (position.overlayX === 'center') {\n      xOrigin = 'center';\n    } else if (this._isRtl()) {\n      xOrigin = position.overlayX === 'start' ? 'right' : 'left';\n    } else {\n      xOrigin = position.overlayX === 'start' ? 'left' : 'right';\n    }\n\n    for (let i = 0; i < elements.length; i++) {\n      elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;\n    }\n  }\n\n  /**\n   * Gets the position and size of the overlay's sizing container.\n   *\n   * This method does no measuring and applies no styles so that we can cheaply compute the\n   * bounds for all positions and choose the best fit based on these results.\n   */\n  private _calculateBoundingBoxRect(origin: Point, position: ConnectedPosition): BoundingBoxRect {\n    const viewport = this._viewportRect;\n    const isRtl = this._isRtl();\n    let height: number, top: number, bottom: number;\n\n    if (position.overlayY === 'top') {\n      // Overlay is opening \"downward\" and thus is bound by the bottom viewport edge.\n      top = origin.y;\n      height = viewport.height - top + this._viewportMargin;\n    } else if (position.overlayY === 'bottom') {\n      // Overlay is opening \"upward\" and thus is bound by the top viewport edge. We need to add\n      // the viewport margin back in, because the viewport rect is narrowed down to remove the\n      // margin, whereas the `origin` position is calculated based on its `ClientRect`.\n      bottom = viewport.height - origin.y + this._viewportMargin * 2;\n      height = viewport.height - bottom + this._viewportMargin;\n    } else {\n      // If neither top nor bottom, it means that the overlay is vertically centered on the\n      // origin point. Note that we want the position relative to the viewport, rather than\n      // the page, which is why we don't use something like `viewport.bottom - origin.y` and\n      // `origin.y - viewport.top`.\n      const smallestDistanceToViewportEdge = Math.min(\n        viewport.bottom - origin.y + viewport.top,\n        origin.y,\n      );\n\n      const previousHeight = this._lastBoundingBoxSize.height;\n\n      height = smallestDistanceToViewportEdge * 2;\n      top = origin.y - smallestDistanceToViewportEdge;\n\n      if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {\n        top = origin.y - previousHeight / 2;\n      }\n    }\n\n    // The overlay is opening 'right-ward' (the content flows to the right).\n    const isBoundedByRightViewportEdge =\n      (position.overlayX === 'start' && !isRtl) || (position.overlayX === 'end' && isRtl);\n\n    // The overlay is opening 'left-ward' (the content flows to the left).\n    const isBoundedByLeftViewportEdge =\n      (position.overlayX === 'end' && !isRtl) || (position.overlayX === 'start' && isRtl);\n\n    let width: number, left: number, right: number;\n\n    if (isBoundedByLeftViewportEdge) {\n      right = viewport.width - origin.x + this._viewportMargin;\n      width = origin.x - this._viewportMargin;\n    } else if (isBoundedByRightViewportEdge) {\n      left = origin.x;\n      width = viewport.right - origin.x;\n    } else {\n      // If neither start nor end, it means that the overlay is horizontally centered on the\n      // origin point. Note that we want the position relative to the viewport, rather than\n      // the page, which is why we don't use something like `viewport.right - origin.x` and\n      // `origin.x - viewport.left`.\n      const smallestDistanceToViewportEdge = Math.min(\n        viewport.right - origin.x + viewport.left,\n        origin.x,\n      );\n      const previousWidth = this._lastBoundingBoxSize.width;\n\n      width = smallestDistanceToViewportEdge * 2;\n      left = origin.x - smallestDistanceToViewportEdge;\n\n      if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {\n        left = origin.x - previousWidth / 2;\n      }\n    }\n\n    return {top: top!, left: left!, bottom: bottom!, right: right!, width, height};\n  }\n\n  /**\n   * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the\n   * origin's connection point and stretches to the bounds of the viewport.\n   *\n   * @param origin The point on the origin element where the overlay is connected.\n   * @param position The position preference\n   */\n  private _setBoundingBoxStyles(origin: Point, position: ConnectedPosition): void {\n    const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);\n\n    // It's weird if the overlay *grows* while scrolling, so we take the last size into account\n    // when applying a new size.\n    if (!this._isInitialRender && !this._growAfterOpen) {\n      boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);\n      boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);\n    }\n\n    const styles = {} as CSSStyleDeclaration;\n\n    if (this._hasExactPosition()) {\n      styles.top = styles.left = '0';\n      styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = '';\n      styles.width = styles.height = '100%';\n    } else {\n      const maxHeight = this._overlayRef.getConfig().maxHeight;\n      const maxWidth = this._overlayRef.getConfig().maxWidth;\n\n      styles.height = coerceCssPixelValue(boundingBoxRect.height);\n      styles.top = coerceCssPixelValue(boundingBoxRect.top);\n      styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);\n      styles.width = coerceCssPixelValue(boundingBoxRect.width);\n      styles.left = coerceCssPixelValue(boundingBoxRect.left);\n      styles.right = coerceCssPixelValue(boundingBoxRect.right);\n\n      // Push the pane content towards the proper direction.\n      if (position.overlayX === 'center') {\n        styles.alignItems = 'center';\n      } else {\n        styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';\n      }\n\n      if (position.overlayY === 'center') {\n        styles.justifyContent = 'center';\n      } else {\n        styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';\n      }\n\n      if (maxHeight) {\n        styles.maxHeight = coerceCssPixelValue(maxHeight);\n      }\n\n      if (maxWidth) {\n        styles.maxWidth = coerceCssPixelValue(maxWidth);\n      }\n    }\n\n    this._lastBoundingBoxSize = boundingBoxRect;\n\n    extendStyles(this._boundingBox!.style, styles);\n  }\n\n  /** Resets the styles for the bounding box so that a new positioning can be computed. */\n  private _resetBoundingBoxStyles() {\n    extendStyles(this._boundingBox!.style, {\n      top: '0',\n      left: '0',\n      right: '0',\n      bottom: '0',\n      height: '',\n      width: '',\n      alignItems: '',\n      justifyContent: '',\n    } as CSSStyleDeclaration);\n  }\n\n  /** Resets the styles for the overlay pane so that a new positioning can be computed. */\n  private _resetOverlayElementStyles() {\n    extendStyles(this._pane.style, {\n      top: '',\n      left: '',\n      bottom: '',\n      right: '',\n      position: '',\n      transform: '',\n    } as CSSStyleDeclaration);\n  }\n\n  /** Sets positioning styles to the overlay element. */\n  private _setOverlayElementStyles(originPoint: Point, position: ConnectedPosition): void {\n    const styles = {} as CSSStyleDeclaration;\n    const hasExactPosition = this._hasExactPosition();\n    const hasFlexibleDimensions = this._hasFlexibleDimensions;\n    const config = this._overlayRef.getConfig();\n\n    if (hasExactPosition) {\n      const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n      extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));\n      extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));\n    } else {\n      styles.position = 'static';\n    }\n\n    // Use a transform to apply the offsets. We do this because the `center` positions rely on\n    // being in the normal flex flow and setting a `top` / `left` at all will completely throw\n    // off the position. We also can't use margins, because they won't have an effect in some\n    // cases where the element doesn't have anything to \"push off of\". Finally, this works\n    // better both with flexible and non-flexible positioning.\n    let transformString = '';\n    let offsetX = this._getOffset(position, 'x');\n    let offsetY = this._getOffset(position, 'y');\n\n    if (offsetX) {\n      transformString += `translateX(${offsetX}px) `;\n    }\n\n    if (offsetY) {\n      transformString += `translateY(${offsetY}px)`;\n    }\n\n    styles.transform = transformString.trim();\n\n    // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because\n    // we need these values to both be set to \"100%\" for the automatic flexible sizing to work.\n    // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.\n    // Note that this doesn't apply when we have an exact position, in which case we do want to\n    // apply them because they'll be cleared from the bounding box.\n    if (config.maxHeight) {\n      if (hasExactPosition) {\n        styles.maxHeight = coerceCssPixelValue(config.maxHeight);\n      } else if (hasFlexibleDimensions) {\n        styles.maxHeight = '';\n      }\n    }\n\n    if (config.maxWidth) {\n      if (hasExactPosition) {\n        styles.maxWidth = coerceCssPixelValue(config.maxWidth);\n      } else if (hasFlexibleDimensions) {\n        styles.maxWidth = '';\n      }\n    }\n\n    extendStyles(this._pane.style, styles);\n  }\n\n  /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */\n  private _getExactOverlayY(\n    position: ConnectedPosition,\n    originPoint: Point,\n    scrollPosition: ViewportScrollPosition,\n  ) {\n    // Reset any existing styles. This is necessary in case the\n    // preferred position has changed since the last `apply`.\n    let styles = {top: '', bottom: ''} as CSSStyleDeclaration;\n    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n\n    if (this._isPushed) {\n      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n    }\n\n    // We want to set either `top` or `bottom` based on whether the overlay wants to appear\n    // above or below the origin and the direction in which the element will expand.\n    if (position.overlayY === 'bottom') {\n      // When using `bottom`, we adjust the y position such that it is the distance\n      // from the bottom of the viewport rather than the top.\n      const documentHeight = this._document.documentElement!.clientHeight;\n      styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;\n    } else {\n      styles.top = coerceCssPixelValue(overlayPoint.y);\n    }\n\n    return styles;\n  }\n\n  /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */\n  private _getExactOverlayX(\n    position: ConnectedPosition,\n    originPoint: Point,\n    scrollPosition: ViewportScrollPosition,\n  ) {\n    // Reset any existing styles. This is necessary in case the preferred position has\n    // changed since the last `apply`.\n    let styles = {left: '', right: ''} as CSSStyleDeclaration;\n    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n\n    if (this._isPushed) {\n      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n    }\n\n    // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n    // or \"after\" the origin, which determines the direction in which the element will expand.\n    // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n    // page is in RTL or LTR.\n    let horizontalStyleProperty: 'left' | 'right';\n\n    if (this._isRtl()) {\n      horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';\n    } else {\n      horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';\n    }\n\n    // When we're setting `right`, we adjust the x position such that it is the distance\n    // from the right edge of the viewport rather than the left edge.\n    if (horizontalStyleProperty === 'right') {\n      const documentWidth = this._document.documentElement!.clientWidth;\n      styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;\n    } else {\n      styles.left = coerceCssPixelValue(overlayPoint.x);\n    }\n\n    return styles;\n  }\n\n  /**\n   * Gets the view properties of the trigger and overlay, including whether they are clipped\n   * or completely outside the view of any of the strategy's scrollables.\n   */\n  private _getScrollVisibility(): ScrollingVisibility {\n    // Note: needs fresh rects since the position could've changed.\n    const originBounds = this._getOriginRect();\n    const overlayBounds = this._pane.getBoundingClientRect();\n\n    // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers\n    // every time, we should be able to use the scrollTop of the containers if the size of those\n    // containers hasn't changed.\n    const scrollContainerBounds = this._scrollables.map(scrollable => {\n      return scrollable.getElementRef().nativeElement.getBoundingClientRect();\n    });\n\n    return {\n      isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n      isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n      isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n      isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n    };\n  }\n\n  /** Subtracts the amount that an element is overflowing on an axis from its length. */\n  private _subtractOverflows(length: number, ...overflows: number[]): number {\n    return overflows.reduce((currentValue: number, currentOverflow: number) => {\n      return currentValue - Math.max(currentOverflow, 0);\n    }, length);\n  }\n\n  /** Narrows the given viewport rect by the current _viewportMargin. */\n  private _getNarrowedViewportRect(): Dimensions {\n    // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,\n    // because we want to use the `clientWidth` and `clientHeight` as the base. The difference\n    // being that the client properties don't include the scrollbar, as opposed to `innerWidth`\n    // and `innerHeight` that do. This is necessary, because the overlay container uses\n    // 100% `width` and `height` which don't include the scrollbar either.\n    const width = this._document.documentElement!.clientWidth;\n    const height = this._document.documentElement!.clientHeight;\n    const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n\n    return {\n      top: scrollPosition.top + this._viewportMargin,\n      left: scrollPosition.left + this._viewportMargin,\n      right: scrollPosition.left + width - this._viewportMargin,\n      bottom: scrollPosition.top + height - this._viewportMargin,\n      width: width - 2 * this._viewportMargin,\n      height: height - 2 * this._viewportMargin,\n    };\n  }\n\n  /** Whether the we're dealing with an RTL context */\n  private _isRtl() {\n    return this._overlayRef.getDirection() === 'rtl';\n  }\n\n  /** Determines whether the overlay uses exact or flexible positioning. */\n  private _hasExactPosition() {\n    return !this._hasFlexibleDimensions || this._isPushed;\n  }\n\n  /** Retrieves the offset of a position along the x or y axis. */\n  private _getOffset(position: ConnectedPosition, axis: 'x' | 'y') {\n    if (axis === 'x') {\n      // We don't do something like `position['offset' + axis]` in\n      // order to avoid breaking minifiers that rename properties.\n      return position.offsetX == null ? this._offsetX : position.offsetX;\n    }\n\n    return position.offsetY == null ? this._offsetY : position.offsetY;\n  }\n\n  /** Validates that the current position match the expected values. */\n  private _validatePositions(): void {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._preferredPositions.length) {\n        throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');\n      }\n\n      // TODO(crisbeto): remove these once Angular's template type\n      // checking is advanced enough to catch these cases.\n      this._preferredPositions.forEach(pair => {\n        validateHorizontalPosition('originX', pair.originX);\n        validateVerticalPosition('originY', pair.originY);\n        validateHorizontalPosition('overlayX', pair.overlayX);\n        validateVerticalPosition('overlayY', pair.overlayY);\n      });\n    }\n  }\n\n  /** Adds a single CSS class or an array of classes on the overlay panel. */\n  private _addPanelClasses(cssClasses: string | string[]) {\n    if (this._pane) {\n      coerceArray(cssClasses).forEach(cssClass => {\n        if (cssClass !== '' && this._appliedPanelClasses.indexOf(cssClass) === -1) {\n          this._appliedPanelClasses.push(cssClass);\n          this._pane.classList.add(cssClass);\n        }\n      });\n    }\n  }\n\n  /** Clears the classes that the position strategy has applied from the overlay panel. */\n  private _clearPanelClasses() {\n    if (this._pane) {\n      this._appliedPanelClasses.forEach(cssClass => {\n        this._pane.classList.remove(cssClass);\n      });\n      this._appliedPanelClasses = [];\n    }\n  }\n\n  /** Returns the ClientRect of the current origin. */\n  private _getOriginRect(): Dimensions {\n    const origin = this._origin;\n\n    if (origin instanceof ElementRef) {\n      return origin.nativeElement.getBoundingClientRect();\n    }\n\n    // Check for Element so SVG elements are also supported.\n    if (origin instanceof Element) {\n      return origin.getBoundingClientRect();\n    }\n\n    const width = origin.width || 0;\n    const height = origin.height || 0;\n\n    // If the origin is a point, return a client rect as if it was a 0x0 element at the point.\n    return {\n      top: origin.y,\n      bottom: origin.y + height,\n      left: origin.x,\n      right: origin.x + width,\n      height,\n      width,\n    };\n  }\n}\n\n/** A simple (x, y) coordinate. */\ninterface Point {\n  x: number;\n  y: number;\n}\n\n/** Record of measurements for how an overlay (at a given position) fits into the viewport. */\ninterface OverlayFit {\n  /** Whether the overlay fits completely in the viewport. */\n  isCompletelyWithinViewport: boolean;\n\n  /** Whether the overlay fits in the viewport on the y-axis. */\n  fitsInViewportVertically: boolean;\n\n  /** Whether the overlay fits in the viewport on the x-axis. */\n  fitsInViewportHorizontally: boolean;\n\n  /** The total visible area (in px^2) of the overlay inside the viewport. */\n  visibleArea: number;\n}\n\n/** Record of the measurements determining whether an overlay will fit in a specific position. */\ninterface FallbackPosition {\n  position: ConnectedPosition;\n  originPoint: Point;\n  overlayPoint: Point;\n  overlayFit: OverlayFit;\n  overlayRect: Dimensions;\n}\n\n/** Position and size of the overlay sizing wrapper for a specific position. */\ninterface BoundingBoxRect {\n  top: number;\n  left: number;\n  bottom: number;\n  right: number;\n  height: number;\n  width: number;\n}\n\n/** Record of measures determining how well a given position will fit with flexible dimensions. */\ninterface FlexibleFit {\n  position: ConnectedPosition;\n  origin: Point;\n  overlayRect: Dimensions;\n  boundingBoxRect: BoundingBoxRect;\n}\n\n/** A connected position as specified by the user. */\nexport interface ConnectedPosition {\n  originX: 'start' | 'center' | 'end';\n  originY: 'top' | 'center' | 'bottom';\n\n  overlayX: 'start' | 'center' | 'end';\n  overlayY: 'top' | 'center' | 'bottom';\n\n  weight?: number;\n  offsetX?: number;\n  offsetY?: number;\n  panelClass?: string | string[];\n}\n\n/** Shallow-extends a stylesheet object with another stylesheet object. */\nfunction extendStyles(\n  destination: CSSStyleDeclaration,\n  source: CSSStyleDeclaration,\n): CSSStyleDeclaration {\n  for (let key in source) {\n    if (source.hasOwnProperty(key)) {\n      destination[key] = source[key];\n    }\n  }\n\n  return destination;\n}\n\n/**\n * Extracts the pixel value as a number from a value, if it's a number\n * or a CSS pixel string (e.g. `1337px`). Otherwise returns null.\n */\nfunction getPixelValue(input: number | string | null | undefined): number | null {\n  if (typeof input !== 'number' && input != null) {\n    const [value, units] = input.split(cssUnitPattern);\n    return !units || units === 'px' ? parseFloat(value) : null;\n  }\n\n  return input || null;\n}\n\n/**\n * Gets a version of an element's bounding `ClientRect` where all the values are rounded down to\n * the nearest pixel. This allows us to account for the cases where there may be sub-pixel\n * deviations in the `ClientRect` returned by the browser (e.g. when zoomed in with a percentage\n * size, see #21350).\n */\nfunction getRoundedBoundingClientRect(clientRect: Dimensions): Dimensions {\n  return {\n    top: Math.floor(clientRect.top),\n    right: Math.floor(clientRect.right),\n    bottom: Math.floor(clientRect.bottom),\n    left: Math.floor(clientRect.left),\n    width: Math.floor(clientRect.width),\n    height: Math.floor(clientRect.height),\n  };\n}\n\nexport const STANDARD_DROPDOWN_BELOW_POSITIONS: ConnectedPosition[] = [\n  {originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top'},\n  {originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom'},\n  {originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top'},\n  {originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom'},\n];\n\nexport const STANDARD_DROPDOWN_ADJACENT_POSITIONS: ConnectedPosition[] = [\n  {originX: 'end', originY: 'top', overlayX: 'start', overlayY: 'top'},\n  {originX: 'end', originY: 'bottom', overlayX: 'start', overlayY: 'bottom'},\n  {originX: 'start', originY: 'top', overlayX: 'end', overlayY: 'top'},\n  {originX: 'start', originY: 'bottom', overlayX: 'end', overlayY: 'bottom'},\n];\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OverlayRef} from '../overlay-ref';\nimport {PositionStrategy} from './position-strategy';\n\n/** Class to be added to the overlay pane wrapper. */\nconst wrapperClass = 'cdk-global-overlay-wrapper';\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nexport class GlobalPositionStrategy implements PositionStrategy {\n  /** The overlay to which this strategy is attached. */\n  private _overlayRef: OverlayRef;\n  private _cssPosition = 'static';\n  private _topOffset = '';\n  private _bottomOffset = '';\n  private _alignItems = '';\n  private _xPosition = '';\n  private _xOffset = '';\n  private _width = '';\n  private _height = '';\n  private _isDisposed = false;\n\n  attach(overlayRef: OverlayRef): void {\n    const config = overlayRef.getConfig();\n\n    this._overlayRef = overlayRef;\n\n    if (this._width && !config.width) {\n      overlayRef.updateSize({width: this._width});\n    }\n\n    if (this._height && !config.height) {\n      overlayRef.updateSize({height: this._height});\n    }\n\n    overlayRef.hostElement.classList.add(wrapperClass);\n    this._isDisposed = false;\n  }\n\n  /**\n   * Sets the top position of the overlay. Clears any previously set vertical position.\n   * @param value New top offset.\n   */\n  top(value: string = ''): this {\n    this._bottomOffset = '';\n    this._topOffset = value;\n    this._alignItems = 'flex-start';\n    return this;\n  }\n\n  /**\n   * Sets the left position of the overlay. Clears any previously set horizontal position.\n   * @param value New left offset.\n   */\n  left(value: string = ''): this {\n    this._xOffset = value;\n    this._xPosition = 'left';\n    return this;\n  }\n\n  /**\n   * Sets the bottom position of the overlay. Clears any previously set vertical position.\n   * @param value New bottom offset.\n   */\n  bottom(value: string = ''): this {\n    this._topOffset = '';\n    this._bottomOffset = value;\n    this._alignItems = 'flex-end';\n    return this;\n  }\n\n  /**\n   * Sets the right position of the overlay. Clears any previously set horizontal position.\n   * @param value New right offset.\n   */\n  right(value: string = ''): this {\n    this._xOffset = value;\n    this._xPosition = 'right';\n    return this;\n  }\n\n  /**\n   * Sets the overlay to the start of the viewport, depending on the overlay direction.\n   * This will be to the left in LTR layouts and to the right in RTL.\n   * @param offset Offset from the edge of the screen.\n   */\n  start(value: string = ''): this {\n    this._xOffset = value;\n    this._xPosition = 'start';\n    return this;\n  }\n\n  /**\n   * Sets the overlay to the end of the viewport, depending on the overlay direction.\n   * This will be to the right in LTR layouts and to the left in RTL.\n   * @param offset Offset from the edge of the screen.\n   */\n  end(value: string = ''): this {\n    this._xOffset = value;\n    this._xPosition = 'end';\n    return this;\n  }\n\n  /**\n   * Sets the overlay width and clears any previously set width.\n   * @param value New width for the overlay\n   * @deprecated Pass the `width` through the `OverlayConfig`.\n   * @breaking-change 8.0.0\n   */\n  width(value: string = ''): this {\n    if (this._overlayRef) {\n      this._overlayRef.updateSize({width: value});\n    } else {\n      this._width = value;\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the overlay height and clears any previously set height.\n   * @param value New height for the overlay\n   * @deprecated Pass the `height` through the `OverlayConfig`.\n   * @breaking-change 8.0.0\n   */\n  height(value: string = ''): this {\n    if (this._overlayRef) {\n      this._overlayRef.updateSize({height: value});\n    } else {\n      this._height = value;\n    }\n\n    return this;\n  }\n\n  /**\n   * Centers the overlay horizontally with an optional offset.\n   * Clears any previously set horizontal position.\n   *\n   * @param offset Overlay offset from the horizontal center.\n   */\n  centerHorizontally(offset: string = ''): this {\n    this.left(offset);\n    this._xPosition = 'center';\n    return this;\n  }\n\n  /**\n   * Centers the overlay vertically with an optional offset.\n   * Clears any previously set vertical position.\n   *\n   * @param offset Overlay offset from the vertical center.\n   */\n  centerVertically(offset: string = ''): this {\n    this.top(offset);\n    this._alignItems = 'center';\n    return this;\n  }\n\n  /**\n   * Apply the position to the element.\n   * @docs-private\n   */\n  apply(): void {\n    // Since the overlay ref applies the strategy asynchronously, it could\n    // have been disposed before it ends up being applied. If that is the\n    // case, we shouldn't do anything.\n    if (!this._overlayRef || !this._overlayRef.hasAttached()) {\n      return;\n    }\n\n    const styles = this._overlayRef.overlayElement.style;\n    const parentStyles = this._overlayRef.hostElement.style;\n    const config = this._overlayRef.getConfig();\n    const {width, height, maxWidth, maxHeight} = config;\n    const shouldBeFlushHorizontally =\n      (width === '100%' || width === '100vw') &&\n      (!maxWidth || maxWidth === '100%' || maxWidth === '100vw');\n    const shouldBeFlushVertically =\n      (height === '100%' || height === '100vh') &&\n      (!maxHeight || maxHeight === '100%' || maxHeight === '100vh');\n    const xPosition = this._xPosition;\n    const xOffset = this._xOffset;\n    const isRtl = this._overlayRef.getConfig().direction === 'rtl';\n    let marginLeft = '';\n    let marginRight = '';\n    let justifyContent = '';\n\n    if (shouldBeFlushHorizontally) {\n      justifyContent = 'flex-start';\n    } else if (xPosition === 'center') {\n      justifyContent = 'center';\n\n      if (isRtl) {\n        marginRight = xOffset;\n      } else {\n        marginLeft = xOffset;\n      }\n    } else if (isRtl) {\n      if (xPosition === 'left' || xPosition === 'end') {\n        justifyContent = 'flex-end';\n        marginLeft = xOffset;\n      } else if (xPosition === 'right' || xPosition === 'start') {\n        justifyContent = 'flex-start';\n        marginRight = xOffset;\n      }\n    } else if (xPosition === 'left' || xPosition === 'start') {\n      justifyContent = 'flex-start';\n      marginLeft = xOffset;\n    } else if (xPosition === 'right' || xPosition === 'end') {\n      justifyContent = 'flex-end';\n      marginRight = xOffset;\n    }\n\n    styles.position = this._cssPosition;\n    styles.marginLeft = shouldBeFlushHorizontally ? '0' : marginLeft;\n    styles.marginTop = shouldBeFlushVertically ? '0' : this._topOffset;\n    styles.marginBottom = this._bottomOffset;\n    styles.marginRight = shouldBeFlushHorizontally ? '0' : marginRight;\n    parentStyles.justifyContent = justifyContent;\n    parentStyles.alignItems = shouldBeFlushVertically ? 'flex-start' : this._alignItems;\n  }\n\n  /**\n   * Cleans up the DOM changes from the position strategy.\n   * @docs-private\n   */\n  dispose(): void {\n    if (this._isDisposed || !this._overlayRef) {\n      return;\n    }\n\n    const styles = this._overlayRef.overlayElement.style;\n    const parent = this._overlayRef.hostElement;\n    const parentStyles = parent.style;\n\n    parent.classList.remove(wrapperClass);\n    parentStyles.justifyContent =\n      parentStyles.alignItems =\n      styles.marginTop =\n      styles.marginBottom =\n      styles.marginLeft =\n      styles.marginRight =\n      styles.position =\n        '';\n\n    this._overlayRef = null!;\n    this._isDisposed = true;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Platform} from '@angular/cdk/platform';\nimport {ViewportRuler} from '@angular/cdk/scrolling';\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable} from '@angular/core';\nimport {OverlayContainer} from '../overlay-container';\nimport {\n  FlexibleConnectedPositionStrategy,\n  FlexibleConnectedPositionStrategyOrigin,\n} from './flexible-connected-position-strategy';\nimport {GlobalPositionStrategy} from './global-position-strategy';\n\n/** Builder for overlay position strategy. */\n@Injectable({providedIn: 'root'})\nexport class OverlayPositionBuilder {\n  constructor(\n    private _viewportRuler: ViewportRuler,\n    @Inject(DOCUMENT) private _document: any,\n    private _platform: Platform,\n    private _overlayContainer: OverlayContainer,\n  ) {}\n\n  /**\n   * Creates a global position strategy.\n   */\n  global(): GlobalPositionStrategy {\n    return new GlobalPositionStrategy();\n  }\n\n  /**\n   * Creates a flexible position strategy.\n   * @param origin Origin relative to which to position the overlay.\n   */\n  flexibleConnectedTo(\n    origin: FlexibleConnectedPositionStrategyOrigin,\n  ): FlexibleConnectedPositionStrategy {\n    return new FlexibleConnectedPositionStrategy(\n      origin,\n      this._viewportRuler,\n      this._document,\n      this._platform,\n      this._overlayContainer,\n    );\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {DomPortalOutlet} from '@angular/cdk/portal';\nimport {DOCUMENT, Location} from '@angular/common';\nimport {\n  ApplicationRef,\n  ComponentFactoryResolver,\n  Inject,\n  Injectable,\n  Injector,\n  NgZone,\n  ANIMATION_MODULE_TYPE,\n  Optional,\n} from '@angular/core';\nimport {OverlayKeyboardDispatcher} from './dispatchers/overlay-keyboard-dispatcher';\nimport {OverlayOutsideClickDispatcher} from './dispatchers/overlay-outside-click-dispatcher';\nimport {OverlayConfig} from './overlay-config';\nimport {OverlayContainer} from './overlay-container';\nimport {OverlayRef} from './overlay-ref';\nimport {OverlayPositionBuilder} from './position/overlay-position-builder';\nimport {ScrollStrategyOptions} from './scroll/index';\n\n/** Next overlay unique ID. */\nlet nextUniqueId = 0;\n\n// Note that Overlay is *not* scoped to the app root because of the ComponentFactoryResolver\n// which needs to be different depending on where OverlayModule is imported.\n\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\n@Injectable({providedIn: 'root'})\nexport class Overlay {\n  private _appRef: ApplicationRef;\n\n  constructor(\n    /** Scrolling strategies that can be used when creating an overlay. */\n    public scrollStrategies: ScrollStrategyOptions,\n    private _overlayContainer: OverlayContainer,\n    private _componentFactoryResolver: ComponentFactoryResolver,\n    private _positionBuilder: OverlayPositionBuilder,\n    private _keyboardDispatcher: OverlayKeyboardDispatcher,\n    private _injector: Injector,\n    private _ngZone: NgZone,\n    @Inject(DOCUMENT) private _document: any,\n    private _directionality: Directionality,\n    private _location: Location,\n    private _outsideClickDispatcher: OverlayOutsideClickDispatcher,\n    @Inject(ANIMATION_MODULE_TYPE) @Optional() private _animationsModuleType?: string,\n  ) {}\n\n  /**\n   * Creates an overlay.\n   * @param config Configuration applied to the overlay.\n   * @returns Reference to the created overlay.\n   */\n  create(config?: OverlayConfig): OverlayRef {\n    const host = this._createHostElement();\n    const pane = this._createPaneElement(host);\n    const portalOutlet = this._createPortalOutlet(pane);\n    const overlayConfig = new OverlayConfig(config);\n\n    overlayConfig.direction = overlayConfig.direction || this._directionality.value;\n\n    return new OverlayRef(\n      portalOutlet,\n      host,\n      pane,\n      overlayConfig,\n      this._ngZone,\n      this._keyboardDispatcher,\n      this._document,\n      this._location,\n      this._outsideClickDispatcher,\n      this._animationsModuleType === 'NoopAnimations',\n    );\n  }\n\n  /**\n   * Gets a position builder that can be used, via fluent API,\n   * to construct and configure a position strategy.\n   * @returns An overlay position builder.\n   */\n  position(): OverlayPositionBuilder {\n    return this._positionBuilder;\n  }\n\n  /**\n   * Creates the DOM element for an overlay and appends it to the overlay container.\n   * @returns Newly-created pane element\n   */\n  private _createPaneElement(host: HTMLElement): HTMLElement {\n    const pane = this._document.createElement('div');\n\n    pane.id = `cdk-overlay-${nextUniqueId++}`;\n    pane.classList.add('cdk-overlay-pane');\n    host.appendChild(pane);\n\n    return pane;\n  }\n\n  /**\n   * Creates the host element that wraps around an overlay\n   * and can be used for advanced positioning.\n   * @returns Newly-create host element.\n   */\n  private _createHostElement(): HTMLElement {\n    const host = this._document.createElement('div');\n    this._overlayContainer.getContainerElement().appendChild(host);\n    return host;\n  }\n\n  /**\n   * Create a DomPortalOutlet into which the overlay content can be loaded.\n   * @param pane The DOM element to turn into a portal outlet.\n   * @returns A portal outlet for the given DOM element.\n   */\n  private _createPortalOutlet(pane: HTMLElement): DomPortalOutlet {\n    // We have to resolve the ApplicationRef later in order to allow people\n    // to use overlay-based providers during app initialization.\n    if (!this._appRef) {\n      this._appRef = this._injector.get<ApplicationRef>(ApplicationRef);\n    }\n\n    return new DomPortalOutlet(\n      pane,\n      this._componentFactoryResolver,\n      this._appRef,\n      this._injector,\n      this._document,\n    );\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Direction, Directionality} from '@angular/cdk/bidi';\nimport {ESCAPE, hasModifierKey} from '@angular/cdk/keycodes';\nimport {TemplatePortal} from '@angular/cdk/portal';\nimport {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  InjectionToken,\n  Input,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Output,\n  SimpleChanges,\n  TemplateRef,\n  ViewContainerRef,\n  booleanAttribute,\n} from '@angular/core';\nimport {Subscription} from 'rxjs';\nimport {takeWhile} from 'rxjs/operators';\nimport {Overlay} from './overlay';\nimport {OverlayConfig} from './overlay-config';\nimport {OverlayRef} from './overlay-ref';\nimport {ConnectedOverlayPositionChange} from './position/connected-position';\nimport {\n  ConnectedPosition,\n  FlexibleConnectedPositionStrategy,\n  FlexibleConnectedPositionStrategyOrigin,\n} from './position/flexible-connected-position-strategy';\nimport {RepositionScrollStrategy, ScrollStrategy} from './scroll/index';\n\n/** Default set of positions for the overlay. Follows the behavior of a dropdown. */\nconst defaultPositionList: ConnectedPosition[] = [\n  {\n    originX: 'start',\n    originY: 'bottom',\n    overlayX: 'start',\n    overlayY: 'top',\n  },\n  {\n    originX: 'start',\n    originY: 'top',\n    overlayX: 'start',\n    overlayY: 'bottom',\n  },\n  {\n    originX: 'end',\n    originY: 'top',\n    overlayX: 'end',\n    overlayY: 'bottom',\n  },\n  {\n    originX: 'end',\n    originY: 'bottom',\n    overlayX: 'end',\n    overlayY: 'top',\n  },\n];\n\n/** Injection token that determines the scroll handling while the connected overlay is open. */\nexport const CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'cdk-connected-overlay-scroll-strategy',\n);\n\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\n@Directive({\n  selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n  exportAs: 'cdkOverlayOrigin',\n  standalone: true,\n})\nexport class CdkOverlayOrigin {\n  constructor(\n    /** Reference to the element on which the directive is applied. */\n    public elementRef: ElementRef,\n  ) {}\n}\n\n/**\n * Directive to facilitate declarative creation of an\n * Overlay using a FlexibleConnectedPositionStrategy.\n */\n@Directive({\n  selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n  exportAs: 'cdkConnectedOverlay',\n  standalone: true,\n})\nexport class CdkConnectedOverlay implements OnDestroy, OnChanges {\n  private _overlayRef: OverlayRef;\n  private _templatePortal: TemplatePortal;\n  private _backdropSubscription = Subscription.EMPTY;\n  private _attachSubscription = Subscription.EMPTY;\n  private _detachSubscription = Subscription.EMPTY;\n  private _positionSubscription = Subscription.EMPTY;\n  private _offsetX: number;\n  private _offsetY: number;\n  private _position: FlexibleConnectedPositionStrategy;\n  private _scrollStrategyFactory: () => ScrollStrategy;\n  private _disposeOnNavigation = false;\n\n  /** Origin for the connected overlay. */\n  @Input('cdkConnectedOverlayOrigin')\n  origin: CdkOverlayOrigin | FlexibleConnectedPositionStrategyOrigin;\n\n  /** Registered connected position pairs. */\n  @Input('cdkConnectedOverlayPositions') positions: ConnectedPosition[];\n\n  /**\n   * This input overrides the positions input if specified. It lets users pass\n   * in arbitrary positioning strategies.\n   */\n  @Input('cdkConnectedOverlayPositionStrategy') positionStrategy: FlexibleConnectedPositionStrategy;\n\n  /** The offset in pixels for the overlay connection point on the x-axis */\n  @Input('cdkConnectedOverlayOffsetX')\n  get offsetX(): number {\n    return this._offsetX;\n  }\n  set offsetX(offsetX: number) {\n    this._offsetX = offsetX;\n\n    if (this._position) {\n      this._updatePositionStrategy(this._position);\n    }\n  }\n\n  /** The offset in pixels for the overlay connection point on the y-axis */\n  @Input('cdkConnectedOverlayOffsetY')\n  get offsetY() {\n    return this._offsetY;\n  }\n  set offsetY(offsetY: number) {\n    this._offsetY = offsetY;\n\n    if (this._position) {\n      this._updatePositionStrategy(this._position);\n    }\n  }\n\n  /** The width of the overlay panel. */\n  @Input('cdkConnectedOverlayWidth') width: number | string;\n\n  /** The height of the overlay panel. */\n  @Input('cdkConnectedOverlayHeight') height: number | string;\n\n  /** The min width of the overlay panel. */\n  @Input('cdkConnectedOverlayMinWidth') minWidth: number | string;\n\n  /** The min height of the overlay panel. */\n  @Input('cdkConnectedOverlayMinHeight') minHeight: number | string;\n\n  /** The custom class to be set on the backdrop element. */\n  @Input('cdkConnectedOverlayBackdropClass') backdropClass: string | string[];\n\n  /** The custom class to add to the overlay pane element. */\n  @Input('cdkConnectedOverlayPanelClass') panelClass: string | string[];\n\n  /** Margin between the overlay and the viewport edges. */\n  @Input('cdkConnectedOverlayViewportMargin') viewportMargin: number = 0;\n\n  /** Strategy to be used when handling scroll events while the overlay is open. */\n  @Input('cdkConnectedOverlayScrollStrategy') scrollStrategy: ScrollStrategy;\n\n  /** Whether the overlay is open. */\n  @Input('cdkConnectedOverlayOpen') open: boolean = false;\n\n  /** Whether the overlay can be closed by user interaction. */\n  @Input('cdkConnectedOverlayDisableClose') disableClose: boolean = false;\n\n  /** CSS selector which to set the transform origin. */\n  @Input('cdkConnectedOverlayTransformOriginOn') transformOriginSelector: string;\n\n  /** Whether or not the overlay should attach a backdrop. */\n  @Input({alias: 'cdkConnectedOverlayHasBackdrop', transform: booleanAttribute})\n  hasBackdrop: boolean = false;\n\n  /** Whether or not the overlay should be locked when scrolling. */\n  @Input({alias: 'cdkConnectedOverlayLockPosition', transform: booleanAttribute})\n  lockPosition: boolean = false;\n\n  /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n  @Input({alias: 'cdkConnectedOverlayFlexibleDimensions', transform: booleanAttribute})\n  flexibleDimensions: boolean = false;\n\n  /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */\n  @Input({alias: 'cdkConnectedOverlayGrowAfterOpen', transform: booleanAttribute})\n  growAfterOpen: boolean = false;\n\n  /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */\n  @Input({alias: 'cdkConnectedOverlayPush', transform: booleanAttribute}) push: boolean = false;\n\n  /** Whether the overlay should be disposed of when the user goes backwards/forwards in history. */\n  @Input({alias: 'cdkConnectedOverlayDisposeOnNavigation', transform: booleanAttribute})\n  get disposeOnNavigation(): boolean {\n    return this._disposeOnNavigation;\n  }\n  set disposeOnNavigation(value: boolean) {\n    this._disposeOnNavigation = value;\n  }\n\n  /** Event emitted when the backdrop is clicked. */\n  @Output() readonly backdropClick = new EventEmitter<MouseEvent>();\n\n  /** Event emitted when the position has changed. */\n  @Output() readonly positionChange = new EventEmitter<ConnectedOverlayPositionChange>();\n\n  /** Event emitted when the overlay has been attached. */\n  @Output() readonly attach = new EventEmitter<void>();\n\n  /** Event emitted when the overlay has been detached. */\n  @Output() readonly detach = new EventEmitter<void>();\n\n  /** Emits when there are keyboard events that are targeted at the overlay. */\n  @Output() readonly overlayKeydown = new EventEmitter<KeyboardEvent>();\n\n  /** Emits when there are mouse outside click events that are targeted at the overlay. */\n  @Output() readonly overlayOutsideClick = new EventEmitter<MouseEvent>();\n\n  // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n\n  constructor(\n    private _overlay: Overlay,\n    templateRef: TemplateRef<any>,\n    viewContainerRef: ViewContainerRef,\n    @Inject(CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY) scrollStrategyFactory: any,\n    @Optional() private _dir: Directionality,\n  ) {\n    this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n    this._scrollStrategyFactory = scrollStrategyFactory;\n    this.scrollStrategy = this._scrollStrategyFactory();\n  }\n\n  /** The associated overlay reference. */\n  get overlayRef(): OverlayRef {\n    return this._overlayRef;\n  }\n\n  /** The element's layout direction. */\n  get dir(): Direction {\n    return this._dir ? this._dir.value : 'ltr';\n  }\n\n  ngOnDestroy() {\n    this._attachSubscription.unsubscribe();\n    this._detachSubscription.unsubscribe();\n    this._backdropSubscription.unsubscribe();\n    this._positionSubscription.unsubscribe();\n\n    if (this._overlayRef) {\n      this._overlayRef.dispose();\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (this._position) {\n      this._updatePositionStrategy(this._position);\n      this._overlayRef.updateSize({\n        width: this.width,\n        minWidth: this.minWidth,\n        height: this.height,\n        minHeight: this.minHeight,\n      });\n\n      if (changes['origin'] && this.open) {\n        this._position.apply();\n      }\n    }\n\n    if (changes['open']) {\n      this.open ? this._attachOverlay() : this._detachOverlay();\n    }\n  }\n\n  /** Creates an overlay */\n  private _createOverlay() {\n    if (!this.positions || !this.positions.length) {\n      this.positions = defaultPositionList;\n    }\n\n    const overlayRef = (this._overlayRef = this._overlay.create(this._buildConfig()));\n    this._attachSubscription = overlayRef.attachments().subscribe(() => this.attach.emit());\n    this._detachSubscription = overlayRef.detachments().subscribe(() => this.detach.emit());\n    overlayRef.keydownEvents().subscribe((event: KeyboardEvent) => {\n      this.overlayKeydown.next(event);\n\n      if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {\n        event.preventDefault();\n        this._detachOverlay();\n      }\n    });\n\n    this._overlayRef.outsidePointerEvents().subscribe((event: MouseEvent) => {\n      this.overlayOutsideClick.next(event);\n    });\n  }\n\n  /** Builds the overlay config based on the directive's inputs */\n  private _buildConfig(): OverlayConfig {\n    const positionStrategy = (this._position =\n      this.positionStrategy || this._createPositionStrategy());\n    const overlayConfig = new OverlayConfig({\n      direction: this._dir,\n      positionStrategy,\n      scrollStrategy: this.scrollStrategy,\n      hasBackdrop: this.hasBackdrop,\n      disposeOnNavigation: this.disposeOnNavigation,\n    });\n\n    if (this.width || this.width === 0) {\n      overlayConfig.width = this.width;\n    }\n\n    if (this.height || this.height === 0) {\n      overlayConfig.height = this.height;\n    }\n\n    if (this.minWidth || this.minWidth === 0) {\n      overlayConfig.minWidth = this.minWidth;\n    }\n\n    if (this.minHeight || this.minHeight === 0) {\n      overlayConfig.minHeight = this.minHeight;\n    }\n\n    if (this.backdropClass) {\n      overlayConfig.backdropClass = this.backdropClass;\n    }\n\n    if (this.panelClass) {\n      overlayConfig.panelClass = this.panelClass;\n    }\n\n    return overlayConfig;\n  }\n\n  /** Updates the state of a position strategy, based on the values of the directive inputs. */\n  private _updatePositionStrategy(positionStrategy: FlexibleConnectedPositionStrategy) {\n    const positions: ConnectedPosition[] = this.positions.map(currentPosition => ({\n      originX: currentPosition.originX,\n      originY: currentPosition.originY,\n      overlayX: currentPosition.overlayX,\n      overlayY: currentPosition.overlayY,\n      offsetX: currentPosition.offsetX || this.offsetX,\n      offsetY: currentPosition.offsetY || this.offsetY,\n      panelClass: currentPosition.panelClass || undefined,\n    }));\n\n    return positionStrategy\n      .setOrigin(this._getFlexibleConnectedPositionStrategyOrigin())\n      .withPositions(positions)\n      .withFlexibleDimensions(this.flexibleDimensions)\n      .withPush(this.push)\n      .withGrowAfterOpen(this.growAfterOpen)\n      .withViewportMargin(this.viewportMargin)\n      .withLockedPosition(this.lockPosition)\n      .withTransformOriginOn(this.transformOriginSelector);\n  }\n\n  /** Returns the position strategy of the overlay to be set on the overlay config */\n  private _createPositionStrategy(): FlexibleConnectedPositionStrategy {\n    const strategy = this._overlay\n      .position()\n      .flexibleConnectedTo(this._getFlexibleConnectedPositionStrategyOrigin());\n    this._updatePositionStrategy(strategy);\n    return strategy;\n  }\n\n  private _getFlexibleConnectedPositionStrategyOrigin(): FlexibleConnectedPositionStrategyOrigin {\n    if (this.origin instanceof CdkOverlayOrigin) {\n      return this.origin.elementRef;\n    } else {\n      return this.origin;\n    }\n  }\n\n  /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */\n  private _attachOverlay() {\n    if (!this._overlayRef) {\n      this._createOverlay();\n    } else {\n      // Update the overlay size, in case the directive's inputs have changed\n      this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;\n    }\n\n    if (!this._overlayRef.hasAttached()) {\n      this._overlayRef.attach(this._templatePortal);\n    }\n\n    if (this.hasBackdrop) {\n      this._backdropSubscription = this._overlayRef.backdropClick().subscribe(event => {\n        this.backdropClick.emit(event);\n      });\n    } else {\n      this._backdropSubscription.unsubscribe();\n    }\n\n    this._positionSubscription.unsubscribe();\n\n    // Only subscribe to `positionChanges` if requested, because putting\n    // together all the information for it can be expensive.\n    if (this.positionChange.observers.length > 0) {\n      this._positionSubscription = this._position.positionChanges\n        .pipe(takeWhile(() => this.positionChange.observers.length > 0))\n        .subscribe(position => {\n          this.positionChange.emit(position);\n\n          if (this.positionChange.observers.length === 0) {\n            this._positionSubscription.unsubscribe();\n          }\n        });\n    }\n  }\n\n  /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */\n  private _detachOverlay() {\n    if (this._overlayRef) {\n      this._overlayRef.detach();\n    }\n\n    this._backdropSubscription.unsubscribe();\n    this._positionSubscription.unsubscribe();\n  }\n}\n\n/** @docs-private */\nexport function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(\n  overlay: Overlay,\n): () => RepositionScrollStrategy {\n  return () => overlay.scrollStrategies.reposition();\n}\n\n/** @docs-private */\nexport const CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n  provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BidiModule} from '@angular/cdk/bidi';\nimport {PortalModule} from '@angular/cdk/portal';\nimport {ScrollingModule} from '@angular/cdk/scrolling';\nimport {NgModule} from '@angular/core';\nimport {Overlay} from './overlay';\nimport {\n  CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n  CdkConnectedOverlay,\n  CdkOverlayOrigin,\n} from './overlay-directives';\n\n@NgModule({\n  imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],\n  exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule],\n  providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER],\n})\nexport class OverlayModule {}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, Inject, OnDestroy} from '@angular/core';\nimport {OverlayContainer} from './overlay-container';\nimport {DOCUMENT} from '@angular/common';\nimport {Platform} from '@angular/cdk/platform';\n\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\n@Injectable({providedIn: 'root'})\nexport class FullscreenOverlayContainer extends OverlayContainer implements OnDestroy {\n  private _fullScreenEventName: string | undefined;\n  private _fullScreenListener: () => void;\n\n  constructor(@Inject(DOCUMENT) _document: any, platform: Platform) {\n    super(_document, platform);\n  }\n\n  override ngOnDestroy() {\n    super.ngOnDestroy();\n\n    if (this._fullScreenEventName && this._fullScreenListener) {\n      this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);\n    }\n  }\n\n  protected override _createContainer(): void {\n    super._createContainer();\n    this._adjustParentForFullscreenChange();\n    this._addFullscreenChangeListener(() => this._adjustParentForFullscreenChange());\n  }\n\n  private _adjustParentForFullscreenChange(): void {\n    if (!this._containerElement) {\n      return;\n    }\n\n    const fullscreenElement = this.getFullscreenElement();\n    const parent = fullscreenElement || this._document.body;\n    parent.appendChild(this._containerElement);\n  }\n\n  private _addFullscreenChangeListener(fn: () => void) {\n    const eventName = this._getEventName();\n\n    if (eventName) {\n      if (this._fullScreenListener) {\n        this._document.removeEventListener(eventName, this._fullScreenListener);\n      }\n\n      this._document.addEventListener(eventName, fn);\n      this._fullScreenListener = fn;\n    }\n  }\n\n  private _getEventName(): string | undefined {\n    if (!this._fullScreenEventName) {\n      const _document = this._document as any;\n\n      if (_document.fullscreenEnabled) {\n        this._fullScreenEventName = 'fullscreenchange';\n      } else if (_document.webkitFullscreenEnabled) {\n        this._fullScreenEventName = 'webkitfullscreenchange';\n      } else if (_document.mozFullScreenEnabled) {\n        this._fullScreenEventName = 'mozfullscreenchange';\n      } else if (_document.msFullscreenEnabled) {\n        this._fullScreenEventName = 'MSFullscreenChange';\n      }\n    }\n\n    return this._fullScreenEventName;\n  }\n\n  /**\n   * When the page is put into fullscreen mode, a specific element is specified.\n   * Only that element and its children are visible when in fullscreen mode.\n   */\n  getFullscreenElement(): Element {\n    const _document = this._document as any;\n\n    return (\n      _document.fullscreenElement ||\n      _document.webkitFullscreenElement ||\n      _document.mozFullScreenElement ||\n      _document.msFullscreenElement ||\n      null\n    );\n  }\n}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {FocusMonitor, FocusOrigin} from '@angular/cdk/a11y';\nimport {Platform} from '@angular/cdk/platform';\nimport {\n  AfterViewInit,\n  booleanAttribute,\n  Directive,\n  ElementRef,\n  inject,\n  Input,\n  NgZone,\n  numberAttribute,\n  OnDestroy,\n  OnInit,\n} from '@angular/core';\nimport {MatRipple, MatRippleLoader} from '@angular/material/core';\n\n/** Shared host configuration for all buttons */\nexport const MAT_BUTTON_HOST = {\n  '[attr.disabled]': 'disabled || null',\n  '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n  // MDC automatically applies the primary theme color to the button, but we want to support\n  // an unthemed version. If color is undefined, apply a CSS class that makes it easy to\n  // select and style this \"theme\".\n  '[class.mat-unthemed]': '!color',\n  // Add a class that applies to all buttons. This makes it easier to target if somebody\n  // wants to target all Material buttons.\n  '[class.mat-mdc-button-base]': 'true',\n  '[class]': 'color ? \"mat-\" + color : \"\"',\n};\n\n/** List of classes to add to buttons instances based on host attribute selector. */\nconst HOST_SELECTOR_MDC_CLASS_PAIR: {attribute: string; mdcClasses: string[]}[] = [\n  {\n    attribute: 'mat-button',\n    mdcClasses: ['mdc-button', 'mat-mdc-button'],\n  },\n  {\n    attribute: 'mat-flat-button',\n    mdcClasses: ['mdc-button', 'mdc-button--unelevated', 'mat-mdc-unelevated-button'],\n  },\n  {\n    attribute: 'mat-raised-button',\n    mdcClasses: ['mdc-button', 'mdc-button--raised', 'mat-mdc-raised-button'],\n  },\n  {\n    attribute: 'mat-stroked-button',\n    mdcClasses: ['mdc-button', 'mdc-button--outlined', 'mat-mdc-outlined-button'],\n  },\n  {\n    attribute: 'mat-fab',\n    mdcClasses: ['mdc-fab', 'mat-mdc-fab'],\n  },\n  {\n    attribute: 'mat-mini-fab',\n    mdcClasses: ['mdc-fab', 'mdc-fab--mini', 'mat-mdc-mini-fab'],\n  },\n  {\n    attribute: 'mat-icon-button',\n    mdcClasses: ['mdc-icon-button', 'mat-mdc-icon-button'],\n  },\n];\n\n/** Base class for all buttons.  */\n@Directive()\nexport class MatButtonBase implements AfterViewInit, OnDestroy {\n  private readonly _focusMonitor = inject(FocusMonitor);\n\n  /**\n   * Handles the lazy creation of the MatButton ripple.\n   * Used to improve initial load time of large applications.\n   */\n  _rippleLoader: MatRippleLoader = inject(MatRippleLoader);\n\n  /** Whether this button is a FAB. Used to apply the correct class on the ripple. */\n  _isFab = false;\n\n  /**\n   * Reference to the MatRipple instance of the button.\n   * @deprecated Considered an implementation detail. To be removed.\n   * @breaking-change 17.0.0\n   */\n  get ripple(): MatRipple {\n    return this._rippleLoader?.getRipple(this._elementRef.nativeElement)!;\n  }\n  set ripple(v: MatRipple) {\n    this._rippleLoader?.attachRipple(this._elementRef.nativeElement, v);\n  }\n\n  /** Theme color palette of the button */\n  @Input() color?: string | null;\n\n  /** Whether the ripple effect is disabled or not. */\n  @Input({transform: booleanAttribute})\n  get disableRipple(): boolean {\n    return this._disableRipple;\n  }\n  set disableRipple(value: any) {\n    this._disableRipple = value;\n    this._updateRippleDisabled();\n  }\n  private _disableRipple: boolean = false;\n\n  @Input({transform: booleanAttribute})\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: any) {\n    this._disabled = value;\n    this._updateRippleDisabled();\n  }\n  private _disabled: boolean = false;\n\n  constructor(\n    public _elementRef: ElementRef,\n    public _platform: Platform,\n    public _ngZone: NgZone,\n    public _animationMode?: string,\n  ) {\n    this._rippleLoader?.configureRipple(this._elementRef.nativeElement, {\n      className: 'mat-mdc-button-ripple',\n    });\n\n    const element = this._elementRef.nativeElement;\n    const classList = (element as HTMLElement).classList;\n\n    // For each of the variant selectors that is present in the button's host\n    // attributes, add the correct corresponding MDC classes.\n    for (const {attribute, mdcClasses} of HOST_SELECTOR_MDC_CLASS_PAIR) {\n      if (element.hasAttribute(attribute)) {\n        classList.add(...mdcClasses);\n      }\n    }\n  }\n\n  ngAfterViewInit() {\n    this._focusMonitor.monitor(this._elementRef, true);\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n  }\n\n  /** Focuses the button. */\n  focus(_origin: FocusOrigin = 'program', options?: FocusOptions): void {\n    if (_origin) {\n      this._focusMonitor.focusVia(this._elementRef.nativeElement, _origin, options);\n    } else {\n      this._elementRef.nativeElement.focus(options);\n    }\n  }\n\n  private _updateRippleDisabled(): void {\n    this._rippleLoader?.setDisabled(\n      this._elementRef.nativeElement,\n      this.disableRipple || this.disabled,\n    );\n  }\n}\n\n/** Shared host configuration for buttons using the `<a>` tag. */\nexport const MAT_ANCHOR_HOST = {\n  '[attr.disabled]': 'disabled || null',\n  '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n\n  // Note that we ignore the user-specified tabindex when it's disabled for\n  // consistency with the `mat-button` applied on native buttons where even\n  // though they have an index, they're not tabbable.\n  '[attr.tabindex]': 'disabled ? -1 : tabIndex',\n  '[attr.aria-disabled]': 'disabled.toString()',\n  // MDC automatically applies the primary theme color to the button, but we want to support\n  // an unthemed version. If color is undefined, apply a CSS class that makes it easy to\n  // select and style this \"theme\".\n  '[class.mat-unthemed]': '!color',\n  // Add a class that applies to all buttons. This makes it easier to target if somebody\n  // wants to target all Material buttons.\n  '[class.mat-mdc-button-base]': 'true',\n  '[class]': 'color ? \"mat-\" + color : \"\"',\n};\n\n/**\n * Anchor button base.\n */\n@Directive()\nexport class MatAnchorBase extends MatButtonBase implements OnInit, OnDestroy {\n  @Input({\n    transform: (value: unknown) => {\n      return value == null ? undefined : numberAttribute(value);\n    },\n  })\n  tabIndex: number;\n\n  constructor(elementRef: ElementRef, platform: Platform, ngZone: NgZone, animationMode?: string) {\n    super(elementRef, platform, ngZone, animationMode);\n  }\n\n  ngOnInit(): void {\n    this._ngZone.runOutsideAngular(() => {\n      this._elementRef.nativeElement.addEventListener('click', this._haltDisabledEvents);\n    });\n  }\n\n  override ngOnDestroy(): void {\n    super.ngOnDestroy();\n    this._elementRef.nativeElement.removeEventListener('click', this._haltDisabledEvents);\n  }\n\n  _haltDisabledEvents = (event: Event): void => {\n    // A disabled button shouldn't apply any actions\n    if (this.disabled) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    }\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Platform} from '@angular/cdk/platform';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  Inject,\n  NgZone,\n  Optional,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\n\nimport {MAT_ANCHOR_HOST, MAT_BUTTON_HOST, MatAnchorBase, MatButtonBase} from './button-base';\n\n/**\n * Material Design button component. Users interact with a button to perform an action.\n * See https://material.io/components/buttons\n *\n * The `MatButton` class applies to native button elements and captures the appearances for\n * \"text button\", \"outlined button\", and \"contained button\" per the Material Design\n * specification. `MatButton` additionally captures an additional \"flat\" appearance, which matches\n * \"contained\" but without elevation.\n */\n@Component({\n  selector: `\n    button[mat-button], button[mat-raised-button], button[mat-flat-button],\n    button[mat-stroked-button]\n  `,\n  templateUrl: 'button.html',\n  styleUrls: ['button.css', 'button-high-contrast.css'],\n  host: MAT_BUTTON_HOST,\n  exportAs: 'matButton',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatButton extends MatButtonBase {\n  constructor(\n    elementRef: ElementRef,\n    platform: Platform,\n    ngZone: NgZone,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n  ) {\n    super(elementRef, platform, ngZone, animationMode);\n  }\n}\n\n/**\n * Material Design button component for anchor elements. Anchor elements are used to provide\n * links for the user to navigate across different routes or pages.\n * See https://material.io/components/buttons\n *\n * The `MatAnchor` class applies to native anchor elements and captures the appearances for\n * \"text button\", \"outlined button\", and \"contained button\" per the Material Design\n * specification. `MatAnchor` additionally captures an additional \"flat\" appearance, which matches\n * \"contained\" but without elevation.\n */\n@Component({\n  selector: `a[mat-button], a[mat-raised-button], a[mat-flat-button], a[mat-stroked-button]`,\n  exportAs: 'matButton, matAnchor',\n  host: MAT_ANCHOR_HOST,\n  templateUrl: 'button.html',\n  styleUrls: ['button.css', 'button-high-contrast.css'],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatAnchor extends MatAnchorBase {\n  constructor(\n    elementRef: ElementRef,\n    platform: Platform,\n    ngZone: NgZone,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n  ) {\n    super(elementRef, platform, ngZone, animationMode);\n  }\n}\n", "<span\n    class=\"mat-mdc-button-persistent-ripple\"\n    [class.mdc-button__ripple]=\"!_isFab\"\n    [class.mdc-fab__ripple]=\"_isFab\"></span>\n\n<ng-content select=\".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])\">\n</ng-content>\n\n<span class=\"mdc-button__label\"><ng-content></ng-content></span>\n\n<ng-content select=\".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]\">\n</ng-content>\n\n<!--\n  The indicator can't be directly on the button, because MDC uses ::before for high contrast\n  indication and it can't be on the ripple, because it has a border radius and overflow: hidden.\n-->\n<span class=\"mat-mdc-focus-indicator\"></span>\n\n<span class=\"mat-mdc-button-touch-target\"></span>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Platform} from '@angular/cdk/platform';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  Inject,\n  InjectionToken,\n  Input,\n  NgZone,\n  Optional,\n  ViewEncapsulation,\n  booleanAttribute,\n} from '@angular/core';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\n\nimport {MatAnchor} from './button';\nimport {MAT_ANCHOR_HOST, MAT_BUTTON_HOST, MatButtonBase} from './button-base';\nimport {ThemePalette} from '@angular/material/core';\n\n/** Default FAB options that can be overridden. */\nexport interface MatFabDefaultOptions {\n  color?: ThemePalette;\n}\n\n/** Injection token to be used to override the default options for FAB. */\nexport const MAT_FAB_DEFAULT_OPTIONS = new InjectionToken<MatFabDefaultOptions>(\n  'mat-mdc-fab-default-options',\n  {\n    providedIn: 'root',\n    factory: MAT_FAB_DEFAULT_OPTIONS_FACTORY,\n  },\n);\n\n/** @docs-private */\nexport function MAT_FAB_DEFAULT_OPTIONS_FACTORY(): MatFabDefaultOptions {\n  return {\n    // The FAB by default has its color set to accent.\n    color: 'accent',\n  };\n}\n\n// Default FAB configuration.\nconst defaults = MAT_FAB_DEFAULT_OPTIONS_FACTORY();\n\n/**\n * Material Design floating action button (FAB) component. These buttons represent the primary\n * or most common action for users to interact with.\n * See https://material.io/components/buttons-floating-action-button/\n *\n * The `MatFabButton` class has two appearances: normal and extended.\n */\n@Component({\n  selector: `button[mat-fab]`,\n  templateUrl: 'button.html',\n  styleUrls: ['fab.css'],\n  host: {\n    ...MAT_BUTTON_HOST,\n    '[class.mdc-fab--extended]': 'extended',\n    '[class.mat-mdc-extended-fab]': 'extended',\n  },\n  exportAs: 'matButton',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatFabButton extends MatButtonBase {\n  override _isFab = true;\n\n  @Input({transform: booleanAttribute}) extended: boolean;\n\n  constructor(\n    elementRef: ElementRef,\n    platform: Platform,\n    ngZone: NgZone,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n    @Optional() @Inject(MAT_FAB_DEFAULT_OPTIONS) private _options?: MatFabDefaultOptions,\n  ) {\n    super(elementRef, platform, ngZone, animationMode);\n    this._options = this._options || defaults;\n    this.color = this._options!.color || defaults.color;\n  }\n}\n\n/**\n * Material Design mini floating action button (FAB) component. These buttons represent the primary\n * or most common action for users to interact with.\n * See https://material.io/components/buttons-floating-action-button/\n */\n@Component({\n  selector: `button[mat-mini-fab]`,\n  templateUrl: 'button.html',\n  styleUrls: ['fab.css'],\n  host: MAT_BUTTON_HOST,\n  exportAs: 'matButton',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatMiniFabButton extends MatButtonBase {\n  override _isFab = true;\n\n  constructor(\n    elementRef: ElementRef,\n    platform: Platform,\n    ngZone: NgZone,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n    @Optional() @Inject(MAT_FAB_DEFAULT_OPTIONS) private _options?: MatFabDefaultOptions,\n  ) {\n    super(elementRef, platform, ngZone, animationMode);\n    this._options = this._options || defaults;\n    this.color = this._options!.color || defaults.color;\n  }\n}\n\n/**\n * Material Design floating action button (FAB) component for anchor elements. Anchor elements\n * are used to provide links for the user to navigate across different routes or pages.\n * See https://material.io/components/buttons-floating-action-button/\n *\n * The `MatFabAnchor` class has two appearances: normal and extended.\n */\n@Component({\n  selector: `a[mat-fab]`,\n  templateUrl: 'button.html',\n  styleUrls: ['fab.css'],\n  host: {\n    ...MAT_ANCHOR_HOST,\n    '[class.mdc-fab--extended]': 'extended',\n    '[class.mat-mdc-extended-fab]': 'extended',\n  },\n  exportAs: 'matButton, matAnchor',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatFabAnchor extends MatAnchor {\n  override _isFab = true;\n\n  @Input({transform: booleanAttribute}) extended: boolean;\n\n  constructor(\n    elementRef: ElementRef,\n    platform: Platform,\n    ngZone: NgZone,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n    @Optional() @Inject(MAT_FAB_DEFAULT_OPTIONS) private _options?: MatFabDefaultOptions,\n  ) {\n    super(elementRef, platform, ngZone, animationMode);\n    this._options = this._options || defaults;\n    this.color = this._options!.color || defaults.color;\n  }\n}\n\n/**\n * Material Design mini floating action button (FAB) component for anchor elements. Anchor elements\n * are used to provide links for the user to navigate across different routes or pages.\n * See https://material.io/components/buttons-floating-action-button/\n */\n@Component({\n  selector: `a[mat-mini-fab]`,\n  templateUrl: 'button.html',\n  styleUrls: ['fab.css'],\n  host: MAT_ANCHOR_HOST,\n  exportAs: 'matButton, matAnchor',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatMiniFabAnchor extends MatAnchor {\n  override _isFab = true;\n\n  constructor(\n    elementRef: ElementRef,\n    platform: Platform,\n    ngZone: NgZone,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n    @Optional() @Inject(MAT_FAB_DEFAULT_OPTIONS) private _options?: MatFabDefaultOptions,\n  ) {\n    super(elementRef, platform, ngZone, animationMode);\n    this._options = this._options || defaults;\n    this.color = this._options!.color || defaults.color;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Platform} from '@angular/cdk/platform';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  Inject,\n  NgZone,\n  Optional,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\nimport {MAT_ANCHOR_HOST, MAT_BUTTON_HOST, MatAnchorBase, MatButtonBase} from './button-base';\n\n/**\n * Material Design icon button component. This type of button displays a single interactive icon for\n * users to perform an action.\n * See https://material.io/develop/web/components/buttons/icon-buttons/\n */\n@Component({\n  selector: `button[mat-icon-button]`,\n  templateUrl: 'icon-button.html',\n  styleUrls: ['icon-button.css', 'button-high-contrast.css'],\n  host: MAT_BUTTON_HOST,\n  exportAs: 'matButton',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatIconButton extends MatButtonBase {\n  constructor(\n    elementRef: ElementRef,\n    platform: Platform,\n    ngZone: NgZone,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n  ) {\n    super(elementRef, platform, ngZone, animationMode);\n\n    this._rippleLoader.configureRipple(this._elementRef.nativeElement, {centered: true});\n  }\n}\n\n/**\n * Material Design icon button component for anchor elements. This button displays a single\n * interaction icon that allows users to navigate across different routes or pages.\n * See https://material.io/develop/web/components/buttons/icon-buttons/\n */\n@Component({\n  selector: `a[mat-icon-button]`,\n  templateUrl: 'button.html',\n  styleUrls: ['icon-button.css', 'button-high-contrast.css'],\n  host: MAT_ANCHOR_HOST,\n  exportAs: 'matButton, matAnchor',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatIconAnchor extends MatAnchorBase {\n  constructor(\n    elementRef: ElementRef,\n    platform: Platform,\n    ngZone: NgZone,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n  ) {\n    super(elementRef, platform, ngZone, animationMode);\n  }\n}\n", "<span class=\"mat-mdc-button-persistent-ripple mdc-icon-button__ripple\"></span>\n\n<ng-content></ng-content>\n\n<!--\n  The indicator can't be directly on the button, because MDC uses ::before for high contrast\n  indication and it can't be on the ripple, because it has a border radius and overflow: hidden.\n-->\n<span class=\"mat-mdc-focus-indicator\"></span>\n\n<span class=\"mat-mdc-button-touch-target\"></span>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatRippleModule} from '@angular/material/core';\nimport {MatAnchor, MatButton} from './button';\nimport {MatFabAnchor, MatFabButton, MatMiniFabAnchor, MatMiniFabButton} from './fab';\nimport {MatIconAnchor, MatIconButton} from './icon-button';\n\n@NgModule({\n  imports: [MatCommonModule, MatRippleModule],\n  exports: [\n    MatAnchor,\n    MatButton,\n    MatIconAnchor,\n    MatIconButton,\n    MatMiniFabAnchor,\n    MatMiniFabButton,\n    MatFabAnchor,\n    MatFabButton,\n    MatCommonModule,\n  ],\n  declarations: [\n    MatAnchor,\n    MatButton,\n    MatIconAnchor,\n    MatMiniFabAnchor,\n    MatMiniFabButton,\n    MatIconButton,\n    MatFabAnchor,\n    MatFabButton,\n  ],\n})\nexport class MatButtonModule {}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, InjectionToken, Renderer2} from '@angular/core';\n\n/**\n * @description\n * Defines an interface that acts as a bridge between the Angular forms API and a\n * native element in the DOM.\n *\n * Implement this interface to create a custom form control directive\n * that integrates with Angular forms.\n *\n * @see {@link DefaultValueAccessor}\n *\n * @publicApi\n */\nexport interface ControlValueAccessor {\n  /**\n   * @description\n   * Writes a new value to the element.\n   *\n   * This method is called by the forms API to write to the view when programmatic\n   * changes from model to view are requested.\n   *\n   * @usageNotes\n   * ### Write a value to the element\n   *\n   * The following example writes a value to the native DOM element.\n   *\n   * ```ts\n   * writeValue(value: any): void {\n   *   this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);\n   * }\n   * ```\n   *\n   * @param obj The new value for the element\n   */\n  writeValue(obj: any): void;\n\n  /**\n   * @description\n   * Registers a callback function that is called when the control's value\n   * changes in the UI.\n   *\n   * This method is called by the forms API on initialization to update the form\n   * model when values propagate from the view to the model.\n   *\n   * When implementing the `registerOnChange` method in your own value accessor,\n   * save the given function so your class calls it at the appropriate time.\n   *\n   * @usageNotes\n   * ### Store the change function\n   *\n   * The following example stores the provided function as an internal method.\n   *\n   * ```ts\n   * registerOnChange(fn: (_: any) => void): void {\n   *   this._onChange = fn;\n   * }\n   * ```\n   *\n   * When the value changes in the UI, call the registered\n   * function to allow the forms API to update itself:\n   *\n   * ```ts\n   * host: {\n   *    '(change)': '_onChange($event.target.value)'\n   * }\n   * ```\n   *\n   * @param fn The callback function to register\n   */\n  registerOnChange(fn: any): void;\n\n  /**\n   * @description\n   * Registers a callback function that is called by the forms API on initialization\n   * to update the form model on blur.\n   *\n   * When implementing `registerOnTouched` in your own value accessor, save the given\n   * function so your class calls it when the control should be considered\n   * blurred or \"touched\".\n   *\n   * @usageNotes\n   * ### Store the callback function\n   *\n   * The following example stores the provided function as an internal method.\n   *\n   * ```ts\n   * registerOnTouched(fn: any): void {\n   *   this._onTouched = fn;\n   * }\n   * ```\n   *\n   * On blur (or equivalent), your class should call the registered function to allow\n   * the forms API to update itself:\n   *\n   * ```ts\n   * host: {\n   *    '(blur)': '_onTouched()'\n   * }\n   * ```\n   *\n   * @param fn The callback function to register\n   */\n  registerOnTouched(fn: any): void;\n\n  /**\n   * @description\n   * Function that is called by the forms API when the control status changes to\n   * or from 'DISABLED'. Depending on the status, it enables or disables the\n   * appropriate DOM element.\n   *\n   * @usageNotes\n   * The following is an example of writing the disabled property to a native DOM element:\n   *\n   * ```ts\n   * setDisabledState(isDisabled: boolean): void {\n   *   this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n   * }\n   * ```\n   *\n   * @param isDisabled The disabled status to set on the element\n   */\n  setDisabledState?(isDisabled: boolean): void;\n}\n\n/**\n * Base class for all ControlValueAccessor classes defined in Forms package.\n * Contains common logic and utility functions.\n *\n * Note: this is an *internal-only* class and should not be extended or used directly in\n * applications code.\n */\n@Directive()\nexport class BaseControlValueAccessor {\n  /**\n   * The registered callback function called when a change or input event occurs on the input\n   * element.\n   * @nodoc\n   */\n  onChange = (_: any) => {};\n\n  /**\n   * The registered callback function called when a blur event occurs on the input element.\n   * @nodoc\n   */\n  onTouched = () => {};\n\n  constructor(private _renderer: Renderer2, private _elementRef: ElementRef) {}\n\n  /**\n   * Helper method that sets a property on a target element using the current Renderer\n   * implementation.\n   * @nodoc\n   */\n  protected setProperty(key: string, value: any): void {\n    this._renderer.setProperty(this._elementRef.nativeElement, key, value);\n  }\n\n  /**\n   * Registers a function called when the control is touched.\n   * @nodoc\n   */\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  /**\n   * Registers a function called when the control value changes.\n   * @nodoc\n   */\n  registerOnChange(fn: (_: any) => {}): void {\n    this.onChange = fn;\n  }\n\n  /**\n   * Sets the \"disabled\" property on the range input element.\n   * @nodoc\n   */\n  setDisabledState(isDisabled: boolean): void {\n    this.setProperty('disabled', isDisabled);\n  }\n}\n\n/**\n * Base class for all built-in ControlValueAccessor classes (except DefaultValueAccessor, which is\n * used in case no other CVAs can be found). We use this class to distinguish between default CVA,\n * built-in CVAs and custom CVAs, so that Forms logic can recognize built-in CVAs and treat custom\n * ones with higher priority (when both built-in and custom CVAs are present).\n *\n * Note: this is an *internal-only* class and should not be extended or used directly in\n * applications code.\n */\n@Directive()\nexport class BuiltInControlValueAccessor extends BaseControlValueAccessor {\n}\n\n/**\n * Used to provide a `ControlValueAccessor` for form controls.\n *\n * See `DefaultValueAccessor` for how to implement one.\n *\n * @publicApi\n */\nexport const NG_VALUE_ACCESSOR =\n    new InjectionToken<ReadonlyArray<ControlValueAccessor>>('NgValueAccessor');\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, forwardRef, Provider} from '@angular/core';\n\nimport {BuiltInControlValueAccessor, ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\n\nconst CHECKBOX_VALUE_ACCESSOR: Provider = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => CheckboxControlValueAccessor),\n  multi: true,\n};\n\n/**\n * @description\n * A `ControlValueAccessor` for writing a value and listening to changes on a checkbox input\n * element.\n *\n * @usageNotes\n *\n * ### Using a checkbox with a reactive form.\n *\n * The following example shows how to use a checkbox with a reactive form.\n *\n * ```ts\n * const rememberLoginControl = new FormControl();\n * ```\n *\n * ```\n * <input type=\"checkbox\" [formControl]=\"rememberLoginControl\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector:\n      'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',\n  host: {'(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()'},\n  providers: [CHECKBOX_VALUE_ACCESSOR]\n})\nexport class CheckboxControlValueAccessor extends BuiltInControlValueAccessor implements\n    ControlValueAccessor {\n  /**\n   * Sets the \"checked\" property on the input element.\n   * @nodoc\n   */\n  writeValue(value: any): void {\n    this.setProperty('checked', value);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getDOM as getDOM} from '@angular/common';\nimport {Directive, ElementRef, forwardRef, Inject, InjectionToken, Optional, Renderer2} from '@angular/core';\n\nimport {BaseControlValueAccessor, ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\n\nexport const DEFAULT_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => DefaultValueAccessor),\n  multi: true\n};\n\n/**\n * We must check whether the agent is Android because composition events\n * behave differently between iOS and Android.\n */\nfunction _isAndroid(): boolean {\n  const userAgent = getDOM() ? getDOM().getUserAgent() : '';\n  return /android (\\d+)/.test(userAgent.toLowerCase());\n}\n\n/**\n * @description\n * Provide this token to control if form directives buffer IME input until\n * the \"compositionend\" event occurs.\n * @publicApi\n */\nexport const COMPOSITION_BUFFER_MODE = new InjectionToken<boolean>('CompositionEventMode');\n\n/**\n * The default `ControlValueAccessor` for writing a value and listening to changes on input\n * elements. The accessor is used by the `FormControlDirective`, `FormControlName`, and\n * `NgModel` directives.\n *\n * {@searchKeywords ngDefaultControl}\n *\n * @usageNotes\n *\n * ### Using the default value accessor\n *\n * The following example shows how to use an input element that activates the default value accessor\n * (in this case, a text field).\n *\n * ```ts\n * const firstNameControl = new FormControl();\n * ```\n *\n * ```\n * <input type=\"text\" [formControl]=\"firstNameControl\">\n * ```\n *\n * This value accessor is used by default for `<input type=\"text\">` and `<textarea>` elements, but\n * you could also use it for custom components that have similar behavior and do not require special\n * processing. In order to attach the default value accessor to a custom element, add the\n * `ngDefaultControl` attribute as shown below.\n *\n * ```\n * <custom-input-component ngDefaultControl [(ngModel)]=\"value\"></custom-input-component>\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector:\n      'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',\n  // TODO: vsavkin replace the above selector with the one below it once\n  // https://github.com/angular/angular/issues/3011 is implemented\n  // selector: '[ngModel],[formControl],[formControlName]',\n  host: {\n    '(input)': '$any(this)._handleInput($event.target.value)',\n    '(blur)': 'onTouched()',\n    '(compositionstart)': '$any(this)._compositionStart()',\n    '(compositionend)': '$any(this)._compositionEnd($event.target.value)'\n  },\n  providers: [DEFAULT_VALUE_ACCESSOR]\n})\nexport class DefaultValueAccessor extends BaseControlValueAccessor implements ControlValueAccessor {\n  /** Whether the user is creating a composition string (IME events). */\n  private _composing = false;\n\n  constructor(\n      renderer: Renderer2, elementRef: ElementRef,\n      @Optional() @Inject(COMPOSITION_BUFFER_MODE) private _compositionMode: boolean) {\n    super(renderer, elementRef);\n    if (this._compositionMode == null) {\n      this._compositionMode = !_isAndroid();\n    }\n  }\n\n  /**\n   * Sets the \"value\" property on the input element.\n   * @nodoc\n   */\n  writeValue(value: any): void {\n    const normalizedValue = value == null ? '' : value;\n    this.setProperty('value', normalizedValue);\n  }\n\n  /** @internal */\n  _handleInput(value: any): void {\n    if (!this._compositionMode || (this._compositionMode && !this._composing)) {\n      this.onChange(value);\n    }\n  }\n\n  /** @internal */\n  _compositionStart(): void {\n    this._composing = true;\n  }\n\n  /** @internal */\n  _compositionEnd(value: any): void {\n    this._composing = false;\n    this._compositionMode && this.onChange(value);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken, isPromise as isPromise, isSubscribable as isSubscribable, RuntimeError as RuntimeError} from '@angular/core';\nimport {forkJoin, from, Observable} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {AsyncValidator, AsyncValidatorFn, ValidationErrors, Validator, ValidatorFn} from './directives/validators';\nimport {RuntimeErrorCode} from './errors';\nimport {AbstractControl} from './model/abstract_model';\n\n\nfunction isEmptyInputValue(value: any): boolean {\n  /**\n   * Check if the object is a string or array before evaluating the length attribute.\n   * This avoids falsely rejecting objects that contain a custom length attribute.\n   * For example, the object {id: 1, length: 0, width: 0} should not be returned as empty.\n   */\n  return value == null ||\n      ((typeof value === 'string' || Array.isArray(value)) && value.length === 0);\n}\n\nfunction hasValidLength(value: any): boolean {\n  // non-strict comparison is intentional, to check for both `null` and `undefined` values\n  return value != null && typeof value.length === 'number';\n}\n\n/**\n * @description\n * An `InjectionToken` for registering additional synchronous validators used with\n * `AbstractControl`s.\n *\n * @see {@link NG_ASYNC_VALIDATORS}\n *\n * @usageNotes\n *\n * ### Providing a custom validator\n *\n * The following example registers a custom validator directive. Adding the validator to the\n * existing collection of validators requires the `multi: true` option.\n *\n * ```typescript\n * @Directive({\n *   selector: '[customValidator]',\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\n * })\n * class CustomValidatorDirective implements Validator {\n *   validate(control: AbstractControl): ValidationErrors | null {\n *     return { 'custom': true };\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport const NG_VALIDATORS = new InjectionToken<ReadonlyArray<Validator|Function>>('NgValidators');\n\n/**\n * @description\n * An `InjectionToken` for registering additional asynchronous validators used with\n * `AbstractControl`s.\n *\n * @see {@link NG_VALIDATORS}\n *\n * @usageNotes\n *\n * ### Provide a custom async validator directive\n *\n * The following example implements the `AsyncValidator` interface to create an\n * async validator directive with a custom error key.\n *\n * ```typescript\n * @Directive({\n *   selector: '[customAsyncValidator]',\n *   providers: [{provide: NG_ASYNC_VALIDATORS, useExisting: CustomAsyncValidatorDirective, multi:\n * true}]\n * })\n * class CustomAsyncValidatorDirective implements AsyncValidator {\n *   validate(control: AbstractControl): Promise<ValidationErrors|null> {\n *     return Promise.resolve({'custom': true});\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport const NG_ASYNC_VALIDATORS =\n    new InjectionToken<ReadonlyArray<Validator|Function>>('NgAsyncValidators');\n\n/**\n * A regular expression that matches valid e-mail addresses.\n *\n * At a high level, this regexp matches e-mail addresses of the format `local-part@tld`, where:\n * - `local-part` consists of one or more of the allowed characters (alphanumeric and some\n *   punctuation symbols).\n * - `local-part` cannot begin or end with a period (`.`).\n * - `local-part` cannot be longer than 64 characters.\n * - `tld` consists of one or more `labels` separated by periods (`.`). For example `localhost` or\n *   `foo.com`.\n * - A `label` consists of one or more of the allowed characters (alphanumeric, dashes (`-`) and\n *   periods (`.`)).\n * - A `label` cannot begin or end with a dash (`-`) or a period (`.`).\n * - A `label` cannot be longer than 63 characters.\n * - The whole address cannot be longer than 254 characters.\n *\n * ## Implementation background\n *\n * This regexp was ported over from AngularJS (see there for git history):\n * https://github.com/angular/angular.js/blob/c133ef836/src/ng/directive/input.js#L27\n * It is based on the\n * [WHATWG version](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n * lengths of different parts of the address). The main differences from the WHATWG version are:\n *   - Disallow `local-part` to begin or end with a period (`.`).\n *   - Disallow `local-part` length to exceed 64 characters.\n *   - Disallow total address length to exceed 254 characters.\n *\n * See [this commit](https://github.com/angular/angular.js/commit/f3f5cf72e) for more details.\n */\nconst EMAIL_REGEXP =\n    /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n\n/**\n * @description\n * Provides a set of built-in validators that can be used by form controls.\n *\n * A validator is a function that processes a `FormControl` or collection of\n * controls and returns an error map or null. A null map means that validation has passed.\n *\n * @see [Form Validation](/guide/form-validation)\n *\n * @publicApi\n */\nexport class Validators {\n  /**\n   * @description\n   * Validator that requires the control's value to be greater than or equal to the provided number.\n   *\n   * @usageNotes\n   *\n   * ### Validate against a minimum of 3\n   *\n   * ```typescript\n   * const control = new FormControl(2, Validators.min(3));\n   *\n   * console.log(control.errors); // {min: {min: 3, actual: 2}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `min` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link updateValueAndValidity()}\n   *\n   */\n  static min(min: number): ValidatorFn {\n    return minValidator(min);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value to be less than or equal to the provided number.\n   *\n   * @usageNotes\n   *\n   * ### Validate against a maximum of 15\n   *\n   * ```typescript\n   * const control = new FormControl(16, Validators.max(15));\n   *\n   * console.log(control.errors); // {max: {max: 15, actual: 16}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `max` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link updateValueAndValidity()}\n   *\n   */\n  static max(max: number): ValidatorFn {\n    return maxValidator(max);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control have a non-empty value.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field is non-empty\n   *\n   * ```typescript\n   * const control = new FormControl('', Validators.required);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map with the `required` property\n   * if the validation check fails, otherwise `null`.\n   *\n   * @see {@link updateValueAndValidity()}\n   *\n   */\n  static required(control: AbstractControl): ValidationErrors|null {\n    return requiredValidator(control);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value be true. This validator is commonly\n   * used for required checkboxes.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field value is true\n   *\n   * ```typescript\n   * const control = new FormControl('some value', Validators.requiredTrue);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map that contains the `required` property\n   * set to `true` if the validation check fails, otherwise `null`.\n   *\n   * @see {@link updateValueAndValidity()}\n   *\n   */\n  static requiredTrue(control: AbstractControl): ValidationErrors|null {\n    return requiredTrueValidator(control);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value pass an email validation test.\n   *\n   * Tests the value using a [regular\n   * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)\n   * pattern suitable for common use cases. The pattern is based on the definition of a valid email\n   * address in the [WHATWG HTML\n   * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n   * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n   * lengths of different parts of the address).\n   *\n   * The differences from the WHATWG version include:\n   * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).\n   * - Disallow `local-part` to be longer than 64 characters.\n   * - Disallow the whole address to be longer than 254 characters.\n   *\n   * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to\n   * validate the value against a different pattern.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field matches a valid email pattern\n   *\n   * ```typescript\n   * const control = new FormControl('bad@', Validators.email);\n   *\n   * console.log(control.errors); // {email: true}\n   * ```\n   *\n   * @returns An error map with the `email` property\n   * if the validation check fails, otherwise `null`.\n   *\n   * @see {@link updateValueAndValidity()}\n   *\n   */\n  static email(control: AbstractControl): ValidationErrors|null {\n    return emailValidator(control);\n  }\n\n  /**\n   * @description\n   * Validator that requires the length of the control's value to be greater than or equal\n   * to the provided minimum length. This validator is also provided by default if you use the\n   * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used\n   * only for types that have a numeric `length` property, such as strings or arrays. The\n   * `minLength` validator logic is also not invoked for values when their `length` property is 0\n   * (for example in case of an empty string or an empty array), to support optional controls. You\n   * can use the standard `required` validator if empty values should not be considered valid.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field has a minimum of 3 characters\n   *\n   * ```typescript\n   * const control = new FormControl('ng', Validators.minLength(3));\n   *\n   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\n   * ```\n   *\n   * ```html\n   * <input minlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `minlength` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link updateValueAndValidity()}\n   *\n   */\n  static minLength(minLength: number): ValidatorFn {\n    return minLengthValidator(minLength);\n  }\n\n  /**\n   * @description\n   * Validator that requires the length of the control's value to be less than or equal\n   * to the provided maximum length. This validator is also provided by default if you use the\n   * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used\n   * only for types that have a numeric `length` property, such as strings or arrays.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field has maximum of 5 characters\n   *\n   * ```typescript\n   * const control = new FormControl('Angular', Validators.maxLength(5));\n   *\n   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\n   * ```\n   *\n   * ```html\n   * <input maxlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `maxlength` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link updateValueAndValidity()}\n   *\n   */\n  static maxLength(maxLength: number): ValidatorFn {\n    return maxLengthValidator(maxLength);\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value to match a regex pattern. This validator is also\n   * provided by default if you use the HTML5 `pattern` attribute.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field only contains letters or spaces\n   *\n   * ```typescript\n   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\n   *\n   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\n   * ```\n   *\n   * ```html\n   * <input pattern=\"[a-zA-Z ]*\">\n   * ```\n   *\n   * ### Pattern matching with the global or sticky flag\n   *\n   * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`\n   * can produce different results on the same input when validations are run consecutively. This is\n   * due to how the behavior of `RegExp.prototype.test` is\n   * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)\n   * (`RegExp` preserves the index of the last match when the global or sticky flag is used).\n   * Due to this behavior, it is recommended that when using\n   * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky\n   * flag enabled.\n   *\n   * ```typescript\n   * // Not recommended (since the `g` flag is used)\n   * const controlOne = new FormControl('1', Validators.pattern(/foo/g));\n   *\n   * // Good\n   * const controlTwo = new FormControl('1', Validators.pattern(/foo/));\n   * ```\n   *\n   * @param pattern A regular expression to be used as is to test the values, or a string.\n   * If a string is passed, the `^` character is prepended and the `$` character is\n   * appended to the provided string (if not already present), and the resulting regular\n   * expression is used to test the values.\n   *\n   * @returns A validator function that returns an error map with the\n   * `pattern` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link updateValueAndValidity()}\n   *\n   */\n  static pattern(pattern: string|RegExp): ValidatorFn {\n    return patternValidator(pattern);\n  }\n\n  /**\n   * @description\n   * Validator that performs no operation.\n   *\n   * @see {@link updateValueAndValidity()}\n   *\n   */\n  static nullValidator(control: AbstractControl): ValidationErrors|null {\n    return nullValidator(control);\n  }\n\n  /**\n   * @description\n   * Compose multiple validators into a single function that returns the union\n   * of the individual error maps for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error maps of the validators if the validation check fails, otherwise `null`.\n   *\n   * @see {@link updateValueAndValidity()}\n   *\n   */\n  static compose(validators: null): null;\n  static compose(validators: (ValidatorFn|null|undefined)[]): ValidatorFn|null;\n  static compose(validators: (ValidatorFn|null|undefined)[]|null): ValidatorFn|null {\n    return compose(validators);\n  }\n\n  /**\n   * @description\n   * Compose multiple async validators into a single function that returns the union\n   * of the individual error objects for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error objects of the async validators if the validation check fails, otherwise `null`.\n   *\n   * @see {@link updateValueAndValidity()}\n   *\n   */\n  static composeAsync(validators: (AsyncValidatorFn|null)[]): AsyncValidatorFn|null {\n    return composeAsync(validators);\n  }\n}\n\n/**\n * Validator that requires the control's value to be greater than or equal to the provided number.\n * See `Validators.min` for additional information.\n */\nexport function minValidator(min: number): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors|null => {\n    if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {\n      return null;  // don't validate empty values to allow optional controls\n    }\n    const value = parseFloat(control.value);\n    // Controls with NaN values after parsing should be treated as not having a\n    // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n    return !isNaN(value) && value < min ? {'min': {'min': min, 'actual': control.value}} : null;\n  };\n}\n\n/**\n * Validator that requires the control's value to be less than or equal to the provided number.\n * See `Validators.max` for additional information.\n */\nexport function maxValidator(max: number): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors|null => {\n    if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {\n      return null;  // don't validate empty values to allow optional controls\n    }\n    const value = parseFloat(control.value);\n    // Controls with NaN values after parsing should be treated as not having a\n    // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n    return !isNaN(value) && value > max ? {'max': {'max': max, 'actual': control.value}} : null;\n  };\n}\n\n/**\n * Validator that requires the control have a non-empty value.\n * See `Validators.required` for additional information.\n */\nexport function requiredValidator(control: AbstractControl): ValidationErrors|null {\n  return isEmptyInputValue(control.value) ? {'required': true} : null;\n}\n\n/**\n * Validator that requires the control's value be true. This validator is commonly\n * used for required checkboxes.\n * See `Validators.requiredTrue` for additional information.\n */\nexport function requiredTrueValidator(control: AbstractControl): ValidationErrors|null {\n  return control.value === true ? null : {'required': true};\n}\n\n/**\n * Validator that requires the control's value pass an email validation test.\n * See `Validators.email` for additional information.\n */\nexport function emailValidator(control: AbstractControl): ValidationErrors|null {\n  if (isEmptyInputValue(control.value)) {\n    return null;  // don't validate empty values to allow optional controls\n  }\n  return EMAIL_REGEXP.test(control.value) ? null : {'email': true};\n}\n\n/**\n * Validator that requires the length of the control's value to be greater than or equal\n * to the provided minimum length. See `Validators.minLength` for additional information.\n */\nexport function minLengthValidator(minLength: number): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors|null => {\n    if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {\n      // don't validate empty values to allow optional controls\n      // don't validate values without `length` property\n      return null;\n    }\n\n    return control.value.length < minLength ?\n        {'minlength': {'requiredLength': minLength, 'actualLength': control.value.length}} :\n        null;\n  };\n}\n\n/**\n * Validator that requires the length of the control's value to be less than or equal\n * to the provided maximum length. See `Validators.maxLength` for additional information.\n */\nexport function maxLengthValidator(maxLength: number): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors|null => {\n    return hasValidLength(control.value) && control.value.length > maxLength ?\n        {'maxlength': {'requiredLength': maxLength, 'actualLength': control.value.length}} :\n        null;\n  };\n}\n\n/**\n * Validator that requires the control's value to match a regex pattern.\n * See `Validators.pattern` for additional information.\n */\nexport function patternValidator(pattern: string|RegExp): ValidatorFn {\n  if (!pattern) return nullValidator;\n  let regex: RegExp;\n  let regexStr: string;\n  if (typeof pattern === 'string') {\n    regexStr = '';\n\n    if (pattern.charAt(0) !== '^') regexStr += '^';\n\n    regexStr += pattern;\n\n    if (pattern.charAt(pattern.length - 1) !== '$') regexStr += '$';\n\n    regex = new RegExp(regexStr);\n  } else {\n    regexStr = pattern.toString();\n    regex = pattern;\n  }\n  return (control: AbstractControl): ValidationErrors|null => {\n    if (isEmptyInputValue(control.value)) {\n      return null;  // don't validate empty values to allow optional controls\n    }\n    const value: string = control.value;\n    return regex.test(value) ? null :\n                               {'pattern': {'requiredPattern': regexStr, 'actualValue': value}};\n  };\n}\n\n/**\n * Function that has `ValidatorFn` shape, but performs no operation.\n */\nexport function nullValidator(control: AbstractControl): ValidationErrors|null {\n  return null;\n}\n\nfunction isPresent(o: any): boolean {\n  return o != null;\n}\n\nexport function toObservable(value: any): Observable<any> {\n  const obs = isPromise(value) ? from(value) : value;\n  if ((typeof ngDevMode === 'undefined' || ngDevMode) && !(isSubscribable(obs))) {\n    let errorMessage = `Expected async validator to return Promise or Observable.`;\n    // A synchronous validator will return object or null.\n    if (typeof value === 'object') {\n      errorMessage +=\n          ' Are you using a synchronous validator where an async validator is expected?';\n    }\n    throw new RuntimeError(RuntimeErrorCode.WRONG_VALIDATOR_RETURN_TYPE, errorMessage);\n  }\n  return obs;\n}\n\nfunction mergeErrors(arrayOfErrors: (ValidationErrors|null)[]): ValidationErrors|null {\n  let res: {[key: string]: any} = {};\n  arrayOfErrors.forEach((errors: ValidationErrors|null) => {\n    res = errors != null ? {...res!, ...errors} : res!;\n  });\n\n  return Object.keys(res).length === 0 ? null : res;\n}\n\ntype GenericValidatorFn = (control: AbstractControl) => any;\n\nfunction executeValidators<V extends GenericValidatorFn>(\n    control: AbstractControl, validators: V[]): ReturnType<V>[] {\n  return validators.map(validator => validator(control));\n}\n\nfunction isValidatorFn<V>(validator: V|Validator|AsyncValidator): validator is V {\n  return !(validator as Validator).validate;\n}\n\n/**\n * Given the list of validators that may contain both functions as well as classes, return the list\n * of validator functions (convert validator classes into validator functions). This is needed to\n * have consistent structure in validators list before composing them.\n *\n * @param validators The set of validators that may contain validators both in plain function form\n *     as well as represented as a validator class.\n */\nexport function normalizeValidators<V>(validators: (V|Validator|AsyncValidator)[]): V[] {\n  return validators.map(validator => {\n    return isValidatorFn<V>(validator) ?\n        validator :\n        ((c: AbstractControl) => validator.validate(c)) as unknown as V;\n  });\n}\n\n/**\n * Merges synchronous validators into a single validator function.\n * See `Validators.compose` for additional information.\n */\nfunction compose(validators: (ValidatorFn|null|undefined)[]|null): ValidatorFn|null {\n  if (!validators) return null;\n  const presentValidators: ValidatorFn[] = validators.filter(isPresent) as any;\n  if (presentValidators.length == 0) return null;\n\n  return function(control: AbstractControl) {\n    return mergeErrors(executeValidators<ValidatorFn>(control, presentValidators));\n  };\n}\n\n/**\n * Accepts a list of validators of different possible shapes (`Validator` and `ValidatorFn`),\n * normalizes the list (converts everything to `ValidatorFn`) and merges them into a single\n * validator function.\n */\nexport function composeValidators(validators: Array<Validator|ValidatorFn>): ValidatorFn|null {\n  return validators != null ? compose(normalizeValidators<ValidatorFn>(validators)) : null;\n}\n\n/**\n * Merges asynchronous validators into a single validator function.\n * See `Validators.composeAsync` for additional information.\n */\nfunction composeAsync(validators: (AsyncValidatorFn|null)[]): AsyncValidatorFn|null {\n  if (!validators) return null;\n  const presentValidators: AsyncValidatorFn[] = validators.filter(isPresent) as any;\n  if (presentValidators.length == 0) return null;\n\n  return function(control: AbstractControl) {\n    const observables =\n        executeValidators<AsyncValidatorFn>(control, presentValidators).map(toObservable);\n    return forkJoin(observables).pipe(map(mergeErrors));\n  };\n}\n\n/**\n * Accepts a list of async validators of different possible shapes (`AsyncValidator` and\n * `AsyncValidatorFn`), normalizes the list (converts everything to `AsyncValidatorFn`) and merges\n * them into a single validator function.\n */\nexport function composeAsyncValidators(validators: Array<AsyncValidator|AsyncValidatorFn>):\n    AsyncValidatorFn|null {\n  return validators != null ? composeAsync(normalizeValidators<AsyncValidatorFn>(validators)) :\n                              null;\n}\n\n/**\n * Merges raw control validators with a given directive validator and returns the combined list of\n * validators as an array.\n */\nexport function mergeValidators<V>(controlValidators: V|V[]|null, dirValidator: V): V[] {\n  if (controlValidators === null) return [dirValidator];\n  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] :\n                                            [controlValidators, dirValidator];\n}\n\n/**\n * Retrieves the list of raw synchronous validators attached to a given control.\n */\nexport function getControlValidators(control: AbstractControl): ValidatorFn|ValidatorFn[]|null {\n  return (control as any)._rawValidators as ValidatorFn | ValidatorFn[] | null;\n}\n\n/**\n * Retrieves the list of raw asynchronous validators attached to a given control.\n */\nexport function getControlAsyncValidators(control: AbstractControl): AsyncValidatorFn|\n    AsyncValidatorFn[]|null {\n  return (control as any)._rawAsyncValidators as AsyncValidatorFn | AsyncValidatorFn[] | null;\n}\n\n/**\n * Accepts a singleton validator, an array, or null, and returns an array type with the provided\n * validators.\n *\n * @param validators A validator, validators, or null.\n * @returns A validators array.\n */\nexport function makeValidatorsArray<T extends ValidatorFn|AsyncValidatorFn>(validators: T|T[]|\n                                                                            null): T[] {\n  if (!validators) return [];\n  return Array.isArray(validators) ? validators : [validators];\n}\n\n/**\n * Determines whether a validator or validators array has a given validator.\n *\n * @param validators The validator or validators to compare against.\n * @param validator The validator to check.\n * @returns Whether the validator is present.\n */\nexport function hasValidator<T extends ValidatorFn|AsyncValidatorFn>(\n    validators: T|T[]|null, validator: T): boolean {\n  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;\n}\n\n/**\n * Combines two arrays of validators into one. If duplicates are provided, only one will be added.\n *\n * @param validators The new validators.\n * @param currentValidators The base array of current validators.\n * @returns An array of validators.\n */\nexport function addValidators<T extends ValidatorFn|AsyncValidatorFn>(\n    validators: T|T[], currentValidators: T|T[]|null): T[] {\n  const current = makeValidatorsArray(currentValidators);\n  const validatorsToAdd = makeValidatorsArray(validators);\n  validatorsToAdd.forEach((v: T) => {\n    // Note: if there are duplicate entries in the new validators array,\n    // only the first one would be added to the current list of validators.\n    // Duplicate ones would be ignored since `hasValidator` would detect\n    // the presence of a validator function and we update the current list in place.\n    if (!hasValidator(current, v)) {\n      current.push(v);\n    }\n  });\n  return current;\n}\n\nexport function removeValidators<T extends ValidatorFn|AsyncValidatorFn>(\n    validators: T|T[], currentValidators: T|T[]|null): T[] {\n  return makeValidatorsArray(currentValidators).filter(v => !hasValidator(validators, v));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable} from 'rxjs';\n\nimport {AbstractControl} from '../model/abstract_model';\nimport {composeAsyncValidators, composeValidators} from '../validators';\n\nimport {AsyncValidator, AsyncValidatorFn, ValidationErrors, Validator, ValidatorFn} from './validators';\n\n\n/**\n * @description\n * Base class for control directives.\n *\n * This class is only used internally in the `ReactiveFormsModule` and the `FormsModule`.\n *\n * @publicApi\n */\nexport abstract class AbstractControlDirective {\n  /**\n   * @description\n   * A reference to the underlying control.\n   *\n   * @returns the control that backs this directive. Most properties fall through to that instance.\n   */\n  abstract get control(): AbstractControl|null;\n\n  /**\n   * @description\n   * Reports the value of the control if it is present, otherwise null.\n   */\n  get value(): any {\n    return this.control ? this.control.value : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is valid. A control is considered valid if no\n   * validation errors exist with the current value.\n   * If the control is not present, null is returned.\n   */\n  get valid(): boolean|null {\n    return this.control ? this.control.valid : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is invalid, meaning that an error exists in the input value.\n   * If the control is not present, null is returned.\n   */\n  get invalid(): boolean|null {\n    return this.control ? this.control.invalid : null;\n  }\n\n  /**\n   * @description\n   * Reports whether a control is pending, meaning that async validation is occurring and\n   * errors are not yet available for the input value. If the control is not present, null is\n   * returned.\n   */\n  get pending(): boolean|null {\n    return this.control ? this.control.pending : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is disabled, meaning that the control is disabled\n   * in the UI and is exempt from validation checks and excluded from aggregate\n   * values of ancestor controls. If the control is not present, null is returned.\n   */\n  get disabled(): boolean|null {\n    return this.control ? this.control.disabled : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is enabled, meaning that the control is included in ancestor\n   * calculations of validity or value. If the control is not present, null is returned.\n   */\n  get enabled(): boolean|null {\n    return this.control ? this.control.enabled : null;\n  }\n\n  /**\n   * @description\n   * Reports the control's validation errors. If the control is not present, null is returned.\n   */\n  get errors(): ValidationErrors|null {\n    return this.control ? this.control.errors : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is pristine, meaning that the user has not yet changed\n   * the value in the UI. If the control is not present, null is returned.\n   */\n  get pristine(): boolean|null {\n    return this.control ? this.control.pristine : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is dirty, meaning that the user has changed\n   * the value in the UI. If the control is not present, null is returned.\n   */\n  get dirty(): boolean|null {\n    return this.control ? this.control.dirty : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is touched, meaning that the user has triggered\n   * a `blur` event on it. If the control is not present, null is returned.\n   */\n  get touched(): boolean|null {\n    return this.control ? this.control.touched : null;\n  }\n\n  /**\n   * @description\n   * Reports the validation status of the control. Possible values include:\n   * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.\n   * If the control is not present, null is returned.\n   */\n  get status(): string|null {\n    return this.control ? this.control.status : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control is untouched, meaning that the user has not yet triggered\n   * a `blur` event on it. If the control is not present, null is returned.\n   */\n  get untouched(): boolean|null {\n    return this.control ? this.control.untouched : null;\n  }\n\n  /**\n   * @description\n   * Returns a multicasting observable that emits a validation status whenever it is\n   * calculated for the control. If the control is not present, null is returned.\n   */\n  get statusChanges(): Observable<any>|null {\n    return this.control ? this.control.statusChanges : null;\n  }\n\n  /**\n   * @description\n   * Returns a multicasting observable of value changes for the control that emits every time the\n   * value of the control changes in the UI or programmatically.\n   * If the control is not present, null is returned.\n   */\n  get valueChanges(): Observable<any>|null {\n    return this.control ? this.control.valueChanges : null;\n  }\n\n  /**\n   * @description\n   * Returns an array that represents the path from the top-level form to this control.\n   * Each index is the string name of the control on that level.\n   */\n  get path(): string[]|null {\n    return null;\n  }\n\n  /**\n   * Contains the result of merging synchronous validators into a single validator function\n   * (combined using `Validators.compose`).\n   */\n  private _composedValidatorFn: ValidatorFn|null|undefined;\n\n  /**\n   * Contains the result of merging asynchronous validators into a single validator function\n   * (combined using `Validators.composeAsync`).\n   */\n  private _composedAsyncValidatorFn: AsyncValidatorFn|null|undefined;\n\n  /**\n   * Set of synchronous validators as they were provided while calling `setValidators` function.\n   * @internal\n   */\n  _rawValidators: Array<Validator|ValidatorFn> = [];\n\n  /**\n   * Set of asynchronous validators as they were provided while calling `setAsyncValidators`\n   * function.\n   * @internal\n   */\n  _rawAsyncValidators: Array<AsyncValidator|AsyncValidatorFn> = [];\n\n  /**\n   * Sets synchronous validators for this directive.\n   * @internal\n   */\n  _setValidators(validators: Array<Validator|ValidatorFn>|undefined): void {\n    this._rawValidators = validators || [];\n    this._composedValidatorFn = composeValidators(this._rawValidators);\n  }\n\n  /**\n   * Sets asynchronous validators for this directive.\n   * @internal\n   */\n  _setAsyncValidators(validators: Array<AsyncValidator|AsyncValidatorFn>|undefined): void {\n    this._rawAsyncValidators = validators || [];\n    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);\n  }\n\n  /**\n   * @description\n   * Synchronous validator function composed of all the synchronous validators registered with this\n   * directive.\n   */\n  get validator(): ValidatorFn|null {\n    return this._composedValidatorFn || null;\n  }\n\n  /**\n   * @description\n   * Asynchronous validator function composed of all the asynchronous validators registered with\n   * this directive.\n   */\n  get asyncValidator(): AsyncValidatorFn|null {\n    return this._composedAsyncValidatorFn || null;\n  }\n\n  /*\n   * The set of callbacks to be invoked when directive instance is being destroyed.\n   */\n  private _onDestroyCallbacks: (() => void)[] = [];\n\n  /**\n   * Internal function to register callbacks that should be invoked\n   * when directive instance is being destroyed.\n   * @internal\n   */\n  _registerOnDestroy(fn: () => void): void {\n    this._onDestroyCallbacks.push(fn);\n  }\n\n  /**\n   * Internal function to invoke all registered \"on destroy\" callbacks.\n   * Note: calling this function also clears the list of callbacks.\n   * @internal\n   */\n  _invokeOnDestroyCallbacks(): void {\n    this._onDestroyCallbacks.forEach(fn => fn());\n    this._onDestroyCallbacks = [];\n  }\n\n  /**\n   * @description\n   * Resets the control with the provided value if the control is present.\n   */\n  reset(value: any = undefined): void {\n    if (this.control) this.control.reset(value);\n  }\n\n  /**\n   * @description\n   * Reports whether the control with the given path has the error specified.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * If no path is given, this method checks for the error on the current control.\n   *\n   * @returns whether the given error is present in the control at the given path.\n   *\n   * If the control is not present, false is returned.\n   */\n  hasError(errorCode: string, path?: Array<string|number>|string): boolean {\n    return this.control ? this.control.hasError(errorCode, path) : false;\n  }\n\n  /**\n   * @description\n   * Reports error data for the control with the given path.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * @returns error data for that particular error. If the control or error is not present,\n   * null is returned.\n   */\n  getError(errorCode: string, path?: Array<string|number>|string): any {\n    return this.control ? this.control.getError(errorCode, path) : null;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractControlDirective} from './abstract_control_directive';\nimport {Form} from './form_interface';\n\n\n/**\n * @description\n * A base class for directives that contain multiple registered instances of `NgControl`.\n * Only used by the forms module.\n *\n * @publicApi\n */\nexport abstract class ControlContainer extends AbstractControlDirective {\n  /**\n   * @description\n   * The name for the control\n   */\n  // TODO(issue/24571): remove '!'.\n  name!: string|number|null;\n\n  /**\n   * @description\n   * The top-level form directive for the control.\n   */\n  get formDirective(): Form|null {\n    return null;\n  }\n\n  /**\n   * @description\n   * The path to this group.\n   */\n  override get path(): string[]|null {\n    return null;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractControlDirective} from './abstract_control_directive';\nimport {ControlContainer} from './control_container';\nimport {ControlValueAccessor} from './control_value_accessor';\n\n\n/**\n * @description\n * A base class that all `FormControl`-based directives extend. It binds a `FormControl`\n * object to a DOM element.\n *\n * @publicApi\n */\nexport abstract class NgControl extends AbstractControlDirective {\n  /**\n   * @description\n   * The parent form for the control.\n   *\n   * @internal\n   */\n  _parent: ControlContainer|null = null;\n\n  /**\n   * @description\n   * The name for the control\n   */\n  name: string|number|null = null;\n\n  /**\n   * @description\n   * The value accessor for the control\n   */\n  valueAccessor: ControlValueAccessor|null = null;\n\n  /**\n   * @description\n   * The callback method to update the model from the view when requested\n   *\n   * @param newValue The new value for the view\n   */\n  abstract viewToModelUpdate(newValue: any): void;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, Optional, Self, Writable as Writable} from '@angular/core';\n\nimport {AbstractControlDirective} from './abstract_control_directive';\nimport {ControlContainer} from './control_container';\nimport {NgControl} from './ng_control';\nimport {type NgForm} from './ng_form';\nimport {type FormGroupDirective} from './reactive_directives/form_group_directive';\n\n// DO NOT REFACTOR!\n// Each status is represented by a separate function to make sure that\n// advanced Closure Compiler optimizations related to property renaming\n// can work correctly.\nexport class AbstractControlStatus {\n  private _cd: AbstractControlDirective|null;\n\n  constructor(cd: AbstractControlDirective|null) {\n    this._cd = cd;\n  }\n\n  protected get isTouched() {\n    return !!this._cd?.control?.touched;\n  }\n\n  protected get isUntouched() {\n    return !!this._cd?.control?.untouched;\n  }\n\n  protected get isPristine() {\n    return !!this._cd?.control?.pristine;\n  }\n\n  protected get isDirty() {\n    return !!this._cd?.control?.dirty;\n  }\n\n  protected get isValid() {\n    return !!this._cd?.control?.valid;\n  }\n\n  protected get isInvalid() {\n    return !!this._cd?.control?.invalid;\n  }\n\n  protected get isPending() {\n    return !!this._cd?.control?.pending;\n  }\n\n  protected get isSubmitted() {\n    // We check for the `submitted` field from `NgForm` and `FormGroupDirective` classes, but\n    // we avoid instanceof checks to prevent non-tree-shakable references to those types.\n    return !!(this._cd as Writable<NgForm|FormGroupDirective>| null)?.submitted;\n  }\n}\n\nexport const ngControlStatusHost = {\n  '[class.ng-untouched]': 'isUntouched',\n  '[class.ng-touched]': 'isTouched',\n  '[class.ng-pristine]': 'isPristine',\n  '[class.ng-dirty]': 'isDirty',\n  '[class.ng-valid]': 'isValid',\n  '[class.ng-invalid]': 'isInvalid',\n  '[class.ng-pending]': 'isPending',\n};\n\nexport const ngGroupStatusHost = {\n  ...ngControlStatusHost,\n  '[class.ng-submitted]': 'isSubmitted',\n};\n\n/**\n * @description\n * Directive automatically applied to Angular form controls that sets CSS classes\n * based on control status.\n *\n * @usageNotes\n *\n * ### CSS classes applied\n *\n * The following classes are applied as the properties become true:\n *\n * * ng-valid\n * * ng-invalid\n * * ng-pending\n * * ng-pristine\n * * ng-dirty\n * * ng-untouched\n * * ng-touched\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({selector: '[formControlName],[ngModel],[formControl]', host: ngControlStatusHost})\nexport class NgControlStatus extends AbstractControlStatus {\n  constructor(@Self() cd: NgControl) {\n    super(cd);\n  }\n}\n\n/**\n * @description\n * Directive automatically applied to Angular form groups that sets CSS classes\n * based on control status (valid/invalid/dirty/etc). On groups, this includes the additional\n * class ng-submitted.\n *\n * @see {@link NgControlStatus}\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector:\n      '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]',\n  host: ngGroupStatusHost\n})\nexport class NgControlStatusGroup extends AbstractControlStatus {\n  constructor(@Optional() @Self() cd: ControlContainer) {\n    super(cd);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const formControlNameExample = `\n  <div [formGroup]=\"myGroup\">\n    <input formControlName=\"firstName\">\n  </div>\n\n  In your class:\n\n  this.myGroup = new FormGroup({\n      firstName: new FormControl()\n  });`;\n\nexport const formGroupNameExample = `\n  <div [formGroup]=\"myGroup\">\n      <div formGroupName=\"person\">\n        <input formControlName=\"firstName\">\n      </div>\n  </div>\n\n  In your class:\n\n  this.myGroup = new FormGroup({\n      person: new FormGroup({ firstName: new FormControl() })\n  });`;\n\nexport const formArrayNameExample = `\n  <div [formGroup]=\"myGroup\">\n    <div formArrayName=\"cities\">\n      <div *ngFor=\"let city of cityArray.controls; index as i\">\n        <input [formControlName]=\"i\">\n      </div>\n    </div>\n  </div>\n\n  In your class:\n\n  this.cityArray = new FormArray([new FormControl('SF')]);\n  this.myGroup = new FormGroup({\n    cities: this.cityArray\n  });`;\n\nexport const ngModelGroupExample = `\n  <form>\n      <div ngModelGroup=\"person\">\n        <input [(ngModel)]=\"person.name\" name=\"firstName\">\n      </div>\n  </form>`;\n\nexport const ngModelWithFormGroupExample = `\n  <div [formGroup]=\"myGroup\">\n      <input formControlName=\"firstName\">\n      <input [(ngModel)]=\"showMoreControls\" [ngModelOptions]=\"{standalone: true}\">\n  </div>\n`;\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\n\nimport {formArrayNameExample, formControlNameExample, formGroupNameExample, ngModelGroupExample} from './error_examples';\n\n\nexport function controlParentException(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.FORM_CONTROL_NAME_MISSING_PARENT,\n      `formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n    Example:\n\n    ${formControlNameExample}`);\n}\n\nexport function ngModelGroupException(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.FORM_CONTROL_NAME_INSIDE_MODEL_GROUP,\n      `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n      that also have a \"form\" prefix: formGroupName, formArrayName, or formGroup.\n\n      Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n      ${formGroupNameExample}\n\n      Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n      ${ngModelGroupExample}`);\n}\n\nexport function missingFormException(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.FORM_GROUP_MISSING_INSTANCE,\n      `formGroup expects a FormGroup instance. Please pass one in.\n\n      Example:\n\n      ${formControlNameExample}`);\n}\n\nexport function groupParentException(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.FORM_GROUP_NAME_MISSING_PARENT,\n      `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n    directive and pass it an existing FormGroup instance (you can create one in your class).\n\n    Example:\n\n    ${formGroupNameExample}`);\n}\n\nexport function arrayParentException(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.FORM_ARRAY_NAME_MISSING_PARENT,\n      `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      ${formArrayNameExample}`);\n}\n\nexport const disabledAttrWarning = `\n  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n  you. We recommend using this approach to avoid 'changed after checked' errors.\n\n  Example:\n  // Specify the \\`disabled\\` property at control creation time:\n  form = new FormGroup({\n    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n    last: new FormControl('Drew', Validators.required)\n  });\n\n  // Controls can also be enabled/disabled after creation:\n  form.get('first')?.enable();\n  form.get('last')?.disable();\n`;\n\nexport const asyncValidatorsDroppedWithOptsWarning = `\n  It looks like you're constructing using a FormControl with both an options argument and an\n  async validators argument. Mixing these arguments will cause your async validators to be dropped.\n  You should either put all your validators in the options object, or in separate validators\n  arguments. For example:\n\n  // Using validators arguments\n  fc = new FormControl(42, Validators.required, myAsyncValidator);\n\n  // Using AbstractControlOptions\n  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});\n\n  // Do NOT mix them: async validators will be dropped!\n  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);\n`;\n\nexport function ngModelWarning(directiveName: string): string {\n  return `\n  It looks like you're using ngModel on the same form field as ${directiveName}.\n  Support for using the ngModel input property and ngModelChange event with\n  reactive form directives has been deprecated in Angular v6 and will be removed\n  in a future version of Angular.\n\n  For more information on this, see our API docs here:\n  https://angular.io/api/forms/${\n      directiveName === 'formControl' ? 'FormControlDirective' : 'FormControlName'}#use-with-ngmodel\n  `;\n}\n\nfunction describeKey(isFormGroup: boolean, key: string|number): string {\n  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;\n}\n\nexport function noControlsError(isFormGroup: boolean): string {\n  return `\n    There are no form controls registered with this ${\n      isFormGroup ? 'group' : 'array'} yet. If you're using ngModel,\n    you may want to check next tick (e.g. use setTimeout).\n  `;\n}\n\nexport function missingControlError(isFormGroup: boolean, key: string|number): string {\n  return `Cannot find form control ${describeKey(isFormGroup, key)}`;\n}\n\nexport function missingControlValueError(isFormGroup: boolean, key: string|number): string {\n  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter, RuntimeError as RuntimeError, Writable as Writable} from '@angular/core';\nimport {Observable} from 'rxjs';\n\nimport {asyncValidatorsDroppedWithOptsWarning, missingControlError, missingControlValueError, noControlsError} from '../directives/reactive_errors';\nimport {AsyncValidatorFn, ValidationErrors, ValidatorFn} from '../directives/validators';\nimport {RuntimeErrorCode} from '../errors';\nimport {FormArray, FormGroup} from '../forms';\nimport {addValidators, composeAsyncValidators, composeValidators, hasValidator, removeValidators, toObservable} from '../validators';\n\n\n/**\n * Reports that a control is valid, meaning that no errors exist in the input value.\n *\n * @see {@link status}\n */\nexport const VALID = 'VALID';\n\n/**\n * Reports that a control is invalid, meaning that an error exists in the input value.\n *\n * @see {@link status}\n */\nexport const INVALID = 'INVALID';\n\n/**\n * Reports that a control is pending, meaning that async validation is occurring and\n * errors are not yet available for the input value.\n *\n * @see {@link markAsPending}\n * @see {@link status}\n */\nexport const PENDING = 'PENDING';\n\n/**\n * Reports that a control is disabled, meaning that the control is exempt from ancestor\n * calculations of validity or value.\n *\n * @see {@link markAsDisabled}\n * @see {@link status}\n */\nexport const DISABLED = 'DISABLED';\n\n/**\n * A form can have several different statuses. Each\n * possible status is returned as a string literal.\n *\n * * **VALID**: Reports that a control is valid, meaning that no errors exist in the input\n * value.\n * * **INVALID**: Reports that a control is invalid, meaning that an error exists in the input\n * value.\n * * **PENDING**: Reports that a control is pending, meaning that async validation is\n * occurring and errors are not yet available for the input value.\n * * **DISABLED**: Reports that a control is\n * disabled, meaning that the control is exempt from ancestor calculations of validity or value.\n *\n * @publicApi\n */\nexport type FormControlStatus = 'VALID'|'INVALID'|'PENDING'|'DISABLED';\n\n/**\n * Gets validators from either an options object or given validators.\n */\nexport function pickValidators(validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|\n                               null): ValidatorFn|ValidatorFn[]|null {\n  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;\n}\n\n/**\n * Creates validator function by combining provided validators.\n */\nfunction coerceToValidator(validator: ValidatorFn|ValidatorFn[]|null): ValidatorFn|null {\n  return Array.isArray(validator) ? composeValidators(validator) : validator || null;\n}\n\n/**\n * Gets async validators from either an options object or given validators.\n */\nexport function pickAsyncValidators(\n    asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null,\n    validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null): AsyncValidatorFn|\n    AsyncValidatorFn[]|null {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (isOptionsObj(validatorOrOpts) && asyncValidator) {\n      console.warn(asyncValidatorsDroppedWithOptsWarning);\n    }\n  }\n  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;\n}\n\n/**\n * Creates async validator function by combining provided async validators.\n */\nfunction coerceToAsyncValidator(asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|\n                                null): AsyncValidatorFn|null {\n  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) :\n                                         asyncValidator || null;\n}\n\nexport type FormHooks = 'change'|'blur'|'submit';\n\n/**\n * Interface for options provided to an `AbstractControl`.\n *\n * @publicApi\n */\nexport interface AbstractControlOptions {\n  /**\n   * @description\n   * The list of validators applied to a control.\n   */\n  validators?: ValidatorFn|ValidatorFn[]|null;\n  /**\n   * @description\n   * The list of async validators applied to control.\n   */\n  asyncValidators?: AsyncValidatorFn|AsyncValidatorFn[]|null;\n  /**\n   * @description\n   * The event name for control to update upon.\n   */\n  updateOn?: 'change'|'blur'|'submit';\n}\n\nexport function isOptionsObj(validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|\n                             null): validatorOrOpts is AbstractControlOptions {\n  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) &&\n      typeof validatorOrOpts === 'object';\n}\n\nexport function assertControlPresent(parent: any, isGroup: boolean, key: string|number): void {\n  const controls = parent.controls as {[key: string|number]: unknown};\n  const collection = isGroup ? Object.keys(controls) : controls;\n  if (!collection.length) {\n    throw new RuntimeError(\n        RuntimeErrorCode.NO_CONTROLS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) ? noControlsError(isGroup) : '');\n  }\n  if (!controls[key]) {\n    throw new RuntimeError(\n        RuntimeErrorCode.MISSING_CONTROL,\n        (typeof ngDevMode === 'undefined' || ngDevMode) ? missingControlError(isGroup, key) : '');\n  }\n}\n\nexport function assertAllValuesPresent(control: any, isGroup: boolean, value: any): void {\n  control._forEachChild((_: unknown, key: string|number) => {\n    if (value[key] === undefined) {\n      throw new RuntimeError(\n          RuntimeErrorCode.MISSING_CONTROL_VALUE,\n          (typeof ngDevMode === 'undefined' || ngDevMode) ? missingControlValueError(isGroup, key) :\n                                                            '');\n    }\n  });\n}\n\n// IsAny checks if T is `any`, by checking a condition that couldn't possibly be true otherwise.\nexport type IsAny<T, Y, N> = 0 extends(1&T) ? Y : N;\n\n/**\n * `TypedOrUntyped` allows one of two different types to be selected, depending on whether the Forms\n * class it's applied to is typed or not.\n *\n * This is for internal Angular usage to support typed forms; do not directly use it.\n */\nexport type TypedOrUntyped<T, Typed, Untyped> = IsAny<T, Untyped, Typed>;\n\n/**\n * Value gives the value type corresponding to a control type.\n *\n * Note that the resulting type will follow the same rules as `.value` on your control, group, or\n * array, including `undefined` for each group element which might be disabled.\n *\n * If you are trying to extract a value type for a data model, you probably want {@link RawValue},\n * which will not have `undefined` in group keys.\n *\n * @usageNotes\n *\n * ### `FormControl` value type\n *\n * You can extract the value type of a single control:\n *\n * ```ts\n * type NameControl = FormControl<string>;\n * type NameValue = Value<NameControl>;\n * ```\n *\n * The resulting type is `string`.\n *\n * ### `FormGroup` value type\n *\n * Imagine you have an interface defining the controls in your group. You can extract the shape of\n * the values as follows:\n *\n * ```ts\n * interface PartyFormControls {\n *   address: FormControl<string>;\n * }\n *\n * // Value operates on controls; the object must be wrapped in a FormGroup.\n * type PartyFormValues = Value<FormGroup<PartyFormControls>>;\n * ```\n *\n * The resulting type is `{address: string|undefined}`.\n *\n * ### `FormArray` value type\n *\n * You can extract values from FormArrays as well:\n *\n * ```ts\n * type GuestNamesControls = FormArray<FormControl<string>>;\n *\n * type NamesValues = Value<GuestNamesControls>;\n * ```\n *\n * The resulting type is `string[]`.\n *\n * **Internal: not for public use.**\n */\nexport type Value<T extends AbstractControl|undefined> =\n    T extends AbstractControl<any, any>? T['value'] : never;\n\n/**\n * RawValue gives the raw value type corresponding to a control type.\n *\n * Note that the resulting type will follow the same rules as `.getRawValue()` on your control,\n * group, or array. This means that all controls inside a group will be required, not optional,\n * regardless of their disabled state.\n *\n * You may also wish to use {@link Value}, which will have `undefined` in group keys (which can be\n * disabled).\n *\n * @usageNotes\n *\n * ### `FormGroup` raw value type\n *\n * Imagine you have an interface defining the controls in your group. You can extract the shape of\n * the raw values as follows:\n *\n * ```ts\n * interface PartyFormControls {\n *   address: FormControl<string>;\n * }\n *\n * // RawValue operates on controls; the object must be wrapped in a FormGroup.\n * type PartyFormValues = RawValue<FormGroup<PartyFormControls>>;\n * ```\n *\n * The resulting type is `{address: string}`. (Note the absence of `undefined`.)\n *\n *  **Internal: not for public use.**\n */\nexport type RawValue<T extends AbstractControl|undefined> = T extends AbstractControl<any, any>?\n    (T['setValue'] extends((v: infer R) => void) ? R : never) :\n    never;\n\n// Disable clang-format to produce clearer formatting for these multiline types.\n// clang-format off\n\n/**\n * Tokenize splits a string literal S by a delimiter D.\n */\nexport type Tokenize<S extends string, D extends string> =\n  string extends S ? string[] : /* S must be a literal */\n    S extends `${infer T}${D}${infer U}` ? [T, ...Tokenize<U, D>] :\n      [S] /* Base case */\n  ;\n\n/**\n * CoerceStrArrToNumArr accepts an array of strings, and converts any numeric string to a number.\n */\nexport type CoerceStrArrToNumArr<S> =\n// Extract the head of the array.\n  S extends [infer Head, ...infer Tail] ?\n    // Using a template literal type, coerce the head to `number` if possible.\n    // Then, recurse on the tail.\n    Head extends `${number}` ?\n      [number, ...CoerceStrArrToNumArr<Tail>] :\n      [Head, ...CoerceStrArrToNumArr<Tail>] :\n    [];\n\n/**\n * Navigate takes a type T and an array K, and returns the type of T[K[0]][K[1]][K[2]]...\n */\nexport type Navigate<T, K extends(Array<string|number>)> =\n  T extends object ? /* T must be indexable (object or array) */\n    (K extends [infer Head, ...infer Tail] ? /* Split K into head and tail */\n      (Head extends keyof T ? /* head(K) must index T */\n        (Tail extends(string|number)[] ? /* tail(K) must be an array */\n          [] extends Tail ? T[Head] : /* base case: K can be split, but Tail is empty */\n            (Navigate<T[Head], Tail>) /* explore T[head(K)] by tail(K) */ :\n          any) /* tail(K) was not an array, give up */ :\n        never) /* head(K) does not index T, give up */ :\n      any) /* K cannot be split, give up */ :\n    any /* T is not indexable, give up */\n  ;\n\n/**\n * Writeable removes readonly from all keys.\n */\nexport type Writeable<T> = {\n  -readonly[P in keyof T]: T[P]\n};\n\n/**\n * GetProperty takes a type T and some property names or indices K.\n * If K is a dot-separated string, it is tokenized into an array before proceeding.\n * Then, the type of the nested property at K is computed: T[K[0]][K[1]][K[2]]...\n * This works with both objects, which are indexed by property name, and arrays, which are indexed\n * numerically.\n *\n * For internal use only.\n */\nexport type GetProperty<T, K> =\n    // K is a string\n    K extends string ? GetProperty<T, CoerceStrArrToNumArr<Tokenize<K, '.'>>> :\n    // Is it an array\n    Writeable<K> extends Array<string|number> ? Navigate<T, Writeable<K>> :\n    // Fall through permissively if we can't calculate the type of K.\n    any;\n\n// clang-format on\n\n/**\n * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.\n *\n * It provides some of the shared behavior that all controls and groups of controls have, like\n * running validators, calculating status, and resetting state. It also defines the properties\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n * instantiated directly.\n *\n * The first type parameter TValue represents the value type of the control (`control.value`).\n * The optional type parameter TRawValue  represents the raw value type (`control.getRawValue()`).\n *\n * @see [Forms Guide](/guide/forms)\n * @see [Reactive Forms Guide](/guide/reactive-forms)\n * @see [Dynamic Forms Guide](/guide/dynamic-form)\n *\n * @publicApi\n */\nexport abstract class AbstractControl<TValue = any, TRawValue extends TValue = TValue> {\n  /** @internal */\n  _pendingDirty = false;\n\n  /**\n   * Indicates that a control has its own pending asynchronous validation in progress.\n   *\n   * @internal\n   */\n  _hasOwnPendingAsyncValidator = false;\n\n  /** @internal */\n  _pendingTouched = false;\n\n  /** @internal */\n  _onCollectionChange = () => {};\n\n  /** @internal */\n  _updateOn?: FormHooks;\n\n  private _parent: FormGroup|FormArray|null = null;\n  private _asyncValidationSubscription: any;\n\n  /**\n   * Contains the result of merging synchronous validators into a single validator function\n   * (combined using `Validators.compose`).\n   *\n   * @internal\n   */\n  private _composedValidatorFn!: ValidatorFn|null;\n\n  /**\n   * Contains the result of merging asynchronous validators into a single validator function\n   * (combined using `Validators.composeAsync`).\n   *\n   * @internal\n   */\n  private _composedAsyncValidatorFn!: AsyncValidatorFn|null;\n\n  /**\n   * Synchronous validators as they were provided:\n   *  - in `AbstractControl` constructor\n   *  - as an argument while calling `setValidators` function\n   *  - while calling the setter on the `validator` field (e.g. `control.validator = validatorFn`)\n   *\n   * @internal\n   */\n  private _rawValidators!: ValidatorFn|ValidatorFn[]|null;\n\n  /**\n   * Asynchronous validators as they were provided:\n   *  - in `AbstractControl` constructor\n   *  - as an argument while calling `setAsyncValidators` function\n   *  - while calling the setter on the `asyncValidator` field (e.g. `control.asyncValidator =\n   * asyncValidatorFn`)\n   *\n   * @internal\n   */\n  private _rawAsyncValidators!: AsyncValidatorFn|AsyncValidatorFn[]|null;\n\n  /**\n   * The current value of the control.\n   *\n   * * For a `FormControl`, the current value.\n   * * For an enabled `FormGroup`, the values of enabled controls as an object\n   * with a key-value pair for each member of the group.\n   * * For a disabled `FormGroup`, the values of all controls as an object\n   * with a key-value pair for each member of the group.\n   * * For a `FormArray`, the values of enabled controls as an array.\n   *\n   */\n  public readonly value!: TValue;\n\n  /**\n   * Initialize the AbstractControl instance.\n   *\n   * @param validators The function or array of functions that is used to determine the validity of\n   *     this control synchronously.\n   * @param asyncValidators The function or array of functions that is used to determine validity of\n   *     this control asynchronously.\n   */\n  constructor(\n      validators: ValidatorFn|ValidatorFn[]|null,\n      asyncValidators: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    this._assignValidators(validators);\n    this._assignAsyncValidators(asyncValidators);\n  }\n\n  /**\n   * Returns the function that is used to determine the validity of this control synchronously.\n   * If multiple validators have been added, this will be a single composed function.\n   * See `Validators.compose()` for additional information.\n   */\n  get validator(): ValidatorFn|null {\n    return this._composedValidatorFn;\n  }\n  set validator(validatorFn: ValidatorFn|null) {\n    this._rawValidators = this._composedValidatorFn = validatorFn;\n  }\n\n  /**\n   * Returns the function that is used to determine the validity of this control asynchronously.\n   * If multiple validators have been added, this will be a single composed function.\n   * See `Validators.compose()` for additional information.\n   */\n  get asyncValidator(): AsyncValidatorFn|null {\n    return this._composedAsyncValidatorFn;\n  }\n  set asyncValidator(asyncValidatorFn: AsyncValidatorFn|null) {\n    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;\n  }\n\n  /**\n   * The parent control.\n   */\n  get parent(): FormGroup|FormArray|null {\n    return this._parent;\n  }\n\n  /**\n   * The validation status of the control.\n   *\n   * @see {@link FormControlStatus}\n   *\n   * These status values are mutually exclusive, so a control cannot be\n   * both valid AND invalid or invalid AND disabled.\n   */\n  public readonly status!: FormControlStatus;\n\n  /**\n   * A control is `valid` when its `status` is `VALID`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if the control has passed all of its validation tests,\n   * false otherwise.\n   */\n  get valid(): boolean {\n    return this.status === VALID;\n  }\n\n  /**\n   * A control is `invalid` when its `status` is `INVALID`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if this control has failed one or more of its validation checks,\n   * false otherwise.\n   */\n  get invalid(): boolean {\n    return this.status === INVALID;\n  }\n\n  /**\n   * A control is `pending` when its `status` is `PENDING`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if this control is in the process of conducting a validation check,\n   * false otherwise.\n   */\n  get pending(): boolean {\n    return this.status == PENDING;\n  }\n\n  /**\n   * A control is `disabled` when its `status` is `DISABLED`.\n   *\n   * Disabled controls are exempt from validation checks and\n   * are not included in the aggregate value of their ancestor\n   * controls.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if the control is disabled, false otherwise.\n   */\n  get disabled(): boolean {\n    return this.status === DISABLED;\n  }\n\n  /**\n   * A control is `enabled` as long as its `status` is not `DISABLED`.\n   *\n   * @returns True if the control has any status other than 'DISABLED',\n   * false if the status is 'DISABLED'.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   */\n  get enabled(): boolean {\n    return this.status !== DISABLED;\n  }\n\n  /**\n   * An object containing any errors generated by failing validation,\n   * or null if there are no errors.\n   */\n  public readonly errors!: ValidationErrors|null;\n\n  /**\n   * A control is `pristine` if the user has not yet changed\n   * the value in the UI.\n   *\n   * @returns True if the user has not yet changed the value in the UI; compare `dirty`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n  public readonly pristine: boolean = true;\n\n  /**\n   * A control is `dirty` if the user has changed the value\n   * in the UI.\n   *\n   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n  get dirty(): boolean {\n    return !this.pristine;\n  }\n\n  /**\n   * True if the control is marked as `touched`.\n   *\n   * A control is marked `touched` once the user has triggered\n   * a `blur` event on it.\n   */\n  public readonly touched: boolean = false;\n\n  /**\n   * True if the control has not been marked as touched\n   *\n   * A control is `untouched` if the user has not yet triggered\n   * a `blur` event on it.\n   */\n  get untouched(): boolean {\n    return !this.touched;\n  }\n\n  /**\n   * A multicasting observable that emits an event every time the value of the control changes, in\n   * the UI or programmatically. It also emits an event each time you call enable() or disable()\n   * without passing along {emitEvent: false} as a function argument.\n   *\n   * **Note**: the emit happens right after a value of this control is updated. The value of a\n   * parent control (for example if this FormControl is a part of a FormGroup) is updated later, so\n   * accessing a value of a parent control (using the `value` property) from the callback of this\n   * event might result in getting a value that has not been updated yet. Subscribe to the\n   * `valueChanges` event of the parent control instead.\n   */\n  public readonly valueChanges!: Observable<TValue>;\n\n  /**\n   * A multicasting observable that emits an event every time the validation `status` of the control\n   * recalculates.\n   *\n   * @see {@link FormControlStatus}\n   * @see {@link AbstractControl.status}\n   *\n   */\n  public readonly statusChanges!: Observable<FormControlStatus>;\n\n  /**\n   * Reports the update strategy of the `AbstractControl` (meaning\n   * the event on which the control updates itself).\n   * Possible values: `'change'` | `'blur'` | `'submit'`\n   * Default value: `'change'`\n   */\n  get updateOn(): FormHooks {\n    return this._updateOn ? this._updateOn : (this.parent ? this.parent.updateOn : 'change');\n  }\n\n  /**\n   * Sets the synchronous validators that are active on this control.  Calling\n   * this overwrites any existing synchronous validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * If you want to add a new validator without affecting existing ones, consider\n   * using `addValidators()` method instead.\n   */\n  setValidators(validators: ValidatorFn|ValidatorFn[]|null): void {\n    this._assignValidators(validators);\n  }\n\n  /**\n   * Sets the asynchronous validators that are active on this control. Calling this\n   * overwrites any existing asynchronous validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * If you want to add a new validator without affecting existing ones, consider\n   * using `addAsyncValidators()` method instead.\n   */\n  setAsyncValidators(validators: AsyncValidatorFn|AsyncValidatorFn[]|null): void {\n    this._assignAsyncValidators(validators);\n  }\n\n  /**\n   * Add a synchronous validator or validators to this control, without affecting other validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * Adding a validator that already exists will have no effect. If duplicate validator functions\n   * are present in the `validators` array, only the first instance would be added to a form\n   * control.\n   *\n   * @param validators The new validator function or functions to add to this control.\n   */\n  addValidators(validators: ValidatorFn|ValidatorFn[]): void {\n    this.setValidators(addValidators(validators, this._rawValidators));\n  }\n\n  /**\n   * Add an asynchronous validator or validators to this control, without affecting other\n   * validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * Adding a validator that already exists will have no effect.\n   *\n   * @param validators The new asynchronous validator function or functions to add to this control.\n   */\n  addAsyncValidators(validators: AsyncValidatorFn|AsyncValidatorFn[]): void {\n    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));\n  }\n\n  /**\n   * Remove a synchronous validator from this control, without affecting other validators.\n   * Validators are compared by function reference; you must pass a reference to the exact same\n   * validator function as the one that was originally set. If a provided validator is not found,\n   * it is ignored.\n   *\n   * @usageNotes\n   *\n   * ### Reference to a ValidatorFn\n   *\n   * ```\n   * // Reference to the RequiredValidator\n   * const ctrl = new FormControl<string | null>('', Validators.required);\n   * ctrl.removeValidators(Validators.required);\n   *\n   * // Reference to anonymous function inside MinValidator\n   * const minValidator = Validators.min(3);\n   * const ctrl = new FormControl<string | null>('', minValidator);\n   * expect(ctrl.hasValidator(minValidator)).toEqual(true)\n   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)\n   *\n   * ctrl.removeValidators(minValidator);\n   * ```\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * @param validators The validator or validators to remove.\n   */\n  removeValidators(validators: ValidatorFn|ValidatorFn[]): void {\n    this.setValidators(removeValidators(validators, this._rawValidators));\n  }\n\n  /**\n   * Remove an asynchronous validator from this control, without affecting other validators.\n   * Validators are compared by function reference; you must pass a reference to the exact same\n   * validator function as the one that was originally set. If a provided validator is not found, it\n   * is ignored.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * @param validators The asynchronous validator or validators to remove.\n   */\n  removeAsyncValidators(validators: AsyncValidatorFn|AsyncValidatorFn[]): void {\n    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));\n  }\n\n  /**\n   * Check whether a synchronous validator function is present on this control. The provided\n   * validator must be a reference to the exact same function that was provided.\n   *\n   * @usageNotes\n   *\n   * ### Reference to a ValidatorFn\n   *\n   * ```\n   * // Reference to the RequiredValidator\n   * const ctrl = new FormControl<number | null>(0, Validators.required);\n   * expect(ctrl.hasValidator(Validators.required)).toEqual(true)\n   *\n   * // Reference to anonymous function inside MinValidator\n   * const minValidator = Validators.min(3);\n   * const ctrl = new FormControl<number | null>(0, minValidator);\n   * expect(ctrl.hasValidator(minValidator)).toEqual(true)\n   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)\n   * ```\n   *\n   * @param validator The validator to check for presence. Compared by function reference.\n   * @returns Whether the provided validator was found on this control.\n   */\n  hasValidator(validator: ValidatorFn): boolean {\n    return hasValidator(this._rawValidators, validator);\n  }\n\n  /**\n   * Check whether an asynchronous validator function is present on this control. The provided\n   * validator must be a reference to the exact same function that was provided.\n   *\n   * @param validator The asynchronous validator to check for presence. Compared by function\n   *     reference.\n   * @returns Whether the provided asynchronous validator was found on this control.\n   */\n  hasAsyncValidator(validator: AsyncValidatorFn): boolean {\n    return hasValidator(this._rawAsyncValidators, validator);\n  }\n\n  /**\n   * Empties out the synchronous validator list.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   */\n  clearValidators(): void {\n    this.validator = null;\n  }\n\n  /**\n   * Empties out the async validator list.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   */\n  clearAsyncValidators(): void {\n    this.asyncValidator = null;\n  }\n\n  /**\n   * Marks the control as `touched`. A control is touched by focus and\n   * blur events that do not change the value.\n   *\n   * @see {@link markAsUntouched()}\n   * @see {@link markAsDirty()}\n   * @see {@link markAsPristine()}\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsTouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as Writable<this>).touched = true;\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsTouched(opts);\n    }\n  }\n\n  /**\n   * Marks the control and all its descendant controls as `touched`.\n   * @see {@link markAsTouched()}\n   */\n  markAllAsTouched(): void {\n    this.markAsTouched({onlySelf: true});\n\n    this._forEachChild((control: AbstractControl) => control.markAllAsTouched());\n  }\n\n  /**\n   * Marks the control as `untouched`.\n   *\n   * If the control has any children, also marks all children as `untouched`\n   * and recalculates the `touched` status of all parent controls.\n   *\n   * @see {@link markAsTouched()}\n   * @see {@link markAsDirty()}\n   * @see {@link markAsPristine()}\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after the marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsUntouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as Writable<this>).touched = false;\n    this._pendingTouched = false;\n\n    this._forEachChild((control: AbstractControl) => {\n      control.markAsUntouched({onlySelf: true});\n    });\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `dirty`. A control becomes dirty when\n   * the control's value is changed through the UI; compare `markAsTouched`.\n   *\n   * @see {@link markAsTouched()}\n   * @see {@link markAsUntouched()}\n   * @see {@link markAsPristine()}\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsDirty(opts: {onlySelf?: boolean} = {}): void {\n    (this as Writable<this>).pristine = false;\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsDirty(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `pristine`.\n   *\n   * If the control has any children, marks all children as `pristine`,\n   * and recalculates the `pristine` status of all parent\n   * controls.\n   *\n   * @see {@link markAsTouched()}\n   * @see {@link markAsUntouched()}\n   * @see {@link markAsDirty()}\n   *\n   * @param opts Configuration options that determine how the control emits events after\n   * marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsPristine(opts: {onlySelf?: boolean} = {}): void {\n    (this as Writable<this>).pristine = true;\n    this._pendingDirty = false;\n\n    this._forEachChild((control: AbstractControl) => {\n      control.markAsPristine({onlySelf: true});\n    });\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `pending`.\n   *\n   * A control is pending while the control performs async validation.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @param opts Configuration options that determine how the control propagates changes and\n   * emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\n   * observable emits an event with the latest status the control is marked pending.\n   * When false, no events are emitted.\n   *\n   */\n  markAsPending(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    (this as Writable<this>).status = PENDING;\n\n    if (opts.emitEvent !== false) {\n      (this.statusChanges as EventEmitter<FormControlStatus>).emit(this.status);\n    }\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsPending(opts);\n    }\n  }\n\n  /**\n   * Disables the control. This means the control is exempt from validation checks and\n   * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n   *\n   * If the control has children, all children are also disabled.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @param opts Configuration options that determine how the control propagates\n   * changes and emits events after the control is disabled.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is disabled.\n   * When false, no events are emitted.\n   */\n  disable(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    // If parent has been marked artificially dirty we don't want to re-calculate the\n    // parent's dirtiness based on the children.\n    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);\n\n    (this as Writable<this>).status = DISABLED;\n    (this as Writable<this>).errors = null;\n    this._forEachChild((control: AbstractControl) => {\n      control.disable({...opts, onlySelf: true});\n    });\n    this._updateValue();\n\n    if (opts.emitEvent !== false) {\n      (this.valueChanges as EventEmitter<TValue>).emit(this.value);\n      (this.statusChanges as EventEmitter<FormControlStatus>).emit(this.status);\n    }\n\n    this._updateAncestors({...opts, skipPristineCheck});\n    this._onDisabledChange.forEach((changeFn) => changeFn(true));\n  }\n\n  /**\n   * Enables the control. This means the control is included in validation checks and\n   * the aggregate value of its parent. Its status recalculates based on its value and\n   * its validators.\n   *\n   * By default, if the control has children, all children are enabled.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @param opts Configure options that control how the control propagates changes and\n   * emits events when marked as untouched\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is enabled.\n   * When false, no events are emitted.\n   */\n  enable(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    // If parent has been marked artificially dirty we don't want to re-calculate the\n    // parent's dirtiness based on the children.\n    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);\n\n    (this as Writable<this>).status = VALID;\n    this._forEachChild((control: AbstractControl) => {\n      control.enable({...opts, onlySelf: true});\n    });\n    this.updateValueAndValidity({onlySelf: true, emitEvent: opts.emitEvent});\n\n    this._updateAncestors({...opts, skipPristineCheck});\n    this._onDisabledChange.forEach((changeFn) => changeFn(false));\n  }\n\n  private _updateAncestors(\n      opts: {onlySelf?: boolean, emitEvent?: boolean, skipPristineCheck?: boolean}): void {\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n      if (!opts.skipPristineCheck) {\n        this._parent._updatePristine();\n      }\n      this._parent._updateTouched();\n    }\n  }\n\n  /**\n   * Sets the parent of the control\n   *\n   * @param parent The new parent.\n   */\n  setParent(parent: FormGroup|FormArray|null): void {\n    this._parent = parent;\n  }\n\n  /**\n   * Sets the value of the control. Abstract method (implemented in sub-classes).\n   */\n  abstract setValue(value: TRawValue, options?: Object): void;\n\n  /**\n   * Patches the value of the control. Abstract method (implemented in sub-classes).\n   */\n  abstract patchValue(value: TValue, options?: Object): void;\n\n  /**\n   * Resets the control. Abstract method (implemented in sub-classes).\n   */\n  abstract reset(value?: TValue, options?: Object): void;\n\n  /**\n   * The raw value of this control. For most control implementations, the raw value will include\n   * disabled children.\n   */\n  getRawValue(): any {\n    return this.value;\n  }\n\n  /**\n   * Recalculates the value and validation status of the control.\n   *\n   * By default, it also updates the value and validity of its ancestors.\n   *\n   * @param opts Configuration options determine how the control propagates changes and emits events\n   * after updates and validity checks are applied.\n   * * `onlySelf`: When true, only update this control. When false or not supplied,\n   * update all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is updated.\n   * When false, no events are emitted.\n   */\n  updateValueAndValidity(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._setInitialStatus();\n    this._updateValue();\n\n    if (this.enabled) {\n      this._cancelExistingSubscription();\n      (this as Writable<this>).errors = this._runValidator();\n      (this as Writable<this>).status = this._calculateStatus();\n\n      if (this.status === VALID || this.status === PENDING) {\n        this._runAsyncValidator(opts.emitEvent);\n      }\n    }\n\n    if (opts.emitEvent !== false) {\n      (this.valueChanges as EventEmitter<TValue>).emit(this.value);\n      (this.statusChanges as EventEmitter<FormControlStatus>).emit(this.status);\n    }\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n    }\n  }\n\n  /** @internal */\n  _updateTreeValidity(opts: {emitEvent?: boolean} = {emitEvent: true}): void {\n    this._forEachChild((ctrl: AbstractControl) => ctrl._updateTreeValidity(opts));\n    this.updateValueAndValidity({onlySelf: true, emitEvent: opts.emitEvent});\n  }\n\n  private _setInitialStatus() {\n    (this as Writable<this>).status = this._allControlsDisabled() ? DISABLED : VALID;\n  }\n\n  private _runValidator(): ValidationErrors|null {\n    return this.validator ? this.validator(this) : null;\n  }\n\n  private _runAsyncValidator(emitEvent?: boolean): void {\n    if (this.asyncValidator) {\n      (this as Writable<this>).status = PENDING;\n      this._hasOwnPendingAsyncValidator = true;\n      const obs = toObservable(this.asyncValidator(this));\n      this._asyncValidationSubscription = obs.subscribe((errors: ValidationErrors|null) => {\n        this._hasOwnPendingAsyncValidator = false;\n        // This will trigger the recalculation of the validation status, which depends on\n        // the state of the asynchronous validation (whether it is in progress or not). So, it is\n        // necessary that we have updated the `_hasOwnPendingAsyncValidator` boolean flag first.\n        this.setErrors(errors, {emitEvent});\n      });\n    }\n  }\n\n  private _cancelExistingSubscription(): void {\n    if (this._asyncValidationSubscription) {\n      this._asyncValidationSubscription.unsubscribe();\n      this._hasOwnPendingAsyncValidator = false;\n    }\n  }\n\n  /**\n   * Sets errors on a form control when running validations manually, rather than automatically.\n   *\n   * Calling `setErrors` also updates the validity of the parent control.\n   *\n   * @param opts Configuration options that determine how the control propagates\n   * changes and emits events after the control errors are set.\n   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\n   * observable emits an event after the errors are set.\n   *\n   * @usageNotes\n   *\n   * ### Manually set the errors for a control\n   *\n   * ```\n   * const login = new FormControl('someLogin');\n   * login.setErrors({\n   *   notUnique: true\n   * });\n   *\n   * expect(login.valid).toEqual(false);\n   * expect(login.errors).toEqual({ notUnique: true });\n   *\n   * login.setValue('someOtherLogin');\n   *\n   * expect(login.valid).toEqual(true);\n   * ```\n   */\n  setErrors(errors: ValidationErrors|null, opts: {emitEvent?: boolean} = {}): void {\n    (this as Writable<this>).errors = errors;\n    this._updateControlsErrors(opts.emitEvent !== false);\n  }\n\n  /**\n   * Retrieves a child control given the control's name or path.\n   *\n   * This signature for get supports strings and `const` arrays (`.get(['foo', 'bar'] as const)`).\n   */\n  get<P extends string|(readonly(string|number)[])>(path: P):\n      AbstractControl<GetProperty<TRawValue, P>>|null;\n\n  /**\n   * Retrieves a child control given the control's name or path.\n   *\n   * This signature for `get` supports non-const (mutable) arrays. Inferred type\n   * information will not be as robust, so prefer to pass a `readonly` array if possible.\n   */\n  get<P extends string|Array<string|number>>(path: P):\n      AbstractControl<GetProperty<TRawValue, P>>|null;\n\n  /**\n   * Retrieves a child control given the control's name or path.\n   *\n   * @param path A dot-delimited string or array of string/number values that define the path to the\n   * control. If a string is provided, passing it as a string literal will result in improved type\n   * information. Likewise, if an array is provided, passing it `as const` will cause improved type\n   * information to be available.\n   *\n   * @usageNotes\n   * ### Retrieve a nested control\n   *\n   * For example, to get a `name` control nested within a `person` sub-group:\n   *\n   * * `this.form.get('person.name');`\n   *\n   * -OR-\n   *\n   * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings\n   *\n   * ### Retrieve a control in a FormArray\n   *\n   * When accessing an element inside a FormArray, you can use an element index.\n   * For example, to get a `price` control from the first element in an `items` array you can use:\n   *\n   * * `this.form.get('items.0.price');`\n   *\n   * -OR-\n   *\n   * * `this.form.get(['items', 0, 'price']);`\n   */\n  get<P extends string|((string | number)[])>(path: P):\n      AbstractControl<GetProperty<TRawValue, P>>|null {\n    let currPath: Array<string|number>|string = path;\n    if (currPath == null) return null;\n    if (!Array.isArray(currPath)) currPath = currPath.split('.');\n    if (currPath.length === 0) return null;\n    return currPath.reduce(\n        (control: AbstractControl|null, name) => control && control._find(name), this);\n  }\n\n  /**\n   * @description\n   * Reports error data for the control with the given path.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * @returns error data for that particular error. If the control or error is not present,\n   * null is returned.\n   */\n  getError(errorCode: string, path?: Array<string|number>|string): any {\n    const control = path ? this.get(path) : this;\n    return control && control.errors ? control.errors[errorCode] : null;\n  }\n\n  /**\n   * @description\n   * Reports whether the control with the given path has the error specified.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * If no path is given, this method checks for the error on the current control.\n   *\n   * @returns whether the given error is present in the control at the given path.\n   *\n   * If the control is not present, false is returned.\n   */\n  hasError(errorCode: string, path?: Array<string|number>|string): boolean {\n    return !!this.getError(errorCode, path);\n  }\n\n  /**\n   * Retrieves the top-level ancestor of this control.\n   */\n  get root(): AbstractControl {\n    let x: AbstractControl = this;\n\n    while (x._parent) {\n      x = x._parent;\n    }\n\n    return x;\n  }\n\n  /** @internal */\n  _updateControlsErrors(emitEvent: boolean): void {\n    (this as Writable<this>).status = this._calculateStatus();\n\n    if (emitEvent) {\n      (this.statusChanges as EventEmitter<FormControlStatus>).emit(this.status);\n    }\n\n    if (this._parent) {\n      this._parent._updateControlsErrors(emitEvent);\n    }\n  }\n\n  /** @internal */\n  _initObservables() {\n    (this as Writable<this>).valueChanges = new EventEmitter();\n    (this as Writable<this>).statusChanges = new EventEmitter();\n  }\n\n\n  private _calculateStatus(): FormControlStatus {\n    if (this._allControlsDisabled()) return DISABLED;\n    if (this.errors) return INVALID;\n    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;\n    if (this._anyControlsHaveStatus(INVALID)) return INVALID;\n    return VALID;\n  }\n\n  /** @internal */\n  abstract _updateValue(): void;\n\n  /** @internal */\n  abstract _forEachChild(cb: (c: AbstractControl) => void): void;\n\n  /** @internal */\n  abstract _anyControls(condition: (c: AbstractControl) => boolean): boolean;\n\n  /** @internal */\n  abstract _allControlsDisabled(): boolean;\n\n  /** @internal */\n  abstract _syncPendingControls(): boolean;\n\n  /** @internal */\n  _anyControlsHaveStatus(status: FormControlStatus): boolean {\n    return this._anyControls((control: AbstractControl) => control.status === status);\n  }\n\n  /** @internal */\n  _anyControlsDirty(): boolean {\n    return this._anyControls((control: AbstractControl) => control.dirty);\n  }\n\n  /** @internal */\n  _anyControlsTouched(): boolean {\n    return this._anyControls((control: AbstractControl) => control.touched);\n  }\n\n  /** @internal */\n  _updatePristine(opts: {onlySelf?: boolean} = {}): void {\n    (this as Writable<this>).pristine = !this._anyControlsDirty();\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts);\n    }\n  }\n\n  /** @internal */\n  _updateTouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as Writable<this>).touched = this._anyControlsTouched();\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts);\n    }\n  }\n\n  /** @internal */\n  _onDisabledChange: Array<(isDisabled: boolean) => void> = [];\n\n  /** @internal */\n  _registerOnCollectionChange(fn: () => void): void {\n    this._onCollectionChange = fn;\n  }\n\n  /** @internal */\n  _setUpdateStrategy(opts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null): void {\n    if (isOptionsObj(opts) && opts.updateOn != null) {\n      this._updateOn = opts.updateOn!;\n    }\n  }\n  /**\n   * Check to see if parent has been marked artificially dirty.\n   *\n   * @internal\n   */\n  private _parentMarkedDirty(onlySelf?: boolean): boolean {\n    const parentDirty = this._parent && this._parent.dirty;\n    return !onlySelf && !!parentDirty && !this._parent!._anyControlsDirty();\n  }\n\n  /** @internal */\n  _find(name: string|number): AbstractControl|null {\n    return null;\n  }\n\n  /**\n   * Internal implementation of the `setValidators` method. Needs to be separated out into a\n   * different method, because it is called in the constructor and it can break cases where\n   * a control is extended.\n   */\n  private _assignValidators(validators: ValidatorFn|ValidatorFn[]|null): void {\n    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;\n    this._composedValidatorFn = coerceToValidator(this._rawValidators);\n  }\n\n  /**\n   * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a\n   * different method, because it is called in the constructor and it can break cases where\n   * a control is extended.\n   */\n  private _assignAsyncValidators(validators: AsyncValidatorFn|AsyncValidatorFn[]|null): void {\n    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;\n    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Writable as Writable} from '@angular/core';\n\nimport {AsyncValidatorFn, ValidatorFn} from '../directives/validators';\n\nimport {AbstractControl, AbstractControlOptions, assertAllValuesPresent, assertControlPresent, pickAsyncValidators, pickValidators, RawValue, TypedOrUntyped, Value} from './abstract_model';\n\n/**\n * FormGroupValue extracts the type of `.value` from a FormGroup's inner object type. The untyped\n * case falls back to {[key: string]: any}.\n *\n * Angular uses this type internally to support Typed Forms; do not use it directly.\n *\n * For internal use only.\n */\nexport type FormGroupValue<T extends {[K in keyof T]?: AbstractControl<any>}> =\n    TypedOrUntyped<T, Partial<{[K in keyof T]: Value<T[K]>}>, {[key: string]: any}>;\n\n/**\n * FormGroupRawValue extracts the type of `.getRawValue()` from a FormGroup's inner object type. The\n * untyped case falls back to {[key: string]: any}.\n *\n * Angular uses this type internally to support Typed Forms; do not use it directly.\n *\n * For internal use only.\n */\nexport type FormGroupRawValue<T extends {[K in keyof T]?: AbstractControl<any>}> =\n    TypedOrUntyped<T, {[K in keyof T]: RawValue<T[K]>}, {[key: string]: any}>;\n\n/**\n * OptionalKeys returns the union of all optional keys in the object.\n *\n * Angular uses this type internally to support Typed Forms; do not use it directly.\n */\nexport type OptionalKeys<T> = {\n  [K in keyof T] -?: undefined extends T[K] ? K : never\n}[keyof T];\n\n/**\n * Tracks the value and validity state of a group of `FormControl` instances.\n *\n * A `FormGroup` aggregates the values of each child `FormControl` into one object,\n * with each control name as the key.  It calculates its status by reducing the status values\n * of its children. For example, if one of the controls in a group is invalid, the entire\n * group becomes invalid.\n *\n * `FormGroup` is one of the four fundamental building blocks used to define forms in Angular,\n * along with `FormControl`, `FormArray`, and `FormRecord`.\n *\n * When instantiating a `FormGroup`, pass in a collection of child controls as the first\n * argument. The key for each child registers the name for the control.\n *\n * `FormGroup` is intended for use cases where the keys are known ahead of time.\n * If you need to dynamically add and remove controls, use {@link FormRecord} instead.\n *\n * `FormGroup` accepts an optional type parameter `TControl`, which is an object type with inner\n * control types as values.\n *\n * @usageNotes\n *\n * ### Create a form group with 2 controls\n *\n * ```\n * const form = new FormGroup({\n *   first: new FormControl('Nancy', Validators.minLength(2)),\n *   last: new FormControl('Drew'),\n * });\n *\n * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\n * console.log(form.status);  // 'VALID'\n * ```\n *\n * ### The type argument, and optional controls\n *\n * `FormGroup` accepts one generic argument, which is an object containing its inner controls.\n * This type will usually be inferred automatically, but you can always specify it explicitly if you\n * wish.\n *\n * If you have controls that are optional (i.e. they can be removed, you can use the `?` in the\n * type):\n *\n * ```\n * const form = new FormGroup<{\n *   first: FormControl<string|null>,\n *   middle?: FormControl<string|null>, // Middle name is optional.\n *   last: FormControl<string|null>,\n * }>({\n *   first: new FormControl('Nancy'),\n *   last: new FormControl('Drew'),\n * });\n * ```\n *\n * ### Create a form group with a group-level validator\n *\n * You include group-level validators as the second arg, or group-level async\n * validators as the third arg. These come in handy when you want to perform validation\n * that considers the value of more than one child control.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('', Validators.minLength(2)),\n *   passwordConfirm: new FormControl('', Validators.minLength(2)),\n * }, passwordMatchValidator);\n *\n *\n * function passwordMatchValidator(g: FormGroup) {\n *    return g.get('password').value === g.get('passwordConfirm').value\n *       ? null : {'mismatch': true};\n * }\n * ```\n *\n * Like `FormControl` instances, you choose to pass in\n * validators and async validators as part of an options object.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('')\n *   passwordConfirm: new FormControl('')\n * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });\n * ```\n *\n * ### Set the updateOn property for all controls in a form group\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * group level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const c = new FormGroup({\n *   one: new FormControl()\n * }, { updateOn: 'blur' });\n * ```\n *\n * ### Using a FormGroup with optional controls\n *\n * It is possible to have optional controls in a FormGroup. An optional control can be removed later\n * using `removeControl`, and can be omitted when calling `reset`. Optional controls must be\n * declared optional in the group's type.\n *\n * ```ts\n * const c = new FormGroup<{one?: FormControl<string>}>({\n *   one: new FormControl('')\n * });\n * ```\n *\n * Notice that `c.value.one` has type `string|null|undefined`. This is because calling `c.reset({})`\n * without providing the optional key `one` will cause it to become `null`.\n *\n * @publicApi\n */\nexport class FormGroup<TControl extends {[K in keyof TControl]: AbstractControl<any>} = any> extends\n    AbstractControl<\n        TypedOrUntyped<TControl, FormGroupValue<TControl>, any>,\n        TypedOrUntyped<TControl, FormGroupRawValue<TControl>, any>> {\n  /**\n   * Creates a new `FormGroup` instance.\n   *\n   * @param controls A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   */\n  constructor(\n      controls: TControl, validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    (typeof ngDevMode === 'undefined' || ngDevMode) && validateFormGroupControls(controls);\n    this.controls = controls;\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,\n      // so we set `emitEvent` to `true` to allow that during the control creation process.\n      emitEvent: !!this.asyncValidator\n    });\n  }\n\n  public controls: TypedOrUntyped<TControl, TControl, {[key: string]: AbstractControl<any>}>;\n\n  /**\n   * Registers a control with the group's list of controls. In a strongly-typed group, the control\n   * must be in the group's type (possibly as an optional key).\n   *\n   * This method does not update the value or validity of the control.\n   * Use {@link FormGroup#addControl addControl} instead.\n   *\n   * @param name The control name to register in the collection\n   * @param control Provides the control for the given name\n   */\n  registerControl<K extends string&keyof TControl>(name: K, control: TControl[K]): TControl[K];\n  registerControl(\n      this: FormGroup<{[key: string]: AbstractControl<any>}>, name: string,\n      control: AbstractControl<any>): AbstractControl<any>;\n\n  registerControl<K extends string&keyof TControl>(name: K, control: TControl[K]): TControl[K] {\n    if (this.controls[name]) return (this.controls as any)[name];\n    this.controls[name] = control;\n    control.setParent(this as FormGroup);\n    control._registerOnCollectionChange(this._onCollectionChange);\n    return control;\n  }\n\n  /**\n   * Add a control to this group. In a strongly-typed group, the control must be in the group's type\n   * (possibly as an optional key).\n   *\n   * If a control with a given name already exists, it would *not* be replaced with a new one.\n   * If you want to replace an existing control, use the {@link FormGroup#setControl setControl}\n   * method instead. This method also updates the value and validity of the control.\n   *\n   * @param name The control name to add to the collection\n   * @param control Provides the control for the given name\n   * @param options Specifies whether this FormGroup instance should emit events after a new\n   *     control is added.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * added. When false, no events are emitted.\n   */\n  addControl(\n      this: FormGroup<{[key: string]: AbstractControl<any>}>, name: string,\n      control: AbstractControl, options?: {emitEvent?: boolean}): void;\n  addControl<K extends string&keyof TControl>(name: K, control: Required<TControl>[K], options?: {\n    emitEvent?: boolean\n  }): void;\n\n  addControl<K extends string&keyof TControl>(name: K, control: Required<TControl>[K], options: {\n    emitEvent?: boolean\n  } = {}): void {\n    this.registerControl(name, control);\n    this.updateValueAndValidity({emitEvent: options.emitEvent});\n    this._onCollectionChange();\n  }\n\n  removeControl(this: FormGroup<{[key: string]: AbstractControl<any>}>, name: string, options?: {\n    emitEvent?: boolean;\n  }): void;\n  removeControl<S extends string>(name: OptionalKeys<TControl>&S, options?: {\n    emitEvent?: boolean;\n  }): void;\n\n  /**\n   * Remove a control from this group. In a strongly-typed group, required controls cannot be\n   * removed.\n   *\n   * This method also updates the value and validity of the control.\n   *\n   * @param name The control name to remove from the collection\n   * @param options Specifies whether this FormGroup instance should emit events after a\n   *     control is removed.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * removed. When false, no events are emitted.\n   */\n  removeControl(name: string, options: {emitEvent?: boolean;} = {}): void {\n    if ((this.controls as any)[name])\n      (this.controls as any)[name]._registerOnCollectionChange(() => {});\n    delete ((this.controls as any)[name]);\n    this.updateValueAndValidity({emitEvent: options.emitEvent});\n    this._onCollectionChange();\n  }\n\n  /**\n   * Replace an existing control. In a strongly-typed group, the control must be in the group's type\n   * (possibly as an optional key).\n   *\n   * If a control with a given name does not exist in this `FormGroup`, it will be added.\n   *\n   * @param name The control name to replace in the collection\n   * @param control Provides the control for the given name\n   * @param options Specifies whether this FormGroup instance should emit events after an\n   *     existing control is replaced.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * replaced with a new one. When false, no events are emitted.\n   */\n  setControl<K extends string&keyof TControl>(name: K, control: TControl[K], options?: {\n    emitEvent?: boolean\n  }): void;\n  setControl(\n      this: FormGroup<{[key: string]: AbstractControl<any>}>, name: string,\n      control: AbstractControl, options?: {emitEvent?: boolean}): void;\n\n  setControl<K extends string&keyof TControl>(name: K, control: TControl[K], options: {\n    emitEvent?: boolean\n  } = {}): void {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete (this.controls[name]);\n    if (control) this.registerControl(name, control);\n    this.updateValueAndValidity({emitEvent: options.emitEvent});\n    this._onCollectionChange();\n  }\n\n  /**\n   * Check whether there is an enabled control with the given name in the group.\n   *\n   * Reports false for disabled controls. If you'd like to check for existence in the group\n   * only, use {@link AbstractControl#get get} instead.\n   *\n   * @param controlName The control name to check for existence in the collection\n   *\n   * @returns false for disabled controls, true otherwise.\n   */\n  contains<K extends string>(controlName: K): boolean;\n  contains(this: FormGroup<{[key: string]: AbstractControl<any>}>, controlName: string): boolean;\n\n  contains<K extends string&keyof TControl>(controlName: K): boolean {\n    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;\n  }\n\n  /**\n   * Sets the value of the `FormGroup`. It accepts an object that matches\n   * the structure of the group, with control names as keys.\n   *\n   * @usageNotes\n   * ### Set the complete value for the form group\n   *\n   * ```\n   * const form = new FormGroup({\n   *   first: new FormControl(),\n   *   last: new FormControl()\n   * });\n   *\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.setValue({first: 'Nancy', last: 'Drew'});\n   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n   * ```\n   *\n   * @throws When strict checks fail, such as setting the value of a control\n   * that doesn't exist or if you exclude a value of a control that does exist.\n   *\n   * @param value The new value for the control that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   */\n  override setValue(value: FormGroupRawValue<TControl>, options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean\n  } = {}): void {\n    assertAllValuesPresent(this, true, value);\n    (Object.keys(value) as Array<keyof TControl>).forEach(name => {\n      assertControlPresent(this, true, name as any);\n      (this.controls as any)[name].setValue(\n          (value as any)[name], {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of the `FormGroup`. It accepts an object with control\n   * names as keys, and does its best to match the values to the correct controls\n   * in the group.\n   *\n   * It accepts both super-sets and sub-sets of the group without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the value for a form group\n   *\n   * ```\n   * const form = new FormGroup({\n   *    first: new FormControl(),\n   *    last: new FormControl()\n   * });\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.patchValue({first: 'Nancy'});\n   * console.log(form.value);   // {first: 'Nancy', last: null}\n   * ```\n   *\n   * @param value The object that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes and\n   * emits events after the value is patched.\n   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n   * true.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control value\n   * is updated. When false, no events are emitted. The configuration options are passed to\n   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n   */\n  override patchValue(value: FormGroupValue<TControl>, options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean\n  } = {}): void {\n    // Even though the `value` argument type doesn't allow `null` and `undefined` values, the\n    // `patchValue` can be called recursively and inner data structures might have these values, so\n    // we just ignore such cases when a field containing FormGroup instance receives `null` or\n    // `undefined` as a value.\n    if (value == null /* both `null` and `undefined` */) return;\n    (Object.keys(value) as Array<keyof TControl>).forEach(name => {\n      // The compiler cannot see through the uninstantiated conditional type of `this.controls`, so\n      // `as any` is required.\n      const control = (this.controls as any)[name];\n      if (control) {\n        control.patchValue(\n            /* Guaranteed to be present, due to the outer forEach. */ value\n                [name as keyof FormGroupValue<TControl>]!,\n            {onlySelf: true, emitEvent: options.emitEvent});\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets\n   * the value of all descendants to their default values, or null if no defaults were provided.\n   *\n   * You reset to a specific form state by passing in a map of states\n   * that matches the structure of your form, with control names as keys. The state\n   * is a standalone value or a form state object with both a value and a disabled\n   * status.\n   *\n   * @param value Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events when the group is reset.\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * @usageNotes\n   *\n   * ### Reset the form group values\n   *\n   * ```ts\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * console.log(form.value);  // {first: 'first name', last: 'last name'}\n   *\n   * form.reset({ first: 'name', last: 'last name' });\n   *\n   * console.log(form.value);  // {first: 'name', last: 'last name'}\n   * ```\n   *\n   * ### Reset the form group values and disabled status\n   *\n   * ```\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * form.reset({\n   *   first: {value: 'name', disabled: true},\n   *   last: 'last'\n   * });\n   *\n   * console.log(form.value);  // {last: 'last'}\n   * console.log(form.get('first').status);  // 'DISABLED'\n   * ```\n   */\n  override reset(\n      value: TypedOrUntyped<TControl, FormGroupValue<TControl>, any> = {} as unknown as\n          FormGroupValue<TControl>,\n      options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._forEachChild((control: AbstractControl, name) => {\n      control.reset(\n          value ? (value as any)[name] : null, {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this._updatePristine(options);\n    this._updateTouched(options);\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * The aggregate value of the `FormGroup`, including any disabled controls.\n   *\n   * Retrieves all values regardless of disabled status.\n   */\n  override getRawValue(): TypedOrUntyped<TControl, FormGroupRawValue<TControl>, any> {\n    return this._reduceChildren({}, (acc, control, name) => {\n      (acc as any)[name] = (control as any).getRawValue();\n      return acc;\n    }) as any;\n  }\n\n  /** @internal */\n  override _syncPendingControls(): boolean {\n    let subtreeUpdated = this._reduceChildren(false, (updated: boolean, child) => {\n      return child._syncPendingControls() ? true : updated;\n    });\n    if (subtreeUpdated) this.updateValueAndValidity({onlySelf: true});\n    return subtreeUpdated;\n  }\n\n  /** @internal */\n  override _forEachChild(cb: (v: any, k: any) => void): void {\n    Object.keys(this.controls).forEach(key => {\n      // The list of controls can change (for ex. controls might be removed) while the loop\n      // is running (as a result of invoking Forms API in `valueChanges` subscription), so we\n      // have to null check before invoking the callback.\n      const control = (this.controls as any)[key];\n      control && cb(control, key);\n    });\n  }\n\n  /** @internal */\n  _setUpControls(): void {\n    this._forEachChild((control) => {\n      control.setParent(this);\n      control._registerOnCollectionChange(this._onCollectionChange);\n    });\n  }\n\n  /** @internal */\n  override _updateValue(): void {\n    (this as Writable<this>).value = this._reduceValue() as any;\n  }\n\n  /** @internal */\n  override _anyControls(condition: (c: AbstractControl) => boolean): boolean {\n    for (const [controlName, control] of Object.entries(this.controls)) {\n      if (this.contains(controlName as any) && condition(control as any)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** @internal */\n  _reduceValue(): Partial<TControl> {\n    let acc: Partial<TControl> = {};\n    return this._reduceChildren(acc, (acc, control, name) => {\n      if (control.enabled || this.disabled) {\n        acc[name] = control.value;\n      }\n      return acc;\n    });\n  }\n\n  /** @internal */\n  _reduceChildren<T, K extends keyof TControl>(\n      initValue: T, fn: (acc: T, control: TControl[K], name: K) => T): T {\n    let res = initValue;\n    this._forEachChild((control: TControl[K], name: K) => {\n      res = fn(res, control, name);\n    });\n    return res;\n  }\n\n  /** @internal */\n  override _allControlsDisabled(): boolean {\n    for (const controlName of (Object.keys(this.controls) as Array<keyof TControl>)) {\n      if ((this.controls as any)[controlName].enabled) {\n        return false;\n      }\n    }\n    return Object.keys(this.controls).length > 0 || this.disabled;\n  }\n\n  /** @internal */\n  override _find(name: string|number): AbstractControl|null {\n    return this.controls.hasOwnProperty(name as string) ?\n        (this.controls as any)[name as keyof TControl] :\n        null;\n  }\n}\n\n/**\n * Will validate that none of the controls has a key with a dot\n * Throws other wise\n */\nfunction validateFormGroupControls<TControl>(\n    controls: {[K in keyof TControl]: AbstractControl<any, any>;}) {\n  const invalidKeys = Object.keys(controls).filter(key => key.includes('.'));\n  if (invalidKeys.length > 0) {\n    // TODO: make this an error once there are no more uses in G3\n    console.warn(`FormGroup keys cannot include \\`.\\`, please replace the keys for: ${\n        invalidKeys.join(',')}.`);\n  }\n}\n\n\ninterface UntypedFormGroupCtor {\n  new(controls: {[key: string]: AbstractControl},\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): UntypedFormGroup;\n\n  /**\n   * The presence of an explicit `prototype` property provides backwards-compatibility for apps that\n   * manually inspect the prototype chain.\n   */\n  prototype: FormGroup<any>;\n}\n\n/**\n * UntypedFormGroup is a non-strongly-typed version of `FormGroup`.\n */\nexport type UntypedFormGroup = FormGroup<any>;\n\nexport const UntypedFormGroup: UntypedFormGroupCtor = FormGroup;\n\n/**\n * @description\n * Asserts that the given control is an instance of `FormGroup`\n *\n * @publicApi\n */\nexport const isFormGroup = (control: unknown): control is FormGroup => control instanceof FormGroup;\n\n/**\n * Tracks the value and validity state of a collection of `FormControl` instances, each of which has\n * the same value type.\n *\n * `FormRecord` is very similar to {@link FormGroup}, except it can be used with a dynamic keys,\n * with controls added and removed as needed.\n *\n * `FormRecord` accepts one generic argument, which describes the type of the controls it contains.\n *\n * @usageNotes\n *\n * ```\n * let numbers = new FormRecord({bill: new FormControl('415-123-456')});\n * numbers.addControl('bob', new FormControl('415-234-567'));\n * numbers.removeControl('bill');\n * ```\n *\n * @publicApi\n */\nexport class FormRecord<TControl extends AbstractControl = AbstractControl> extends\n    FormGroup<{[key: string]: TControl}> {}\n\nexport interface FormRecord<TControl> {\n  /**\n   * Registers a control with the records's list of controls.\n   *\n   * See `FormGroup#registerControl` for additional information.\n   */\n  registerControl(name: string, control: TControl): TControl;\n\n  /**\n   * Add a control to this group.\n   *\n   * See `FormGroup#addControl` for additional information.\n   */\n  addControl(name: string, control: TControl, options?: {emitEvent?: boolean}): void;\n\n  /**\n   * Remove a control from this group.\n   *\n   * See `FormGroup#removeControl` for additional information.\n   */\n  removeControl(name: string, options?: {emitEvent?: boolean}): void;\n\n  /**\n   * Replace an existing control.\n   *\n   * See `FormGroup#setControl` for additional information.\n   */\n  setControl(name: string, control: TControl, options?: {emitEvent?: boolean}): void;\n\n  /**\n   * Check whether there is an enabled control with the given name in the group.\n   *\n   * See `FormGroup#contains` for additional information.\n   */\n  contains(controlName: string): boolean;\n\n  /**\n   * Sets the value of the `FormRecord`. It accepts an object that matches\n   * the structure of the group, with control names as keys.\n   *\n   * See `FormGroup#setValue` for additional information.\n   */\n  setValue(value: {[key: string]: Value<TControl>}, options?: {\n    onlySelf?: boolean,\n    emitEvent?: boolean\n  }): void;\n\n  /**\n   * Patches the value of the `FormRecord`. It accepts an object with control\n   * names as keys, and does its best to match the values to the correct controls\n   * in the group.\n   *\n   * See `FormGroup#patchValue` for additional information.\n   */\n  patchValue(value: {[key: string]: Value<TControl>}, options?: {\n    onlySelf?: boolean,\n    emitEvent?: boolean\n  }): void;\n\n  /**\n   * Resets the `FormRecord`, marks all descendants `pristine` and `untouched` and sets\n   * the value of all descendants to null.\n   *\n   * See `FormGroup#reset` for additional information.\n   */\n  reset(value?: {[key: string]: Value<TControl>}, options?: {\n    onlySelf?: boolean,\n    emitEvent?: boolean\n  }): void;\n\n  /**\n   * The aggregate value of the `FormRecord`, including any disabled controls.\n   *\n   * See `FormGroup#getRawValue` for additional information.\n   */\n  getRawValue(): {[key: string]: RawValue<TControl>};\n}\n\n/**\n * @description\n * Asserts that the given control is an instance of `FormRecord`\n *\n * @publicApi\n */\nexport const isFormRecord = (control: unknown): control is FormRecord =>\n    control instanceof FormRecord;\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Inject, InjectionToken, RuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\nimport {AbstractControl} from '../model/abstract_model';\nimport {FormArray} from '../model/form_array';\nimport {FormControl} from '../model/form_control';\nimport {FormGroup} from '../model/form_group';\nimport {getControlAsyncValidators, getControlValidators, mergeValidators} from '../validators';\n\nimport {AbstractControlDirective} from './abstract_control_directive';\nimport {AbstractFormGroupDirective} from './abstract_form_group_directive';\nimport {ControlContainer} from './control_container';\nimport {BuiltInControlValueAccessor, ControlValueAccessor} from './control_value_accessor';\nimport {DefaultValueAccessor} from './default_value_accessor';\nimport {NgControl} from './ng_control';\nimport {FormArrayName} from './reactive_directives/form_group_name';\nimport {ngModelWarning} from './reactive_errors';\nimport {AsyncValidatorFn, Validator, ValidatorFn} from './validators';\n\n/**\n * Token to provide to allow SetDisabledState to always be called when a CVA is added, regardless of\n * whether the control is disabled or enabled.\n *\n * @see {@link FormsModule#withconfig}\n */\nexport const CALL_SET_DISABLED_STATE = new InjectionToken(\n    'CallSetDisabledState', {providedIn: 'root', factory: () => setDisabledStateDefault});\n\n/**\n * The type for CALL_SET_DISABLED_STATE. If `always`, then ControlValueAccessor will always call\n * `setDisabledState` when attached, which is the most correct behavior. Otherwise, it will only be\n * called when disabled, which is the legacy behavior for compatibility.\n *\n * @publicApi\n * @see {@link FormsModule#withconfig}\n */\nexport type SetDisabledStateOption = 'whenDisabledForLegacyCode'|'always';\n\n/**\n * Whether to use the fixed setDisabledState behavior by default.\n */\nexport const setDisabledStateDefault: SetDisabledStateOption = 'always';\n\nexport function controlPath(name: string|null, parent: ControlContainer): string[] {\n  return [...parent.path!, name!];\n}\n\n/**\n * Links a Form control and a Form directive by setting up callbacks (such as `onChange`) on both\n * instances. This function is typically invoked when form directive is being initialized.\n *\n * @param control Form control instance that should be linked.\n * @param dir Directive that should be linked with a given control.\n */\nexport function setUpControl(\n    control: FormControl, dir: NgControl,\n    callSetDisabledState: SetDisabledStateOption = setDisabledStateDefault): void {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (!control) _throwError(dir, 'Cannot find control with');\n    if (!dir.valueAccessor) _throwMissingValueAccessorError(dir);\n  }\n\n  setUpValidators(control, dir);\n\n  dir.valueAccessor!.writeValue(control.value);\n\n  // The legacy behavior only calls the CVA's `setDisabledState` if the control is disabled.\n  // If the `callSetDisabledState` option is set to `always`, then this bug is fixed and\n  // the method is always called.\n  if (control.disabled || callSetDisabledState === 'always') {\n    dir.valueAccessor!.setDisabledState?.(control.disabled);\n  }\n\n  setUpViewChangePipeline(control, dir);\n  setUpModelChangePipeline(control, dir);\n\n  setUpBlurPipeline(control, dir);\n\n  setUpDisabledChangeHandler(control, dir);\n}\n\n/**\n * Reverts configuration performed by the `setUpControl` control function.\n * Effectively disconnects form control with a given form directive.\n * This function is typically invoked when corresponding form directive is being destroyed.\n *\n * @param control Form control which should be cleaned up.\n * @param dir Directive that should be disconnected from a given control.\n * @param validateControlPresenceOnChange Flag that indicates whether onChange handler should\n *     contain asserts to verify that it's not called once directive is destroyed. We need this flag\n *     to avoid potentially breaking changes caused by better control cleanup introduced in #39235.\n */\nexport function cleanUpControl(\n    control: FormControl|null, dir: NgControl,\n    validateControlPresenceOnChange: boolean = true): void {\n  const noop = () => {\n    if (validateControlPresenceOnChange && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      _noControlError(dir);\n    }\n  };\n\n  // The `valueAccessor` field is typically defined on FromControl and FormControlName directive\n  // instances and there is a logic in `selectValueAccessor` function that throws if it's not the\n  // case. We still check the presence of `valueAccessor` before invoking its methods to make sure\n  // that cleanup works correctly if app code or tests are setup to ignore the error thrown from\n  // `selectValueAccessor`. See https://github.com/angular/angular/issues/40521.\n  if (dir.valueAccessor) {\n    dir.valueAccessor.registerOnChange(noop);\n    dir.valueAccessor.registerOnTouched(noop);\n  }\n\n  cleanUpValidators(control, dir);\n\n  if (control) {\n    dir._invokeOnDestroyCallbacks();\n    control._registerOnCollectionChange(() => {});\n  }\n}\n\nfunction registerOnValidatorChange<V>(validators: (V|Validator)[], onChange: () => void): void {\n  validators.forEach((validator: V|Validator) => {\n    if ((<Validator>validator).registerOnValidatorChange)\n      (<Validator>validator).registerOnValidatorChange!(onChange);\n  });\n}\n\n/**\n * Sets up disabled change handler function on a given form control if ControlValueAccessor\n * associated with a given directive instance supports the `setDisabledState` call.\n *\n * @param control Form control where disabled change handler should be setup.\n * @param dir Corresponding directive instance associated with this control.\n */\nexport function setUpDisabledChangeHandler(control: FormControl, dir: NgControl): void {\n  if (dir.valueAccessor!.setDisabledState) {\n    const onDisabledChange = (isDisabled: boolean) => {\n      dir.valueAccessor!.setDisabledState!(isDisabled);\n    };\n    control.registerOnDisabledChange(onDisabledChange);\n\n    // Register a callback function to cleanup disabled change handler\n    // from a control instance when a directive is destroyed.\n    dir._registerOnDestroy(() => {\n      control._unregisterOnDisabledChange(onDisabledChange);\n    });\n  }\n}\n\n/**\n * Sets up sync and async directive validators on provided form control.\n * This function merges validators from the directive into the validators of the control.\n *\n * @param control Form control where directive validators should be setup.\n * @param dir Directive instance that contains validators to be setup.\n */\nexport function setUpValidators(control: AbstractControl, dir: AbstractControlDirective): void {\n  const validators = getControlValidators(control);\n  if (dir.validator !== null) {\n    control.setValidators(mergeValidators<ValidatorFn>(validators, dir.validator));\n  } else if (typeof validators === 'function') {\n    // If sync validators are represented by a single validator function, we force the\n    // `Validators.compose` call to happen by executing the `setValidators` function with\n    // an array that contains that function. We need this to avoid possible discrepancies in\n    // validators behavior, so sync validators are always processed by the `Validators.compose`.\n    // Note: we should consider moving this logic inside the `setValidators` function itself, so we\n    // have consistent behavior on AbstractControl API level. The same applies to the async\n    // validators logic below.\n    control.setValidators([validators]);\n  }\n\n  const asyncValidators = getControlAsyncValidators(control);\n  if (dir.asyncValidator !== null) {\n    control.setAsyncValidators(\n        mergeValidators<AsyncValidatorFn>(asyncValidators, dir.asyncValidator));\n  } else if (typeof asyncValidators === 'function') {\n    control.setAsyncValidators([asyncValidators]);\n  }\n\n  // Re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4\n  const onValidatorChange = () => control.updateValueAndValidity();\n  registerOnValidatorChange<ValidatorFn>(dir._rawValidators, onValidatorChange);\n  registerOnValidatorChange<AsyncValidatorFn>(dir._rawAsyncValidators, onValidatorChange);\n}\n\n/**\n * Cleans up sync and async directive validators on provided form control.\n * This function reverts the setup performed by the `setUpValidators` function, i.e.\n * removes directive-specific validators from a given control instance.\n *\n * @param control Form control from where directive validators should be removed.\n * @param dir Directive instance that contains validators to be removed.\n * @returns true if a control was updated as a result of this action.\n */\nexport function cleanUpValidators(\n    control: AbstractControl|null, dir: AbstractControlDirective): boolean {\n  let isControlUpdated = false;\n  if (control !== null) {\n    if (dir.validator !== null) {\n      const validators = getControlValidators(control);\n      if (Array.isArray(validators) && validators.length > 0) {\n        // Filter out directive validator function.\n        const updatedValidators = validators.filter((validator) => validator !== dir.validator);\n        if (updatedValidators.length !== validators.length) {\n          isControlUpdated = true;\n          control.setValidators(updatedValidators);\n        }\n      }\n    }\n\n    if (dir.asyncValidator !== null) {\n      const asyncValidators = getControlAsyncValidators(control);\n      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {\n        // Filter out directive async validator function.\n        const updatedAsyncValidators =\n            asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);\n        if (updatedAsyncValidators.length !== asyncValidators.length) {\n          isControlUpdated = true;\n          control.setAsyncValidators(updatedAsyncValidators);\n        }\n      }\n    }\n  }\n\n  // Clear onValidatorChange callbacks by providing a noop function.\n  const noop = () => {};\n  registerOnValidatorChange<ValidatorFn>(dir._rawValidators, noop);\n  registerOnValidatorChange<AsyncValidatorFn>(dir._rawAsyncValidators, noop);\n\n  return isControlUpdated;\n}\n\nfunction setUpViewChangePipeline(control: FormControl, dir: NgControl): void {\n  dir.valueAccessor!.registerOnChange((newValue: any) => {\n    control._pendingValue = newValue;\n    control._pendingChange = true;\n    control._pendingDirty = true;\n\n    if (control.updateOn === 'change') updateControl(control, dir);\n  });\n}\n\nfunction setUpBlurPipeline(control: FormControl, dir: NgControl): void {\n  dir.valueAccessor!.registerOnTouched(() => {\n    control._pendingTouched = true;\n\n    if (control.updateOn === 'blur' && control._pendingChange) updateControl(control, dir);\n    if (control.updateOn !== 'submit') control.markAsTouched();\n  });\n}\n\nfunction updateControl(control: FormControl, dir: NgControl): void {\n  if (control._pendingDirty) control.markAsDirty();\n  control.setValue(control._pendingValue, {emitModelToViewChange: false});\n  dir.viewToModelUpdate(control._pendingValue);\n  control._pendingChange = false;\n}\n\nfunction setUpModelChangePipeline(control: FormControl, dir: NgControl): void {\n  const onChange = (newValue?: any, emitModelEvent?: boolean) => {\n    // control -> view\n    dir.valueAccessor!.writeValue(newValue);\n\n    // control -> ngModel\n    if (emitModelEvent) dir.viewToModelUpdate(newValue);\n  };\n  control.registerOnChange(onChange);\n\n  // Register a callback function to cleanup onChange handler\n  // from a control instance when a directive is destroyed.\n  dir._registerOnDestroy(() => {\n    control._unregisterOnChange(onChange);\n  });\n}\n\n/**\n * Links a FormGroup or FormArray instance and corresponding Form directive by setting up validators\n * present in the view.\n *\n * @param control FormGroup or FormArray instance that should be linked.\n * @param dir Directive that provides view validators.\n */\nexport function setUpFormContainer(\n    control: FormGroup|FormArray, dir: AbstractFormGroupDirective|FormArrayName) {\n  if (control == null && (typeof ngDevMode === 'undefined' || ngDevMode))\n    _throwError(dir, 'Cannot find control with');\n  setUpValidators(control, dir);\n}\n\n/**\n * Reverts the setup performed by the `setUpFormContainer` function.\n *\n * @param control FormGroup or FormArray instance that should be cleaned up.\n * @param dir Directive that provided view validators.\n * @returns true if a control was updated as a result of this action.\n */\nexport function cleanUpFormContainer(\n    control: FormGroup|FormArray, dir: AbstractFormGroupDirective|FormArrayName): boolean {\n  return cleanUpValidators(control, dir);\n}\n\nfunction _noControlError(dir: NgControl) {\n  return _throwError(dir, 'There is no FormControl instance attached to form control element with');\n}\n\nfunction _throwError(dir: AbstractControlDirective, message: string): void {\n  const messageEnd = _describeControlLocation(dir);\n  throw new Error(`${message} ${messageEnd}`);\n}\n\nfunction _describeControlLocation(dir: AbstractControlDirective): string {\n  const path = dir.path;\n  if (path && path.length > 1) return `path: '${path.join(' -> ')}'`;\n  if (path?.[0]) return `name: '${path}'`;\n  return 'unspecified name attribute';\n}\n\nfunction _throwMissingValueAccessorError(dir: AbstractControlDirective) {\n  const loc = _describeControlLocation(dir);\n  throw new RuntimeError(\n      RuntimeErrorCode.NG_MISSING_VALUE_ACCESSOR, `No value accessor for form control ${loc}.`);\n}\n\nfunction _throwInvalidValueAccessorError(dir: AbstractControlDirective) {\n  const loc = _describeControlLocation(dir);\n  throw new RuntimeError(\n      RuntimeErrorCode.NG_VALUE_ACCESSOR_NOT_PROVIDED,\n      `Value accessor was not provided as an array for form control with ${loc}. ` +\n          `Check that the \\`NG_VALUE_ACCESSOR\\` token is configured as a \\`multi: true\\` provider.`);\n}\n\nexport function isPropertyUpdated(changes: {[key: string]: any}, viewModel: any): boolean {\n  if (!changes.hasOwnProperty('model')) return false;\n  const change = changes['model'];\n\n  if (change.isFirstChange()) return true;\n  return !Object.is(viewModel, change.currentValue);\n}\n\nexport function isBuiltInAccessor(valueAccessor: ControlValueAccessor): boolean {\n  // Check if a given value accessor is an instance of a class that directly extends\n  // `BuiltInControlValueAccessor` one.\n  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;\n}\n\nexport function syncPendingControls(form: FormGroup, directives: Set<NgControl>|NgControl[]): void {\n  form._syncPendingControls();\n  directives.forEach((dir: NgControl) => {\n    const control = dir.control as FormControl;\n    if (control.updateOn === 'submit' && control._pendingChange) {\n      dir.viewToModelUpdate(control._pendingValue);\n      control._pendingChange = false;\n    }\n  });\n}\n\n// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented\nexport function selectValueAccessor(\n    dir: NgControl, valueAccessors: ControlValueAccessor[]): ControlValueAccessor|null {\n  if (!valueAccessors) return null;\n\n  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === 'undefined' || ngDevMode))\n    _throwInvalidValueAccessorError(dir);\n\n  let defaultAccessor: ControlValueAccessor|undefined = undefined;\n  let builtinAccessor: ControlValueAccessor|undefined = undefined;\n  let customAccessor: ControlValueAccessor|undefined = undefined;\n\n  valueAccessors.forEach((v: ControlValueAccessor) => {\n    if (v.constructor === DefaultValueAccessor) {\n      defaultAccessor = v;\n    } else if (isBuiltInAccessor(v)) {\n      if (builtinAccessor && (typeof ngDevMode === 'undefined' || ngDevMode))\n        _throwError(dir, 'More than one built-in value accessor matches form control with');\n      builtinAccessor = v;\n    } else {\n      if (customAccessor && (typeof ngDevMode === 'undefined' || ngDevMode))\n        _throwError(dir, 'More than one custom value accessor matches form control with');\n      customAccessor = v;\n    }\n  });\n\n  if (customAccessor) return customAccessor;\n  if (builtinAccessor) return builtinAccessor;\n  if (defaultAccessor) return defaultAccessor;\n\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    _throwError(dir, 'No valid value accessor for form control with');\n  }\n  return null;\n}\n\nexport function removeListItem<T>(list: T[], el: T): void {\n  const index = list.indexOf(el);\n  if (index > -1) list.splice(index, 1);\n}\n\n// TODO(kara): remove after deprecation period\nexport function _ngModelWarning(\n    name: string, type: {_ngModelWarningSentOnce: boolean},\n    instance: {_ngModelWarningSent: boolean}, warningConfig: string|null) {\n  if (warningConfig === 'never') return;\n\n  if (((warningConfig === null || warningConfig === 'once') && !type._ngModelWarningSentOnce) ||\n      (warningConfig === 'always' && !instance._ngModelWarningSent)) {\n    console.warn(ngModelWarning(name));\n    type._ngModelWarningSentOnce = true;\n    instance._ngModelWarningSent = true;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AfterViewInit, Directive, EventEmitter, forwardRef, Inject, Input, Optional, Provider, Self, Writable as Writable} from '@angular/core';\n\nimport {AbstractControl, FormHooks} from '../model/abstract_model';\nimport {FormControl} from '../model/form_control';\nimport {FormGroup} from '../model/form_group';\nimport {composeAsyncValidators, composeValidators, NG_ASYNC_VALIDATORS, NG_VALIDATORS} from '../validators';\n\nimport {ControlContainer} from './control_container';\nimport {Form} from './form_interface';\nimport {NgControl} from './ng_control';\nimport {NgModel} from './ng_model';\nimport {NgModelGroup} from './ng_model_group';\nimport {CALL_SET_DISABLED_STATE, SetDisabledStateOption, setUpControl, setUpFormContainer, syncPendingControls} from './shared';\nimport {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from './validators';\n\nconst formDirectiveProvider: Provider = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => NgForm)\n};\n\nconst resolvedPromise = (() => Promise.resolve())();\n\n/**\n * @description\n * Creates a top-level `FormGroup` instance and binds it to a form\n * to track aggregate form value and validation status.\n *\n * As soon as you import the `FormsModule`, this directive becomes active by default on\n * all `<form>` tags.  You don't need to add a special selector.\n *\n * You optionally export the directive into a local template variable using `ngForm` as the key\n * (ex: `#myForm=\"ngForm\"`). This is optional, but useful.  Many properties from the underlying\n * `FormGroup` instance are duplicated on the directive itself, so a reference to it\n * gives you access to the aggregate value and validity status of the form, as well as\n * user interaction properties like `dirty` and `touched`.\n *\n * To register child controls with the form, use `NgModel` with a `name`\n * attribute. You may use `NgModelGroup` to create sub-groups within the form.\n *\n * If necessary, listen to the directive's `ngSubmit` event to be notified when the user has\n * triggered a form submission. The `ngSubmit` event emits the original form\n * submission event.\n *\n * In template driven forms, all `<form>` tags are automatically tagged as `NgForm`.\n * To import the `FormsModule` but skip its usage in some forms,\n * for example, to use native HTML5 validation, add the `ngNoForm` and the `<form>`\n * tags won't create an `NgForm` directive. In reactive forms, using `ngNoForm` is\n * unnecessary because the `<form>` tags are inert. In that case, you would\n * refrain from using the `formGroup` directive.\n *\n * @usageNotes\n *\n * ### Listening for form submission\n *\n * The following example shows how to capture the form values from the \"ngSubmit\" event.\n *\n * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}\n *\n * ### Setting the update options\n *\n * The following example shows you how to change the \"updateOn\" option from its default using\n * ngFormOptions.\n *\n * ```html\n * <form [ngFormOptions]=\"{updateOn: 'blur'}\">\n *    <input name=\"one\" ngModel>  <!-- this ngModel will update on blur -->\n * </form>\n * ```\n *\n * ### Native DOM validation UI\n *\n * In order to prevent the native DOM form validation UI from interfering with Angular's form\n * validation, Angular automatically adds the `novalidate` attribute on any `<form>` whenever\n * `FormModule` or `ReactiveFormModule` are imported into the application.\n * If you want to explicitly enable native DOM validation UI with Angular forms, you can add the\n * `ngNativeValidate` attribute to the `<form>` element:\n *\n * ```html\n * <form ngNativeValidate>\n *   ...\n * </form>\n * ```\n *\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector: 'form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]',\n  providers: [formDirectiveProvider],\n  host: {'(submit)': 'onSubmit($event)', '(reset)': 'onReset()'},\n  outputs: ['ngSubmit'],\n  exportAs: 'ngForm'\n})\nexport class NgForm extends ControlContainer implements Form, AfterViewInit {\n  /**\n   * @description\n   * Returns whether the form submission has been triggered.\n   */\n  public readonly submitted: boolean = false;\n\n  private _directives = new Set<NgModel>();\n\n  /**\n   * @description\n   * The `FormGroup` instance created for this form.\n   */\n  form: FormGroup;\n\n  /**\n   * @description\n   * Event emitter for the \"ngSubmit\" event\n   */\n  ngSubmit = new EventEmitter();\n\n  /**\n   * @description\n   * Tracks options for the `NgForm` instance.\n   *\n   * **updateOn**: Sets the default `updateOn` value for all child `NgModels` below it\n   * unless explicitly set by a child `NgModel` using `ngModelOptions`). Defaults to 'change'.\n   * Possible values: `'change'` | `'blur'` | `'submit'`.\n   *\n   */\n  // TODO(issue/24571): remove '!'.\n  @Input('ngFormOptions') options!: {updateOn?: FormHooks};\n\n  constructor(\n      @Optional() @Self() @Inject(NG_VALIDATORS) validators: (Validator|ValidatorFn)[],\n      @Optional() @Self() @Inject(NG_ASYNC_VALIDATORS) asyncValidators:\n          (AsyncValidator|AsyncValidatorFn)[],\n      @Optional() @Inject(CALL_SET_DISABLED_STATE) private callSetDisabledState?:\n          SetDisabledStateOption) {\n    super();\n    this.form =\n        new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));\n  }\n\n  /** @nodoc */\n  ngAfterViewInit() {\n    this._setUpdateStrategy();\n  }\n\n  /**\n   * @description\n   * The directive instance.\n   */\n  override get formDirective(): Form {\n    return this;\n  }\n\n  /**\n   * @description\n   * The internal `FormGroup` instance.\n   */\n  override get control(): FormGroup {\n    return this.form;\n  }\n\n  /**\n   * @description\n   * Returns an array representing the path to this group. Because this directive\n   * always lives at the top level of a form, it is always an empty array.\n   */\n  override get path(): string[] {\n    return [];\n  }\n\n  /**\n   * @description\n   * Returns a map of the controls in this group.\n   */\n  get controls(): {[key: string]: AbstractControl} {\n    return this.form.controls;\n  }\n\n  /**\n   * @description\n   * Method that sets up the control directive in this group, re-calculates its value\n   * and validity, and adds the instance to the internal list of directives.\n   *\n   * @param dir The `NgModel` directive instance.\n   */\n  addControl(dir: NgModel): void {\n    resolvedPromise.then(() => {\n      const container = this._findContainer(dir.path);\n      (dir as Writable<NgModel>).control =\n          <FormControl>container.registerControl(dir.name, dir.control);\n      setUpControl(dir.control, dir, this.callSetDisabledState);\n      dir.control.updateValueAndValidity({emitEvent: false});\n      this._directives.add(dir);\n    });\n  }\n\n  /**\n   * @description\n   * Retrieves the `FormControl` instance from the provided `NgModel` directive.\n   *\n   * @param dir The `NgModel` directive instance.\n   */\n  getControl(dir: NgModel): FormControl {\n    return <FormControl>this.form.get(dir.path);\n  }\n\n  /**\n   * @description\n   * Removes the `NgModel` instance from the internal list of directives\n   *\n   * @param dir The `NgModel` directive instance.\n   */\n  removeControl(dir: NgModel): void {\n    resolvedPromise.then(() => {\n      const container = this._findContainer(dir.path);\n      if (container) {\n        container.removeControl(dir.name);\n      }\n      this._directives.delete(dir);\n    });\n  }\n\n  /**\n   * @description\n   * Adds a new `NgModelGroup` directive instance to the form.\n   *\n   * @param dir The `NgModelGroup` directive instance.\n   */\n  addFormGroup(dir: NgModelGroup): void {\n    resolvedPromise.then(() => {\n      const container = this._findContainer(dir.path);\n      const group = new FormGroup({});\n      setUpFormContainer(group, dir);\n      container.registerControl(dir.name, group);\n      group.updateValueAndValidity({emitEvent: false});\n    });\n  }\n\n  /**\n   * @description\n   * Removes the `NgModelGroup` directive instance from the form.\n   *\n   * @param dir The `NgModelGroup` directive instance.\n   */\n  removeFormGroup(dir: NgModelGroup): void {\n    resolvedPromise.then(() => {\n      const container = this._findContainer(dir.path);\n      if (container) {\n        container.removeControl(dir.name);\n      }\n    });\n  }\n\n  /**\n   * @description\n   * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance\n   *\n   * @param dir The `NgModelGroup` directive instance.\n   */\n  getFormGroup(dir: NgModelGroup): FormGroup {\n    return <FormGroup>this.form.get(dir.path);\n  }\n\n  /**\n   * Sets the new value for the provided `NgControl` directive.\n   *\n   * @param dir The `NgControl` directive instance.\n   * @param value The new value for the directive's control.\n   */\n  updateModel(dir: NgControl, value: any): void {\n    resolvedPromise.then(() => {\n      const ctrl = <FormControl>this.form.get(dir.path!);\n      ctrl.setValue(value);\n    });\n  }\n\n  /**\n   * @description\n   * Sets the value for this `FormGroup`.\n   *\n   * @param value The new value\n   */\n  setValue(value: {[key: string]: any}): void {\n    this.control.setValue(value);\n  }\n\n  /**\n   * @description\n   * Method called when the \"submit\" event is triggered on the form.\n   * Triggers the `ngSubmit` emitter to emit the \"submit\" event as its payload.\n   *\n   * @param $event The \"submit\" event object\n   */\n  onSubmit($event: Event): boolean {\n    (this as Writable<this>).submitted = true;\n    syncPendingControls(this.form, this._directives);\n    this.ngSubmit.emit($event);\n    // Forms with `method=\"dialog\"` have some special behavior\n    // that won't reload the page and that shouldn't be prevented.\n    return ($event?.target as HTMLFormElement | null)?.method === 'dialog';\n  }\n\n  /**\n   * @description\n   * Method called when the \"reset\" event is triggered on the form.\n   */\n  onReset(): void {\n    this.resetForm();\n  }\n\n  /**\n   * @description\n   * Resets the form to an initial value and resets its submitted status.\n   *\n   * @param value The new value for the form.\n   */\n  resetForm(value: any = undefined): void {\n    this.form.reset(value);\n    (this as Writable<this>).submitted = false;\n  }\n\n  private _setUpdateStrategy() {\n    if (this.options && this.options.updateOn != null) {\n      this.form._updateOn = this.options.updateOn;\n    }\n  }\n\n  private _findContainer(path: string[]): FormGroup {\n    path.pop();\n    return path.length ? <FormGroup>this.form.get(path) : this.form;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function removeListItem<T>(list: T[], el: T): void {\n  const index = list.indexOf(el);\n  if (index > -1) list.splice(index, 1);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Writable as Writable} from '@angular/core';\n\nimport {AsyncValidatorFn, ValidatorFn} from '../directives/validators';\nimport {removeListItem} from '../util';\n\nimport {AbstractControl, AbstractControlOptions, isOptionsObj, pickAsyncValidators, pickValidators} from './abstract_model';\n\n/**\n * FormControlState is a boxed form value. It is an object with a `value` key and a `disabled` key.\n *\n * @publicApi\n */\nexport interface FormControlState<T> {\n  value: T;\n  disabled: boolean;\n}\n\n/**\n * Interface for options provided to a `FormControl`.\n *\n * This interface extends all options from {@link AbstractControlOptions}, plus some options\n * unique to `FormControl`.\n *\n * @publicApi\n */\nexport interface FormControlOptions extends AbstractControlOptions {\n  /**\n   * @description\n   * Whether to use the initial value used to construct the `FormControl` as its default value\n   * as well. If this option is false or not provided, the default value of a FormControl is `null`.\n   * When a FormControl is reset without an explicit value, its value reverts to\n   * its default value.\n   */\n  nonNullable?: boolean;\n\n  /**\n   * @deprecated Use `nonNullable` instead.\n   */\n  initialValueIsDefault?: boolean;\n}\n\n/**\n * Tracks the value and validation status of an individual form control.\n *\n * This is one of the four fundamental building blocks of Angular forms, along with\n * `FormGroup`, `FormArray` and `FormRecord`. It extends the `AbstractControl` class that\n * implements most of the base functionality for accessing the value, validation status,\n * user interactions and events.\n *\n * `FormControl` takes a single generic argument, which describes the type of its value. This\n * argument always implicitly includes `null` because the control can be reset. To change this\n * behavior, set `nonNullable` or see the usage notes below.\n *\n * See [usage examples below](#usage-notes).\n *\n * @see {@link AbstractControl}\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see [Usage Notes](#usage-notes)\n *\n * @publicApi\n *\n * @overriddenImplementation FormControlCtor\n *\n * @usageNotes\n *\n * ### Initializing Form Controls\n *\n * Instantiate a `FormControl`, with an initial value.\n *\n * ```ts\n * const control = new FormControl('some value');\n * console.log(control.value);     // 'some value'\n * ```\n *\n * The following example initializes the control with a form state object. The `value`\n * and `disabled` keys are required in this case.\n *\n * ```ts\n * const control = new FormControl({ value: 'n/a', disabled: true });\n * console.log(control.value);     // 'n/a'\n * console.log(control.status);    // 'DISABLED'\n * ```\n *\n * The following example initializes the control with a synchronous validator.\n *\n * ```ts\n * const control = new FormControl('', Validators.required);\n * console.log(control.value);      // ''\n * console.log(control.status);     // 'INVALID'\n * ```\n *\n * The following example initializes the control using an options object.\n *\n * ```ts\n * const control = new FormControl('', {\n *    validators: Validators.required,\n *    asyncValidators: myAsyncValidator\n * });\n * ```\n *\n * ### The single type argument\n *\n * `FormControl` accepts a generic argument, which describes the type of its value.\n * In most cases, this argument will be inferred.\n *\n * If you are initializing the control to `null`, or you otherwise wish to provide a\n * wider type, you may specify the argument explicitly:\n *\n * ```\n * let fc = new FormControl<string|null>(null);\n * fc.setValue('foo');\n * ```\n *\n * You might notice that `null` is always added to the type of the control.\n * This is because the control will become `null` if you call `reset`. You can change\n * this behavior by setting `{nonNullable: true}`.\n *\n * ### Configure the control to update on a blur event\n *\n * Set the `updateOn` option to `'blur'` to update on the blur `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'blur' });\n * ```\n *\n * ### Configure the control to update on a submit event\n *\n * Set the `updateOn` option to `'submit'` to update on a submit `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'submit' });\n * ```\n *\n * ### Reset the control back to a specific value\n *\n * You reset to a specific form state by passing through a standalone\n * value or a form state object that contains both a value and a disabled state\n * (these are the only two properties that cannot be calculated).\n *\n * ```ts\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n *\n * control.reset('Drew');\n *\n * console.log(control.value); // 'Drew'\n * ```\n *\n * ### Reset the control to its initial value\n *\n * If you wish to always reset the control to its initial value (instead of null),\n * you can pass the `nonNullable` option:\n *\n * ```\n * const control = new FormControl('Nancy', {nonNullable: true});\n *\n * console.log(control.value); // 'Nancy'\n *\n * control.reset();\n *\n * console.log(control.value); // 'Nancy'\n * ```\n *\n * ### Reset the control back to an initial value and disabled\n *\n * ```\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n * console.log(control.status); // 'VALID'\n *\n * control.reset({ value: 'Drew', disabled: true });\n *\n * console.log(control.value); // 'Drew'\n * console.log(control.status); // 'DISABLED'\n * ```\n */\nexport interface FormControl<TValue = any> extends AbstractControl<TValue> {\n  /**\n   * The default value of this FormControl, used whenever the control is reset without an explicit\n   * value. See {@link FormControlOptions#nonNullable} for more information on configuring\n   * a default value.\n   */\n  readonly defaultValue: TValue;\n\n  /** @internal */\n  _onChange: Function[];\n\n  /**\n   * This field holds a pending value that has not yet been applied to the form's value.\n   * @internal\n   */\n  _pendingValue: TValue;\n\n  /** @internal */\n  _pendingChange: boolean;\n\n  /**\n   * Sets a new value for the form control.\n   *\n   * @param value The new value for the control.\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events when the value changes.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an\n   * `onChange` event to\n   * update the view.\n   * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an\n   * `ngModelChange`\n   * event to update the model.\n   *\n   */\n  setValue(value: TValue, options?: {\n    onlySelf?: boolean,\n    emitEvent?: boolean,\n    emitModelToViewChange?: boolean,\n    emitViewToModelChange?: boolean\n  }): void;\n\n  /**\n   * Patches the value of a control.\n   *\n   * This function is functionally the same as {@link FormControl#setValue setValue} at this level.\n   * It exists for symmetry with {@link FormGroup#patchValue patchValue} on `FormGroups` and\n   * `FormArrays`, where it does behave differently.\n   *\n   * @see {@link FormControl#setValue} for options\n   */\n  patchValue(value: TValue, options?: {\n    onlySelf?: boolean,\n    emitEvent?: boolean,\n    emitModelToViewChange?: boolean,\n    emitViewToModelChange?: boolean\n  }): void;\n\n  /**\n   * Resets the form control, marking it `pristine` and `untouched`, and resetting\n   * the value. The new value will be the provided value (if passed), `null`, or the initial value\n   * if `nonNullable` was set in the constructor via {@link FormControlOptions}.\n   *\n   * ```ts\n   * // By default, the control will reset to null.\n   * const dog = new FormControl('spot');\n   * dog.reset(); // dog.value is null\n   *\n   * // If this flag is set, the control will instead reset to the initial value.\n   * const cat = new FormControl('tabby', {nonNullable: true});\n   * cat.reset(); // cat.value is \"tabby\"\n   *\n   * // A value passed to reset always takes precedence.\n   * const fish = new FormControl('finn', {nonNullable: true});\n   * fish.reset('bubble'); // fish.value is \"bubble\"\n   * ```\n   *\n   * @param formState Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   *\n   */\n  reset(formState?: TValue|FormControlState<TValue>, options?: {\n    onlySelf?: boolean,\n    emitEvent?: boolean\n  }): void;\n\n  /**\n   * For a simple FormControl, the raw value is equivalent to the value.\n   */\n  getRawValue(): TValue;\n\n  /**\n   * @internal\n   */\n  _updateValue(): void;\n\n  /**\n   * @internal\n   */\n  _anyControls(condition: (c: AbstractControl) => boolean): boolean;\n\n  /**\n   * @internal\n   */\n  _allControlsDisabled(): boolean;\n\n\n  /**\n   * Register a listener for change events.\n   *\n   * @param fn The method that is called when the value changes\n   */\n  registerOnChange(fn: Function): void;\n\n\n  /**\n   * Internal function to unregister a change events listener.\n   * @internal\n   */\n  _unregisterOnChange(fn: (value?: any, emitModelEvent?: boolean) => void): void;\n\n  /**\n   * Register a listener for disabled events.\n   *\n   * @param fn The method that is called when the disabled status changes.\n   */\n  registerOnDisabledChange(fn: (isDisabled: boolean) => void): void;\n\n  /**\n   * Internal function to unregister a disabled event listener.\n   * @internal\n   */\n  _unregisterOnDisabledChange(fn: (isDisabled: boolean) => void): void;\n\n  /**\n   * @internal\n   */\n  _forEachChild(cb: (c: AbstractControl) => void): void;\n\n  /** @internal */\n  _syncPendingControls(): boolean;\n}\n\n// This internal interface is present to avoid a naming clash, resulting in the wrong `FormControl`\n// symbol being used.\ntype FormControlInterface<TValue = any> = FormControl<TValue>;\n\n/**\n * Various available constructors for `FormControl`.\n * Do not use this interface directly. Instead, use `FormControl`:\n * ```\n * const fc = new FormControl('foo');\n * ```\n * This symbol is prefixed with  to make plain that it is an internal symbol.\n */\nexport interface FormControlCtor {\n  /**\n   * Construct a FormControl with no initial value or validators.\n   */\n  new(): FormControl<any>;\n\n  /**\n   * Creates a new `FormControl` instance.\n   *\n   * @param formState Initializes the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or a `FormControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   */\n  new<T = any>(value: FormControlState<T>|T, opts: FormControlOptions&{nonNullable: true}):\n      FormControl<T>;\n\n  /**\n   * @deprecated Use `nonNullable` instead.\n   */\n  new<T = any>(value: FormControlState<T>|T, opts: FormControlOptions&{\n    initialValueIsDefault: true\n  }): FormControl<T>;\n\n  /**\n   * @deprecated When passing an `options` argument, the `asyncValidator` argument has no effect.\n   */\n  new<T = any>(\n      value: FormControlState<T>|T, opts: FormControlOptions,\n      asyncValidator: AsyncValidatorFn|AsyncValidatorFn[]): FormControl<T|null>;\n\n  new<T = any>(\n      value: FormControlState<T>|T,\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|FormControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): FormControl<T|null>;\n\n  /**\n   * The presence of an explicit `prototype` property provides backwards-compatibility for apps that\n   * manually inspect the prototype chain.\n   */\n  prototype: FormControl<any>;\n}\n\nfunction isFormControlState(formState: unknown): formState is FormControlState<unknown> {\n  return typeof formState === 'object' && formState !== null &&\n      Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;\n}\n\nexport const FormControl: FormControlCtor =\n    (class FormControl<TValue = any> extends AbstractControl<\n         TValue> implements FormControlInterface<TValue> {\n      /** @publicApi */\n      public readonly defaultValue: TValue = null as unknown as TValue;\n\n      /** @internal */\n      _onChange: Array<Function> = [];\n\n      /** @internal */\n      _pendingValue!: TValue;\n\n      /** @internal */\n      _pendingChange: boolean = false;\n\n      constructor(\n          // formState and defaultValue will only be null if T is nullable\n          formState: FormControlState<TValue>|TValue = null as unknown as TValue,\n          validatorOrOpts?: ValidatorFn|ValidatorFn[]|FormControlOptions|null,\n          asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n        super(\n            pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n        this._applyFormState(formState);\n        this._setUpdateStrategy(validatorOrOpts);\n        this._initObservables();\n        this.updateValueAndValidity({\n          onlySelf: true,\n          // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n          // `VALID` or `INVALID`.\n          // The status should be broadcasted via the `statusChanges` observable, so we set\n          // `emitEvent` to `true` to allow that during the control creation process.\n          emitEvent: !!this.asyncValidator\n        });\n        if (isOptionsObj(validatorOrOpts) &&\n            (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {\n          if (isFormControlState(formState)) {\n            this.defaultValue = formState.value;\n          } else {\n            this.defaultValue = formState;\n          }\n        }\n      }\n\n      override setValue(value: TValue, options: {\n        onlySelf?: boolean,\n        emitEvent?: boolean,\n        emitModelToViewChange?: boolean,\n        emitViewToModelChange?: boolean\n      } = {}): void {\n        (this as Writable<this>).value = this._pendingValue = value;\n        if (this._onChange.length && options.emitModelToViewChange !== false) {\n          this._onChange.forEach(\n              (changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));\n        }\n        this.updateValueAndValidity(options);\n      }\n\n      override patchValue(value: TValue, options: {\n        onlySelf?: boolean,\n        emitEvent?: boolean,\n        emitModelToViewChange?: boolean,\n        emitViewToModelChange?: boolean\n      } = {}): void {\n        this.setValue(value, options);\n      }\n\n      override reset(\n          formState: TValue|FormControlState<TValue> = this.defaultValue,\n          options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n        this._applyFormState(formState);\n        this.markAsPristine(options);\n        this.markAsUntouched(options);\n        this.setValue(this.value, options);\n        this._pendingChange = false;\n      }\n\n      /**  @internal */\n      override _updateValue(): void {}\n\n      /**  @internal */\n      override _anyControls(condition: (c: AbstractControl) => boolean): boolean {\n        return false;\n      }\n\n      /**  @internal */\n      override _allControlsDisabled(): boolean {\n        return this.disabled;\n      }\n\n      registerOnChange(fn: Function): void {\n        this._onChange.push(fn);\n      }\n\n      /** @internal */\n      _unregisterOnChange(fn: (value?: any, emitModelEvent?: boolean) => void): void {\n        removeListItem(this._onChange, fn);\n      }\n\n      registerOnDisabledChange(fn: (isDisabled: boolean) => void): void {\n        this._onDisabledChange.push(fn);\n      }\n\n      /** @internal */\n      _unregisterOnDisabledChange(fn: (isDisabled: boolean) => void): void {\n        removeListItem(this._onDisabledChange, fn);\n      }\n\n      /** @internal */\n      override _forEachChild(cb: (c: AbstractControl) => void): void {}\n\n      /** @internal */\n      override _syncPendingControls(): boolean {\n        if (this.updateOn === 'submit') {\n          if (this._pendingDirty) this.markAsDirty();\n          if (this._pendingTouched) this.markAsTouched();\n          if (this._pendingChange) {\n            this.setValue(this._pendingValue, {onlySelf: true, emitModelToViewChange: false});\n            return true;\n          }\n        }\n        return false;\n      }\n\n      private _applyFormState(formState: FormControlState<TValue>|TValue) {\n        if (isFormControlState(formState)) {\n          (this as Writable<this>).value = this._pendingValue = formState.value;\n          formState.disabled ? this.disable({onlySelf: true, emitEvent: false}) :\n                               this.enable({onlySelf: true, emitEvent: false});\n        } else {\n          (this as Writable<this>).value = this._pendingValue = formState;\n        }\n      }\n    });\n\ninterface UntypedFormControlCtor {\n  new(): UntypedFormControl;\n\n  new(formState?: any, validatorOrOpts?: ValidatorFn|ValidatorFn[]|FormControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): UntypedFormControl;\n\n  /**\n   * The presence of an explicit `prototype` property provides backwards-compatibility for apps that\n   * manually inspect the prototype chain.\n   */\n  prototype: FormControl<any>;\n}\n\n/**\n * UntypedFormControl is a non-strongly-typed version of `FormControl`.\n */\nexport type UntypedFormControl = FormControl<any>;\n\nexport const UntypedFormControl: UntypedFormControlCtor = FormControl;\n\n/**\n * @description\n * Asserts that the given control is an instance of `FormControl`\n *\n * @publicApi\n */\nexport const isFormControl = (control: unknown): control is FormControl =>\n    control instanceof FormControl;\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, OnDestroy, OnInit} from '@angular/core';\n\nimport {FormGroup} from '../model/form_group';\n\nimport {ControlContainer} from './control_container';\nimport {Form} from './form_interface';\nimport {controlPath} from './shared';\n\n\n\n/**\n * @description\n * A base class for code shared between the `NgModelGroup` and `FormGroupName` directives.\n *\n * @publicApi\n */\n@Directive()\nexport class AbstractFormGroupDirective extends ControlContainer implements OnInit, OnDestroy {\n  /**\n   * @description\n   * The parent control for the group\n   *\n   * @internal\n   */\n  // TODO(issue/24571): remove '!'.\n  _parent!: ControlContainer;\n\n  /** @nodoc */\n  ngOnInit(): void {\n    this._checkParentType();\n    // Register the group with its parent group.\n    this.formDirective!.addFormGroup(this);\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    if (this.formDirective) {\n      // Remove the group from its parent group.\n      this.formDirective.removeFormGroup(this);\n    }\n  }\n\n  /**\n   * @description\n   * The `FormGroup` bound to this directive.\n   */\n  override get control(): FormGroup {\n    return this.formDirective!.getFormGroup(this);\n  }\n\n  /**\n   * @description\n   * The path to this group from the top-level directive.\n   */\n  override get path(): string[] {\n    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);\n  }\n\n  /**\n   * @description\n   * The top-level directive for this group if present, otherwise null.\n   */\n  override get formDirective(): Form|null {\n    return this._parent ? this._parent.formDirective : null;\n  }\n\n  /** @internal */\n  _checkParentType(): void {}\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\n\nimport {formControlNameExample, formGroupNameExample, ngModelGroupExample, ngModelWithFormGroupExample} from './error_examples';\n\n\nexport function modelParentException(): Error {\n  return new RuntimeError(RuntimeErrorCode.NGMODEL_IN_FORM_GROUP, `\n    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n    formGroup's partner directive \"formControlName\" instead.  Example:\n\n    ${formControlNameExample}\n\n    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n    Example:\n\n    ${ngModelWithFormGroupExample}`);\n}\n\nexport function formGroupNameException(): Error {\n  return new RuntimeError(RuntimeErrorCode.NGMODEL_IN_FORM_GROUP_NAME, `\n    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n    Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n    ${formGroupNameExample}\n\n    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n    ${ngModelGroupExample}`);\n}\n\nexport function missingNameException(): Error {\n  return new RuntimeError(\n      RuntimeErrorCode.NGMODEL_WITHOUT_NAME,\n      `If ngModel is used within a form tag, either the name attribute must be set or the form\n    control must be defined as 'standalone' in ngModelOptions.\n\n    Example 1: <input [(ngModel)]=\"person.firstName\" name=\"first\">\n    Example 2: <input [(ngModel)]=\"person.firstName\" [ngModelOptions]=\"{standalone: true}\">`);\n}\n\nexport function modelGroupParentException(): Error {\n  return new RuntimeError(RuntimeErrorCode.NGMODELGROUP_IN_FORM_GROUP, `\n    ngModelGroup cannot be used with a parent formGroup directive.\n\n    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n    ${formGroupNameExample}\n\n    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n    ${ngModelGroupExample}`);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, forwardRef, Host, Inject, Input, OnDestroy, OnInit, Optional, Self, SkipSelf} from '@angular/core';\n\nimport {NG_ASYNC_VALIDATORS, NG_VALIDATORS} from '../validators';\n\nimport {AbstractFormGroupDirective} from './abstract_form_group_directive';\nimport {ControlContainer} from './control_container';\nimport {NgForm} from './ng_form';\nimport {modelGroupParentException} from './template_driven_errors';\nimport {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from './validators';\n\nexport const modelGroupProvider: any = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => NgModelGroup)\n};\n\n/**\n * @description\n * Creates and binds a `FormGroup` instance to a DOM element.\n *\n * This directive can only be used as a child of `NgForm` (within `<form>` tags).\n *\n * Use this directive to validate a sub-group of your form separately from the\n * rest of your form, or if some values in your domain model make more sense\n * to consume together in a nested object.\n *\n * Provide a name for the sub-group and it will become the key\n * for the sub-group in the form's full value. If you need direct access, export the directive into\n * a local template variable using `ngModelGroup` (ex: `#myGroup=\"ngModelGroup\"`).\n *\n * @usageNotes\n *\n * ### Consuming controls in a grouping\n *\n * The following example shows you how to combine controls together in a sub-group\n * of the form.\n *\n * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}\n *\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup'})\nexport class NgModelGroup extends AbstractFormGroupDirective implements OnInit, OnDestroy {\n  /**\n   * @description\n   * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds\n   * to a key in the parent `NgForm`.\n   */\n  @Input('ngModelGroup') override name: string = '';\n\n  constructor(\n      @Host() @SkipSelf() parent: ControlContainer,\n      @Optional() @Self() @Inject(NG_VALIDATORS) validators: (Validator|ValidatorFn)[],\n      @Optional() @Self() @Inject(NG_ASYNC_VALIDATORS) asyncValidators:\n          (AsyncValidator|AsyncValidatorFn)[]) {\n    super();\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n  }\n\n  /** @internal */\n  override _checkParentType(): void {\n    if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm) &&\n        (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw modelGroupParentException();\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {booleanAttribute, ChangeDetectorRef, Directive, EventEmitter, forwardRef, Host, Inject, Input, OnChanges, OnDestroy, Optional, Output, Provider, Self, SimpleChanges} from '@angular/core';\n\nimport {FormHooks} from '../model/abstract_model';\nimport {FormControl} from '../model/form_control';\nimport {NG_ASYNC_VALIDATORS, NG_VALIDATORS} from '../validators';\n\nimport {AbstractFormGroupDirective} from './abstract_form_group_directive';\nimport {ControlContainer} from './control_container';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\nimport {NgControl} from './ng_control';\nimport {NgForm} from './ng_form';\nimport {NgModelGroup} from './ng_model_group';\nimport {CALL_SET_DISABLED_STATE, controlPath, isPropertyUpdated, selectValueAccessor, SetDisabledStateOption, setUpControl} from './shared';\nimport {formGroupNameException, missingNameException, modelParentException} from './template_driven_errors';\nimport {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from './validators';\n\nconst formControlBinding: Provider = {\n  provide: NgControl,\n  useExisting: forwardRef(() => NgModel)\n};\n\n/**\n * `ngModel` forces an additional change detection run when its inputs change:\n * E.g.:\n * ```\n * <div>{{myModel.valid}}</div>\n * <input [(ngModel)]=\"myValue\" #myModel=\"ngModel\">\n * ```\n * I.e. `ngModel` can export itself on the element and then be used in the template.\n * Normally, this would result in expressions before the `input` that use the exported directive\n * to have an old value as they have been\n * dirty checked before. As this is a very common case for `ngModel`, we added this second change\n * detection run.\n *\n * Notes:\n * - this is just one extra run no matter how many `ngModel`s have been changed.\n * - this is a general problem when using `exportAs` for directives!\n */\nconst resolvedPromise = (() => Promise.resolve())();\n\n/**\n * @description\n * Creates a `FormControl` instance from a [domain\n * model](https://en.wikipedia.org/wiki/Domain_model) and binds it to a form control element.\n *\n * The `FormControl` instance tracks the value, user interaction, and\n * validation status of the control and keeps the view synced with the model. If used\n * within a parent form, the directive also registers itself with the form as a child\n * control.\n *\n * This directive is used by itself or as part of a larger form. Use the\n * `ngModel` selector to activate it.\n *\n * It accepts a domain model as an optional `Input`. If you have a one-way binding\n * to `ngModel` with `[]` syntax, changing the domain model's value in the component\n * class sets the value in the view. If you have a two-way binding with `[()]` syntax\n * (also known as 'banana-in-a-box syntax'), the value in the UI always syncs back to\n * the domain model in your class.\n *\n * To inspect the properties of the associated `FormControl` (like the validity state),\n * export the directive into a local template variable using `ngModel` as the key (ex:\n * `#myVar=\"ngModel\"`). You can then access the control using the directive's `control` property.\n * However, the most commonly used properties (like `valid` and `dirty`) also exist on the control\n * for direct access. See a full list of properties directly available in\n * `AbstractControlDirective`.\n *\n * @see {@link RadioControlValueAccessor}\n * @see {@link SelectControlValueAccessor}\n *\n * @usageNotes\n *\n * ### Using ngModel on a standalone control\n *\n * The following examples show a simple standalone control using `ngModel`:\n *\n * {@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}\n *\n * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute\n * so that the control can be registered with the parent form under that name.\n *\n * In the context of a parent form, it's often unnecessary to include one-way or two-way binding,\n * as the parent form syncs the value for you. You access its properties by exporting it into a\n * local template variable using `ngForm` such as (`#f=\"ngForm\"`). Use the variable where\n * needed on form submission.\n *\n * If you do need to populate initial values into your form, using a one-way binding for\n * `ngModel` tends to be sufficient as long as you use the exported form's value rather\n * than the domain model's value on submit.\n *\n * ### Using ngModel within a form\n *\n * The following example shows controls using `ngModel` within a form:\n *\n * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}\n *\n * ### Using a standalone ngModel within a group\n *\n * The following example shows you how to use a standalone ngModel control\n * within a form. This controls the display of the form, but doesn't contain form data.\n *\n * ```html\n * <form>\n *   <input name=\"login\" ngModel placeholder=\"Login\">\n *   <input type=\"checkbox\" ngModel [ngModelOptions]=\"{standalone: true}\"> Show more options?\n * </form>\n * <!-- form value: {login: ''} -->\n * ```\n *\n * ### Setting the ngModel `name` attribute through options\n *\n * The following example shows you an alternate way to set the name attribute. Here,\n * an attribute identified as name is used within a custom form control component. To still be able\n * to specify the NgModel's name, you must specify it using the `ngModelOptions` input instead.\n *\n * ```html\n * <form>\n *   <my-custom-form-control name=\"Nancy\" ngModel [ngModelOptions]=\"{name: 'user'}\">\n *   </my-custom-form-control>\n * </form>\n * <!-- form value: {user: ''} -->\n * ```\n *\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector: '[ngModel]:not([formControlName]):not([formControl])',\n  providers: [formControlBinding],\n  exportAs: 'ngModel'\n})\nexport class NgModel extends NgControl implements OnChanges, OnDestroy {\n  public override readonly control: FormControl = new FormControl();\n\n  // At runtime we coerce arbitrary values assigned to the \"disabled\" input to a \"boolean\".\n  // This is not reflected in the type of the property because outside of templates, consumers\n  // should only deal with booleans. In templates, a string is allowed for convenience and to\n  // match the native \"disabled attribute\" semantics which can be observed on input elements.\n  // This static member tells the compiler that values of type \"string\" can also be assigned\n  // to the input in a template.\n  /** @nodoc */\n  static ngAcceptInputType_isDisabled: boolean|string;\n\n  /** @internal */\n  _registered = false;\n\n  /**\n   * Internal reference to the view model value.\n   * @nodoc\n   */\n  viewModel: any;\n\n  /**\n   * @description\n   * Tracks the name bound to the directive. If a parent form exists, it\n   * uses this name as a key to retrieve this control's value.\n   */\n  @Input() override name: string = '';\n\n  /**\n   * @description\n   * Tracks whether the control is disabled.\n   */\n  // TODO(issue/24571): remove '!'.\n  @Input('disabled') isDisabled!: boolean;\n\n  /**\n   * @description\n   * Tracks the value bound to this directive.\n   */\n  @Input('ngModel') model: any;\n\n  /**\n   * @description\n   * Tracks the configuration options for this `ngModel` instance.\n   *\n   * **name**: An alternative to setting the name attribute on the form control element. See\n   * the [example](api/forms/NgModel#using-ngmodel-on-a-standalone-control) for using `NgModel`\n   * as a standalone control.\n   *\n   * **standalone**: When set to true, the `ngModel` will not register itself with its parent form,\n   * and acts as if it's not in the form. Defaults to false. If no parent form exists, this option\n   * has no effect.\n   *\n   * **updateOn**: Defines the event upon which the form control value and validity update.\n   * Defaults to 'change'. Possible values: `'change'` | `'blur'` | `'submit'`.\n   *\n   */\n  // TODO(issue/24571): remove '!'.\n  @Input('ngModelOptions') options!: {name?: string, standalone?: boolean, updateOn?: FormHooks};\n\n  /**\n   * @description\n   * Event emitter for producing the `ngModelChange` event after\n   * the view model updates.\n   */\n  @Output('ngModelChange') update = new EventEmitter();\n\n  constructor(\n      @Optional() @Host() parent: ControlContainer,\n      @Optional() @Self() @Inject(NG_VALIDATORS) validators: (Validator|ValidatorFn)[],\n      @Optional() @Self() @Inject(NG_ASYNC_VALIDATORS) asyncValidators:\n          (AsyncValidator|AsyncValidatorFn)[],\n      @Optional() @Self() @Inject(NG_VALUE_ACCESSOR) valueAccessors: ControlValueAccessor[],\n      @Optional() @Inject(ChangeDetectorRef) private _changeDetectorRef?: ChangeDetectorRef|null,\n      @Optional() @Inject(CALL_SET_DISABLED_STATE) private callSetDisabledState?:\n          SetDisabledStateOption) {\n    super();\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n    this.valueAccessor = selectValueAccessor(this, valueAccessors);\n  }\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges) {\n    this._checkForErrors();\n    if (!this._registered || 'name' in changes) {\n      if (this._registered) {\n        this._checkName();\n        if (this.formDirective) {\n          // We can't call `formDirective.removeControl(this)`, because the `name` has already been\n          // changed. We also can't reset the name temporarily since the logic in `removeControl`\n          // is inside a promise and it won't run immediately. We work around it by giving it an\n          // object with the same shape instead.\n          const oldName = changes['name'].previousValue;\n          this.formDirective.removeControl({name: oldName, path: this._getPath(oldName)});\n        }\n      }\n      this._setUpControl();\n    }\n    if ('isDisabled' in changes) {\n      this._updateDisabled(changes);\n    }\n\n    if (isPropertyUpdated(changes, this.viewModel)) {\n      this._updateValue(this.model);\n      this.viewModel = this.model;\n    }\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    this.formDirective && this.formDirective.removeControl(this);\n  }\n\n  /**\n   * @description\n   * Returns an array that represents the path from the top-level form to this control.\n   * Each index is the string name of the control on that level.\n   */\n  override get path(): string[] {\n    return this._getPath(this.name);\n  }\n\n  /**\n   * @description\n   * The top-level directive for this control if present, otherwise null.\n   */\n  get formDirective(): any {\n    return this._parent ? this._parent.formDirective : null;\n  }\n\n  /**\n   * @description\n   * Sets the new value for the view model and emits an `ngModelChange` event.\n   *\n   * @param newValue The new value emitted by `ngModelChange`.\n   */\n  override viewToModelUpdate(newValue: any): void {\n    this.viewModel = newValue;\n    this.update.emit(newValue);\n  }\n\n  private _setUpControl(): void {\n    this._setUpdateStrategy();\n    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);\n    this._registered = true;\n  }\n\n  private _setUpdateStrategy(): void {\n    if (this.options && this.options.updateOn != null) {\n      this.control._updateOn = this.options.updateOn;\n    }\n  }\n\n  private _isStandalone(): boolean {\n    return !this._parent || !!(this.options && this.options.standalone);\n  }\n\n  private _setUpStandalone(): void {\n    setUpControl(this.control, this, this.callSetDisabledState);\n    this.control.updateValueAndValidity({emitEvent: false});\n  }\n\n  private _checkForErrors(): void {\n    if (!this._isStandalone()) {\n      this._checkParentType();\n    }\n    this._checkName();\n  }\n\n  private _checkParentType(): void {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!(this._parent instanceof NgModelGroup) &&\n          this._parent instanceof AbstractFormGroupDirective) {\n        throw formGroupNameException();\n      } else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {\n        throw modelParentException();\n      }\n    }\n  }\n\n  private _checkName(): void {\n    if (this.options && this.options.name) this.name = this.options.name;\n\n    if (!this._isStandalone() && !this.name && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw missingNameException();\n    }\n  }\n\n  private _updateValue(value: any): void {\n    resolvedPromise.then(() => {\n      this.control.setValue(value, {emitViewToModelChange: false});\n      this._changeDetectorRef?.markForCheck();\n    });\n  }\n\n  private _updateDisabled(changes: SimpleChanges) {\n    const disabledValue = changes['isDisabled'].currentValue;\n    // checking for 0 to avoid breaking change\n    const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);\n\n    resolvedPromise.then(() => {\n      if (isDisabled && !this.control.disabled) {\n        this.control.disable();\n      } else if (!isDisabled && this.control.disabled) {\n        this.control.enable();\n      }\n\n      this._changeDetectorRef?.markForCheck();\n    });\n  }\n\n  private _getPath(controlName: string): string[] {\n    return this._parent ? controlPath(controlName, this._parent) : [controlName];\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive} from '@angular/core';\n\n/**\n * @description\n *\n * Adds `novalidate` attribute to all forms by default.\n *\n * `novalidate` is used to disable browser's native form validation.\n *\n * If you want to use native validation with Angular forms, just add `ngNativeValidate` attribute:\n *\n * ```\n * <form ngNativeValidate></form>\n * ```\n *\n * @publicApi\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n */\n@Directive({\n  selector: 'form:not([ngNoForm]):not([ngNativeValidate])',\n  host: {'novalidate': ''},\n})\nexport class NgNoValidate {\n}\n\nexport {NgNoValidate as NgNoValidate};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, forwardRef, Provider} from '@angular/core';\n\nimport {BuiltInControlValueAccessor, ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\n\nconst NUMBER_VALUE_ACCESSOR: Provider = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => NumberValueAccessor),\n  multi: true\n};\n\n/**\n * @description\n * The `ControlValueAccessor` for writing a number value and listening to number input changes.\n * The value accessor is used by the `FormControlDirective`, `FormControlName`, and `NgModel`\n * directives.\n *\n * @usageNotes\n *\n * ### Using a number input with a reactive form.\n *\n * The following example shows how to use a number input with a reactive form.\n *\n * ```ts\n * const totalCountControl = new FormControl();\n * ```\n *\n * ```\n * <input type=\"number\" [formControl]=\"totalCountControl\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector:\n      'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',\n  host: {'(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()'},\n  providers: [NUMBER_VALUE_ACCESSOR]\n})\nexport class NumberValueAccessor extends BuiltInControlValueAccessor implements\n    ControlValueAccessor {\n  /**\n   * Sets the \"value\" property on the input element.\n   * @nodoc\n   */\n  writeValue(value: number): void {\n    // The value needs to be normalized for IE9, otherwise it is set to 'null' when null\n    const normalizedValue = value == null ? '' : value;\n    this.setProperty('value', normalizedValue);\n  }\n\n  /**\n   * Registers a function called when the control value changes.\n   * @nodoc\n   */\n  override registerOnChange(fn: (_: number|null) => void): void {\n    this.onChange = (value) => {\n      fn(value == '' ? null : parseFloat(value));\n    };\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, forwardRef, inject, Injectable, Injector, Input, NgModule, OnDestroy, OnInit, Provider, Renderer2, RuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\n\nimport {BuiltInControlValueAccessor, ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\nimport {NgControl} from './ng_control';\nimport {CALL_SET_DISABLED_STATE, setDisabledStateDefault, SetDisabledStateOption} from './shared';\n\nconst RADIO_VALUE_ACCESSOR: Provider = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => RadioControlValueAccessor),\n  multi: true\n};\n\nfunction throwNameError() {\n  throw new RuntimeError(RuntimeErrorCode.NAME_AND_FORM_CONTROL_NAME_MUST_MATCH, `\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type=\"radio\" formControlName=\"food\" name=\"food\">\n    `);\n}\n\n/**\n * Internal-only NgModule that works as a host for the `RadioControlRegistry` tree-shakable\n * provider. Note: the `InternalFormsSharedModule` can not be used here directly, since it's\n * declared *after* the `RadioControlRegistry` class and the `providedIn` doesn't support\n * `forwardRef` logic.\n */\n@NgModule()\nexport class RadioControlRegistryModule {\n}\n\n/**\n * @description\n * Class used by Angular to track radio buttons. For internal use only.\n */\n@Injectable({providedIn: RadioControlRegistryModule})\nexport class RadioControlRegistry {\n  private _accessors: any[] = [];\n\n  /**\n   * @description\n   * Adds a control to the internal registry. For internal use only.\n   */\n  add(control: NgControl, accessor: RadioControlValueAccessor) {\n    this._accessors.push([control, accessor]);\n  }\n\n  /**\n   * @description\n   * Removes a control from the internal registry. For internal use only.\n   */\n  remove(accessor: RadioControlValueAccessor) {\n    for (let i = this._accessors.length - 1; i >= 0; --i) {\n      if (this._accessors[i][1] === accessor) {\n        this._accessors.splice(i, 1);\n        return;\n      }\n    }\n  }\n\n  /**\n   * @description\n   * Selects a radio button. For internal use only.\n   */\n  select(accessor: RadioControlValueAccessor) {\n    this._accessors.forEach((c) => {\n      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {\n        c[1].fireUncheck(accessor.value);\n      }\n    });\n  }\n\n  private _isSameGroup(\n      controlPair: [NgControl, RadioControlValueAccessor],\n      accessor: RadioControlValueAccessor): boolean {\n    if (!controlPair[0].control) return false;\n    return controlPair[0]._parent === accessor._control._parent &&\n        controlPair[1].name === accessor.name;\n  }\n}\n\n/**\n * @description\n * The `ControlValueAccessor` for writing radio control values and listening to radio control\n * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\n * `NgModel` directives.\n *\n * @usageNotes\n *\n * ### Using radio buttons with reactive form directives\n *\n * The follow example shows how to use radio buttons in a reactive form. When using radio buttons in\n * a reactive form, radio buttons in the same group should have the same `formControlName`.\n * Providing a `name` attribute is optional.\n *\n * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector:\n      'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',\n  host: {'(change)': 'onChange()', '(blur)': 'onTouched()'},\n  providers: [RADIO_VALUE_ACCESSOR]\n})\nexport class RadioControlValueAccessor extends BuiltInControlValueAccessor implements\n    ControlValueAccessor, OnDestroy, OnInit {\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _state!: boolean;\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _control!: NgControl;\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _fn!: Function;\n\n  private setDisabledStateFired = false;\n\n  /**\n   * The registered callback function called when a change event occurs on the input element.\n   * Note: we declare `onChange` here (also used as host listener) as a function with no arguments\n   * to override the `onChange` function (which expects 1 argument) in the parent\n   * `BaseControlValueAccessor` class.\n   * @nodoc\n   */\n  override onChange = () => {};\n\n  /**\n   * @description\n   * Tracks the name of the radio input element.\n   */\n  // TODO(issue/24571): remove '!'.\n  @Input() name!: string;\n\n  /**\n   * @description\n   * Tracks the name of the `FormControl` bound to the directive. The name corresponds\n   * to a key in the parent `FormGroup` or `FormArray`.\n   */\n  // TODO(issue/24571): remove '!'.\n  @Input() formControlName!: string;\n\n  /**\n   * @description\n   * Tracks the value of the radio input element\n   */\n  @Input() value: any;\n\n  private callSetDisabledState =\n      inject(CALL_SET_DISABLED_STATE, {optional: true}) ?? setDisabledStateDefault;\n\n  constructor(\n      renderer: Renderer2, elementRef: ElementRef, private _registry: RadioControlRegistry,\n      private _injector: Injector) {\n    super(renderer, elementRef);\n  }\n\n  /** @nodoc */\n  ngOnInit(): void {\n    this._control = this._injector.get(NgControl);\n    this._checkName();\n    this._registry.add(this._control, this);\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    this._registry.remove(this);\n  }\n\n  /**\n   * Sets the \"checked\" property value on the radio input element.\n   * @nodoc\n   */\n  writeValue(value: any): void {\n    this._state = value === this.value;\n    this.setProperty('checked', this._state);\n  }\n\n  /**\n   * Registers a function called when the control value changes.\n   * @nodoc\n   */\n  override registerOnChange(fn: (_: any) => {}): void {\n    this._fn = fn;\n    this.onChange = () => {\n      fn(this.value);\n      this._registry.select(this);\n    };\n  }\n\n  /** @nodoc */\n  override setDisabledState(isDisabled: boolean): void {\n    /**\n     * `setDisabledState` is supposed to be called whenever the disabled state of a control changes,\n     * including upon control creation. However, a longstanding bug caused the method to not fire\n     * when an *enabled* control was attached. This bug was fixed in v15 in #47576.\n     *\n     * This had a side effect: previously, it was possible to instantiate a reactive form control\n     * with `[attr.disabled]=true`, even though the corresponding control was enabled in the\n     * model. This resulted in a mismatch between the model and the DOM. Now, because\n     * `setDisabledState` is always called, the value in the DOM will be immediately overwritten\n     * with the \"correct\" enabled value.\n     *\n     * However, the fix also created an exceptional case: radio buttons. Because Reactive Forms\n     * models the entire group of radio buttons as a single `FormControl`, there is no way to\n     * control the disabled state for individual radios, so they can no longer be configured as\n     * disabled. Thus, we keep the old behavior for radio buttons, so that `[attr.disabled]`\n     * continues to work. Specifically, we drop the first call to `setDisabledState` if `disabled`\n     * is `false`, and we are not in legacy mode.\n     */\n    if (this.setDisabledStateFired || isDisabled ||\n        this.callSetDisabledState === 'whenDisabledForLegacyCode') {\n      this.setProperty('disabled', isDisabled);\n    }\n    this.setDisabledStateFired = true;\n  }\n\n  /**\n   * Sets the \"value\" on the radio input element and unchecks it.\n   *\n   * @param value\n   */\n  fireUncheck(value: any): void {\n    this.writeValue(value);\n  }\n\n  private _checkName(): void {\n    if (this.name && this.formControlName && this.name !== this.formControlName &&\n        (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throwNameError();\n    }\n    if (!this.name && this.formControlName) this.name = this.formControlName;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, forwardRef, Provider} from '@angular/core';\n\nimport {BuiltInControlValueAccessor, ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\n\nconst RANGE_VALUE_ACCESSOR: Provider = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => RangeValueAccessor),\n  multi: true\n};\n\n/**\n * @description\n * The `ControlValueAccessor` for writing a range value and listening to range input changes.\n * The value accessor is used by the `FormControlDirective`, `FormControlName`, and  `NgModel`\n * directives.\n *\n * @usageNotes\n *\n * ### Using a range input with a reactive form\n *\n * The following example shows how to use a range input with a reactive form.\n *\n * ```ts\n * const ageControl = new FormControl();\n * ```\n *\n * ```\n * <input type=\"range\" [formControl]=\"ageControl\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector:\n      'input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]',\n  host: {\n    '(change)': 'onChange($event.target.value)',\n    '(input)': 'onChange($event.target.value)',\n    '(blur)': 'onTouched()'\n  },\n  providers: [RANGE_VALUE_ACCESSOR]\n})\nexport class RangeValueAccessor extends BuiltInControlValueAccessor implements\n    ControlValueAccessor {\n  /**\n   * Sets the \"value\" property on the input element.\n   * @nodoc\n   */\n  writeValue(value: any): void {\n    this.setProperty('value', parseFloat(value));\n  }\n\n  /**\n   * Registers a function called when the control value changes.\n   * @nodoc\n   */\n  override registerOnChange(fn: (_: number|null) => void): void {\n    this.onChange = (value) => {\n      fn(value == '' ? null : parseFloat(value));\n    };\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, EventEmitter, forwardRef, Inject, InjectionToken, Input, OnChanges, OnDestroy, Optional, Output, Provider, Self, SimpleChanges} from '@angular/core';\n\nimport {FormControl} from '../../model/form_control';\nimport {NG_ASYNC_VALIDATORS, NG_VALIDATORS} from '../../validators';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '../control_value_accessor';\nimport {NgControl} from '../ng_control';\nimport {disabledAttrWarning} from '../reactive_errors';\nimport {_ngModelWarning, CALL_SET_DISABLED_STATE, cleanUpControl, isPropertyUpdated, selectValueAccessor, SetDisabledStateOption, setUpControl} from '../shared';\nimport {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from '../validators';\n\n\n/**\n * Token to provide to turn off the ngModel warning on formControl and formControlName.\n */\nexport const NG_MODEL_WITH_FORM_CONTROL_WARNING =\n    new InjectionToken('NgModelWithFormControlWarning');\n\nconst formControlBinding: Provider = {\n  provide: NgControl,\n  useExisting: forwardRef(() => FormControlDirective)\n};\n\n/**\n * @description\n * Synchronizes a standalone `FormControl` instance to a form control element.\n *\n * Note that support for using the `ngModel` input property and `ngModelChange` event with reactive\n * form directives was deprecated in Angular v6 and is scheduled for removal in\n * a future version of Angular.\n * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see {@link FormControl}\n * @see {@link AbstractControl}\n *\n * @usageNotes\n *\n * The following example shows how to register a standalone control and set its value.\n *\n * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\n@Directive({selector: '[formControl]', providers: [formControlBinding], exportAs: 'ngForm'})\nexport class FormControlDirective extends NgControl implements OnChanges, OnDestroy {\n  /**\n   * Internal reference to the view model value.\n   * @nodoc\n   */\n  viewModel: any;\n\n  /**\n   * @description\n   * Tracks the `FormControl` instance bound to the directive.\n   */\n  // TODO(issue/24571): remove '!'.\n  @Input('formControl') form!: FormControl;\n\n  /**\n   * @description\n   * Triggers a warning in dev mode that this input should not be used with reactive forms.\n   */\n  @Input('disabled')\n  set isDisabled(isDisabled: boolean) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      console.warn(disabledAttrWarning);\n    }\n  }\n\n  // TODO(kara): remove next 4 properties once deprecation period is over\n\n  /** @deprecated as of v6 */\n  @Input('ngModel') model: any;\n\n  /** @deprecated as of v6 */\n  @Output('ngModelChange') update = new EventEmitter();\n\n  /**\n   * @description\n   * Static property used to track whether any ngModel warnings have been sent across\n   * all instances of FormControlDirective. Used to support warning config of \"once\".\n   *\n   * @internal\n   */\n  static _ngModelWarningSentOnce = false;\n\n  /**\n   * @description\n   * Instance property used to track whether an ngModel warning has been sent out for this\n   * particular `FormControlDirective` instance. Used to support warning config of \"always\".\n   *\n   * @internal\n   */\n  _ngModelWarningSent = false;\n\n  constructor(\n      @Optional() @Self() @Inject(NG_VALIDATORS) validators: (Validator|ValidatorFn)[],\n      @Optional() @Self() @Inject(NG_ASYNC_VALIDATORS) asyncValidators:\n          (AsyncValidator|AsyncValidatorFn)[],\n      @Optional() @Self() @Inject(NG_VALUE_ACCESSOR) valueAccessors: ControlValueAccessor[],\n      @Optional() @Inject(NG_MODEL_WITH_FORM_CONTROL_WARNING) private _ngModelWarningConfig: string|\n      null,\n      @Optional() @Inject(CALL_SET_DISABLED_STATE) private callSetDisabledState?:\n          SetDisabledStateOption) {\n    super();\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n    this.valueAccessor = selectValueAccessor(this, valueAccessors);\n  }\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges): void {\n    if (this._isControlChanged(changes)) {\n      const previousForm = changes['form'].previousValue;\n      if (previousForm) {\n        cleanUpControl(previousForm, this, /* validateControlPresenceOnChange */ false);\n      }\n      setUpControl(this.form, this, this.callSetDisabledState);\n      this.form.updateValueAndValidity({emitEvent: false});\n    }\n    if (isPropertyUpdated(changes, this.viewModel)) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        _ngModelWarning('formControl', FormControlDirective, this, this._ngModelWarningConfig);\n      }\n      this.form.setValue(this.model);\n      this.viewModel = this.model;\n    }\n  }\n\n  /** @nodoc */\n  ngOnDestroy() {\n    if (this.form) {\n      cleanUpControl(this.form, this, /* validateControlPresenceOnChange */ false);\n    }\n  }\n\n  /**\n   * @description\n   * Returns an array that represents the path from the top-level form to this control.\n   * Each index is the string name of the control on that level.\n   */\n  override get path(): string[] {\n    return [];\n  }\n\n  /**\n   * @description\n   * The `FormControl` bound to this directive.\n   */\n  override get control(): FormControl {\n    return this.form;\n  }\n\n  /**\n   * @description\n   * Sets the new value for the view model and emits an `ngModelChange` event.\n   *\n   * @param newValue The new value for the view model.\n   */\n  override viewToModelUpdate(newValue: any): void {\n    this.viewModel = newValue;\n    this.update.emit(newValue);\n  }\n\n  private _isControlChanged(changes: {[key: string]: any}): boolean {\n    return changes.hasOwnProperty('form');\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, EventEmitter, forwardRef, Inject, Input, OnChanges, OnDestroy, Optional, Output, Provider, Self, SimpleChanges, Writable as Writable} from '@angular/core';\n\nimport {FormArray} from '../../model/form_array';\nimport {FormControl, isFormControl} from '../../model/form_control';\nimport {FormGroup} from '../../model/form_group';\nimport {NG_ASYNC_VALIDATORS, NG_VALIDATORS} from '../../validators';\nimport {ControlContainer} from '../control_container';\nimport {Form} from '../form_interface';\nimport {missingFormException} from '../reactive_errors';\nimport {CALL_SET_DISABLED_STATE, cleanUpControl, cleanUpFormContainer, cleanUpValidators, removeListItem, SetDisabledStateOption, setUpControl, setUpFormContainer, setUpValidators, syncPendingControls} from '../shared';\nimport {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from '../validators';\n\nimport {FormControlName} from './form_control_name';\nimport {FormArrayName, FormGroupName} from './form_group_name';\n\nconst formDirectiveProvider: Provider = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => FormGroupDirective)\n};\n\n/**\n * @description\n *\n * Binds an existing `FormGroup` or `FormRecord` to a DOM element.\n *\n * This directive accepts an existing `FormGroup` instance. It will then use this\n * `FormGroup` instance to match any child `FormControl`, `FormGroup`/`FormRecord`,\n * and `FormArray` instances to child `FormControlName`, `FormGroupName`,\n * and `FormArrayName` directives.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see {@link AbstractControl}\n *\n * @usageNotes\n * ### Register Form Group\n *\n * The following example registers a `FormGroup` with first name and last name controls,\n * and listens for the *ngSubmit* event when the button is clicked.\n *\n * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\n@Directive({\n  selector: '[formGroup]',\n  providers: [formDirectiveProvider],\n  host: {'(submit)': 'onSubmit($event)', '(reset)': 'onReset()'},\n  exportAs: 'ngForm'\n})\nexport class FormGroupDirective extends ControlContainer implements Form, OnChanges, OnDestroy {\n  /**\n   * @description\n   * Reports whether the form submission has been triggered.\n   */\n  public readonly submitted: boolean = false;\n\n  /**\n   * Reference to an old form group input value, which is needed to cleanup old instance in case it\n   * was replaced with a new one.\n   */\n  private _oldForm: FormGroup|undefined;\n\n  /**\n   * Callback that should be invoked when controls in FormGroup or FormArray collection change\n   * (added or removed). This callback triggers corresponding DOM updates.\n   */\n  private readonly _onCollectionChange = () => this._updateDomValue();\n\n  /**\n   * @description\n   * Tracks the list of added `FormControlName` instances\n   */\n  directives: FormControlName[] = [];\n\n  /**\n   * @description\n   * Tracks the `FormGroup` bound to this directive.\n   */\n  @Input('formGroup') form: FormGroup = null!;\n\n  /**\n   * @description\n   * Emits an event when the form submission has been triggered.\n   */\n  @Output() ngSubmit = new EventEmitter();\n\n  constructor(\n      @Optional() @Self() @Inject(NG_VALIDATORS) validators: (Validator|ValidatorFn)[],\n      @Optional() @Self() @Inject(NG_ASYNC_VALIDATORS) asyncValidators:\n          (AsyncValidator|AsyncValidatorFn)[],\n      @Optional() @Inject(CALL_SET_DISABLED_STATE) private callSetDisabledState?:\n          SetDisabledStateOption) {\n    super();\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n  }\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges): void {\n    this._checkFormPresent();\n    if (changes.hasOwnProperty('form')) {\n      this._updateValidators();\n      this._updateDomValue();\n      this._updateRegistrations();\n      this._oldForm = this.form;\n    }\n  }\n\n  /** @nodoc */\n  ngOnDestroy() {\n    if (this.form) {\n      cleanUpValidators(this.form, this);\n\n      // Currently the `onCollectionChange` callback is rewritten each time the\n      // `_registerOnCollectionChange` function is invoked. The implication is that cleanup should\n      // happen *only* when the `onCollectionChange` callback was set by this directive instance.\n      // Otherwise it might cause overriding a callback of some other directive instances. We should\n      // consider updating this logic later to make it similar to how `onChange` callbacks are\n      // handled, see https://github.com/angular/angular/issues/39732 for additional info.\n      if (this.form._onCollectionChange === this._onCollectionChange) {\n        this.form._registerOnCollectionChange(() => {});\n      }\n    }\n  }\n\n  /**\n   * @description\n   * Returns this directive's instance.\n   */\n  override get formDirective(): Form {\n    return this;\n  }\n\n  /**\n   * @description\n   * Returns the `FormGroup` bound to this directive.\n   */\n  override get control(): FormGroup {\n    return this.form;\n  }\n\n  /**\n   * @description\n   * Returns an array representing the path to this group. Because this directive\n   * always lives at the top level of a form, it always an empty array.\n   */\n  override get path(): string[] {\n    return [];\n  }\n\n  /**\n   * @description\n   * Method that sets up the control directive in this group, re-calculates its value\n   * and validity, and adds the instance to the internal list of directives.\n   *\n   * @param dir The `FormControlName` directive instance.\n   */\n  addControl(dir: FormControlName): FormControl {\n    const ctrl: any = this.form.get(dir.path);\n    setUpControl(ctrl, dir, this.callSetDisabledState);\n    ctrl.updateValueAndValidity({emitEvent: false});\n    this.directives.push(dir);\n    return ctrl;\n  }\n\n  /**\n   * @description\n   * Retrieves the `FormControl` instance from the provided `FormControlName` directive\n   *\n   * @param dir The `FormControlName` directive instance.\n   */\n  getControl(dir: FormControlName): FormControl {\n    return <FormControl>this.form.get(dir.path);\n  }\n\n  /**\n   * @description\n   * Removes the `FormControlName` instance from the internal list of directives\n   *\n   * @param dir The `FormControlName` directive instance.\n   */\n  removeControl(dir: FormControlName): void {\n    cleanUpControl(dir.control || null, dir, /* validateControlPresenceOnChange */ false);\n    removeListItem(this.directives, dir);\n  }\n\n  /**\n   * Adds a new `FormGroupName` directive instance to the form.\n   *\n   * @param dir The `FormGroupName` directive instance.\n   */\n  addFormGroup(dir: FormGroupName): void {\n    this._setUpFormContainer(dir);\n  }\n\n  /**\n   * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the\n   * view.\n   *\n   * @param dir The `FormGroupName` directive instance.\n   */\n  removeFormGroup(dir: FormGroupName): void {\n    this._cleanUpFormContainer(dir);\n  }\n\n  /**\n   * @description\n   * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance\n   *\n   * @param dir The `FormGroupName` directive instance.\n   */\n  getFormGroup(dir: FormGroupName): FormGroup {\n    return <FormGroup>this.form.get(dir.path);\n  }\n\n  /**\n   * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.\n   *\n   * @param dir The `FormArrayName` directive instance.\n   */\n  addFormArray(dir: FormArrayName): void {\n    this._setUpFormContainer(dir);\n  }\n\n  /**\n   * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the\n   * view.\n   *\n   * @param dir The `FormArrayName` directive instance.\n   */\n  removeFormArray(dir: FormArrayName): void {\n    this._cleanUpFormContainer(dir);\n  }\n\n  /**\n   * @description\n   * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.\n   *\n   * @param dir The `FormArrayName` directive instance.\n   */\n  getFormArray(dir: FormArrayName): FormArray {\n    return <FormArray>this.form.get(dir.path);\n  }\n\n  /**\n   * Sets the new value for the provided `FormControlName` directive.\n   *\n   * @param dir The `FormControlName` directive instance.\n   * @param value The new value for the directive's control.\n   */\n  updateModel(dir: FormControlName, value: any): void {\n    const ctrl = <FormControl>this.form.get(dir.path);\n    ctrl.setValue(value);\n  }\n\n  /**\n   * @description\n   * Method called with the \"submit\" event is triggered on the form.\n   * Triggers the `ngSubmit` emitter to emit the \"submit\" event as its payload.\n   *\n   * @param $event The \"submit\" event object\n   */\n  onSubmit($event: Event): boolean {\n    (this as Writable<this>).submitted = true;\n    syncPendingControls(this.form, this.directives);\n    this.ngSubmit.emit($event);\n    // Forms with `method=\"dialog\"` have some special behavior that won't reload the page and that\n    // shouldn't be prevented. Note that we need to null check the `event` and the `target`, because\n    // some internal apps call this method directly with the wrong arguments.\n    return ($event?.target as HTMLFormElement | null)?.method === 'dialog';\n  }\n\n  /**\n   * @description\n   * Method called when the \"reset\" event is triggered on the form.\n   */\n  onReset(): void {\n    this.resetForm();\n  }\n\n  /**\n   * @description\n   * Resets the form to an initial value and resets its submitted status.\n   *\n   * @param value The new value for the form.\n   */\n  resetForm(value: any = undefined): void {\n    this.form.reset(value);\n    (this as Writable<this>).submitted = false;\n  }\n\n  /** @internal */\n  _updateDomValue() {\n    this.directives.forEach(dir => {\n      const oldCtrl = dir.control;\n      const newCtrl = this.form.get(dir.path);\n      if (oldCtrl !== newCtrl) {\n        // Note: the value of the `dir.control` may not be defined, for example when it's a first\n        // `FormControl` that is added to a `FormGroup` instance (via `addControl` call).\n        cleanUpControl(oldCtrl || null, dir);\n\n        // Check whether new control at the same location inside the corresponding `FormGroup` is an\n        // instance of `FormControl` and perform control setup only if that's the case.\n        // Note: we don't need to clear the list of directives (`this.directives`) here, it would be\n        // taken care of in the `removeControl` method invoked when corresponding `formControlName`\n        // directive instance is being removed (invoked from `FormControlName.ngOnDestroy`).\n        if (isFormControl(newCtrl)) {\n          setUpControl(newCtrl, dir, this.callSetDisabledState);\n          (dir as Writable<FormControlName>).control = newCtrl;\n        }\n      }\n    });\n\n    this.form._updateTreeValidity({emitEvent: false});\n  }\n\n  private _setUpFormContainer(dir: FormArrayName|FormGroupName): void {\n    const ctrl: any = this.form.get(dir.path);\n    setUpFormContainer(ctrl, dir);\n    // NOTE: this operation looks unnecessary in case no new validators were added in\n    // `setUpFormContainer` call. Consider updating this code to match the logic in\n    // `_cleanUpFormContainer` function.\n    ctrl.updateValueAndValidity({emitEvent: false});\n  }\n\n  private _cleanUpFormContainer(dir: FormArrayName|FormGroupName): void {\n    if (this.form) {\n      const ctrl: any = this.form.get(dir.path);\n      if (ctrl) {\n        const isControlUpdated = cleanUpFormContainer(ctrl, dir);\n        if (isControlUpdated) {\n          // Run validity check only in case a control was updated (i.e. view validators were\n          // removed) as removing view validators might cause validity to change.\n          ctrl.updateValueAndValidity({emitEvent: false});\n        }\n      }\n    }\n  }\n\n  private _updateRegistrations() {\n    this.form._registerOnCollectionChange(this._onCollectionChange);\n    if (this._oldForm) {\n      this._oldForm._registerOnCollectionChange(() => {});\n    }\n  }\n\n  private _updateValidators() {\n    setUpValidators(this.form, this);\n    if (this._oldForm) {\n      cleanUpValidators(this._oldForm, this);\n    }\n  }\n\n  private _checkFormPresent() {\n    if (!this.form && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw missingFormException();\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, forwardRef, Host, Inject, Input, OnDestroy, OnInit, Optional, Provider, Self, SkipSelf} from '@angular/core';\n\nimport {FormArray} from '../../model/form_array';\nimport {NG_ASYNC_VALIDATORS, NG_VALIDATORS} from '../../validators';\nimport {AbstractFormGroupDirective} from '../abstract_form_group_directive';\nimport {ControlContainer} from '../control_container';\nimport {arrayParentException, groupParentException} from '../reactive_errors';\nimport {controlPath} from '../shared';\nimport {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from '../validators';\n\nimport {FormGroupDirective} from './form_group_directive';\n\nconst formGroupNameProvider: Provider = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => FormGroupName)\n};\n\n/**\n * @description\n *\n * Syncs a nested `FormGroup` or `FormRecord` to a DOM element.\n *\n * This directive can only be used with a parent `FormGroupDirective`.\n *\n * It accepts the string name of the nested `FormGroup` or `FormRecord` to link, and\n * looks for a `FormGroup` or `FormRecord` registered with that name in the parent\n * `FormGroup` instance you passed into `FormGroupDirective`.\n *\n * Use nested form groups to validate a sub-group of a\n * form separately from the rest or to group the values of certain\n * controls into their own nested object.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n *\n * @usageNotes\n *\n * ### Access the group by name\n *\n * The following example uses the `AbstractControl.get` method to access the\n * associated `FormGroup`\n *\n * ```ts\n *   this.form.get('name');\n * ```\n *\n * ### Access individual controls in the group\n *\n * The following example uses the `AbstractControl.get` method to access\n * individual controls within the group using dot syntax.\n *\n * ```ts\n *   this.form.get('name.first');\n * ```\n *\n * ### Register a nested `FormGroup`.\n *\n * The following example registers a nested *name* `FormGroup` within an existing `FormGroup`,\n * and provides methods to retrieve the nested `FormGroup` and individual controls.\n *\n * {@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\n@Directive({selector: '[formGroupName]', providers: [formGroupNameProvider]})\nexport class FormGroupName extends AbstractFormGroupDirective implements OnInit, OnDestroy {\n  /**\n   * @description\n   * Tracks the name of the `FormGroup` bound to the directive. The name corresponds\n   * to a key in the parent `FormGroup` or `FormArray`.\n   * Accepts a name as a string or a number.\n   * The name in the form of a string is useful for individual forms,\n   * while the numerical form allows for form groups to be bound\n   * to indices when iterating over groups in a `FormArray`.\n   */\n  @Input('formGroupName') override name: string|number|null = null;\n\n  constructor(\n      @Optional() @Host() @SkipSelf() parent: ControlContainer,\n      @Optional() @Self() @Inject(NG_VALIDATORS) validators: (Validator|ValidatorFn)[],\n      @Optional() @Self() @Inject(NG_ASYNC_VALIDATORS) asyncValidators:\n          (AsyncValidator|AsyncValidatorFn)[]) {\n    super();\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n  }\n\n  /** @internal */\n  override _checkParentType(): void {\n    if (_hasInvalidParent(this._parent) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw groupParentException();\n    }\n  }\n}\n\nexport const formArrayNameProvider: any = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => FormArrayName)\n};\n\n/**\n * @description\n *\n * Syncs a nested `FormArray` to a DOM element.\n *\n * This directive is designed to be used with a parent `FormGroupDirective` (selector:\n * `[formGroup]`).\n *\n * It accepts the string name of the nested `FormArray` you want to link, and\n * will look for a `FormArray` registered with that name in the parent\n * `FormGroup` instance you passed into `FormGroupDirective`.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see {@link AbstractControl}\n *\n * @usageNotes\n *\n * ### Example\n *\n * {@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\n@Directive({selector: '[formArrayName]', providers: [formArrayNameProvider]})\nexport class FormArrayName extends ControlContainer implements OnInit, OnDestroy {\n  /** @internal */\n  _parent: ControlContainer;\n\n  /**\n   * @description\n   * Tracks the name of the `FormArray` bound to the directive. The name corresponds\n   * to a key in the parent `FormGroup` or `FormArray`.\n   * Accepts a name as a string or a number.\n   * The name in the form of a string is useful for individual forms,\n   * while the numerical form allows for form arrays to be bound\n   * to indices when iterating over arrays in a `FormArray`.\n   */\n  @Input('formArrayName') override name: string|number|null = null;\n\n  constructor(\n      @Optional() @Host() @SkipSelf() parent: ControlContainer,\n      @Optional() @Self() @Inject(NG_VALIDATORS) validators: (Validator|ValidatorFn)[],\n      @Optional() @Self() @Inject(NG_ASYNC_VALIDATORS) asyncValidators:\n          (AsyncValidator|AsyncValidatorFn)[]) {\n    super();\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n  }\n\n  /**\n   * A lifecycle method called when the directive's inputs are initialized. For internal use only.\n   * @throws If the directive does not have a valid parent.\n   * @nodoc\n   */\n  ngOnInit(): void {\n    this._checkParentType();\n    this.formDirective!.addFormArray(this);\n  }\n\n  /**\n   * A lifecycle method called before the directive's instance is destroyed. For internal use only.\n   * @nodoc\n   */\n  ngOnDestroy(): void {\n    if (this.formDirective) {\n      this.formDirective.removeFormArray(this);\n    }\n  }\n\n  /**\n   * @description\n   * The `FormArray` bound to this directive.\n   */\n  override get control(): FormArray {\n    return this.formDirective!.getFormArray(this);\n  }\n\n  /**\n   * @description\n   * The top-level directive for this group if present, otherwise null.\n   */\n  override get formDirective(): FormGroupDirective|null {\n    return this._parent ? <FormGroupDirective>this._parent.formDirective : null;\n  }\n\n  /**\n   * @description\n   * Returns an array that represents the path from the top-level form to this control.\n   * Each index is the string name of the control on that level.\n   */\n  override get path(): string[] {\n    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);\n  }\n\n  private _checkParentType(): void {\n    if (_hasInvalidParent(this._parent) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw arrayParentException();\n    }\n  }\n}\n\nfunction _hasInvalidParent(parent: ControlContainer): boolean {\n  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) &&\n      !(parent instanceof FormArrayName);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, EventEmitter, forwardRef, Host, Inject, Input, OnChanges, OnDestroy, Optional, Output, Provider, Self, SimpleChanges, SkipSelf, Writable as Writable} from '@angular/core';\n\nimport {FormControl} from '../../model/form_control';\nimport {NG_ASYNC_VALIDATORS, NG_VALIDATORS} from '../../validators';\nimport {AbstractFormGroupDirective} from '../abstract_form_group_directive';\nimport {ControlContainer} from '../control_container';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '../control_value_accessor';\nimport {NgControl} from '../ng_control';\nimport {controlParentException, disabledAttrWarning, ngModelGroupException} from '../reactive_errors';\nimport {_ngModelWarning, controlPath, isPropertyUpdated, selectValueAccessor} from '../shared';\nimport {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from '../validators';\n\nimport {NG_MODEL_WITH_FORM_CONTROL_WARNING} from './form_control_directive';\nimport {FormGroupDirective} from './form_group_directive';\nimport {FormArrayName, FormGroupName} from './form_group_name';\n\nconst controlNameBinding: Provider = {\n  provide: NgControl,\n  useExisting: forwardRef(() => FormControlName)\n};\n\n/**\n * @description\n * Syncs a `FormControl` in an existing `FormGroup` to a form control\n * element by name.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see {@link FormControl}\n * @see {@link AbstractControl}\n *\n * @usageNotes\n *\n * ### Register `FormControl` within a group\n *\n * The following example shows how to register multiple form controls within a form group\n * and set their value.\n *\n * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\n *\n * To see `formControlName` examples with different form control types, see:\n *\n * * Radio buttons: `RadioControlValueAccessor`\n * * Selects: `SelectControlValueAccessor`\n *\n * ### Use with ngModel is deprecated\n *\n * Support for using the `ngModel` input property and `ngModelChange` event with reactive\n * form directives has been deprecated in Angular v6 and is scheduled for removal in\n * a future version of Angular.\n *\n * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).\n *\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\n@Directive({selector: '[formControlName]', providers: [controlNameBinding]})\nexport class FormControlName extends NgControl implements OnChanges, OnDestroy {\n  private _added = false;\n  /**\n   * Internal reference to the view model value.\n   * @internal\n   */\n  viewModel: any;\n\n  /**\n   * @description\n   * Tracks the `FormControl` instance bound to the directive.\n   */\n  // TODO(issue/24571): remove '!'.\n  override readonly control!: FormControl;\n\n  /**\n   * @description\n   * Tracks the name of the `FormControl` bound to the directive. The name corresponds\n   * to a key in the parent `FormGroup` or `FormArray`.\n   * Accepts a name as a string or a number.\n   * The name in the form of a string is useful for individual forms,\n   * while the numerical form allows for form controls to be bound\n   * to indices when iterating over controls in a `FormArray`.\n   */\n  @Input('formControlName') override name: string|number|null = null;\n\n  /**\n   * @description\n   * Triggers a warning in dev mode that this input should not be used with reactive forms.\n   */\n  @Input('disabled')\n  set isDisabled(isDisabled: boolean) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      console.warn(disabledAttrWarning);\n    }\n  }\n\n  // TODO(kara): remove next 4 properties once deprecation period is over\n\n  /** @deprecated as of v6 */\n  @Input('ngModel') model: any;\n\n  /** @deprecated as of v6 */\n  @Output('ngModelChange') update = new EventEmitter();\n\n  /**\n   * @description\n   * Static property used to track whether any ngModel warnings have been sent across\n   * all instances of FormControlName. Used to support warning config of \"once\".\n   *\n   * @internal\n   */\n  static _ngModelWarningSentOnce = false;\n\n  /**\n   * @description\n   * Instance property used to track whether an ngModel warning has been sent out for this\n   * particular FormControlName instance. Used to support warning config of \"always\".\n   *\n   * @internal\n   */\n  _ngModelWarningSent = false;\n\n  constructor(\n      @Optional() @Host() @SkipSelf() parent: ControlContainer,\n      @Optional() @Self() @Inject(NG_VALIDATORS) validators: (Validator|ValidatorFn)[],\n      @Optional() @Self() @Inject(NG_ASYNC_VALIDATORS) asyncValidators:\n          (AsyncValidator|AsyncValidatorFn)[],\n      @Optional() @Self() @Inject(NG_VALUE_ACCESSOR) valueAccessors: ControlValueAccessor[],\n      @Optional() @Inject(NG_MODEL_WITH_FORM_CONTROL_WARNING) private _ngModelWarningConfig: string|\n      null) {\n    super();\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n    this.valueAccessor = selectValueAccessor(this, valueAccessors);\n  }\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges) {\n    if (!this._added) this._setUpControl();\n    if (isPropertyUpdated(changes, this.viewModel)) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        _ngModelWarning('formControlName', FormControlName, this, this._ngModelWarningConfig);\n      }\n      this.viewModel = this.model;\n      this.formDirective.updateModel(this, this.model);\n    }\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    if (this.formDirective) {\n      this.formDirective.removeControl(this);\n    }\n  }\n\n  /**\n   * @description\n   * Sets the new value for the view model and emits an `ngModelChange` event.\n   *\n   * @param newValue The new value for the view model.\n   */\n  override viewToModelUpdate(newValue: any): void {\n    this.viewModel = newValue;\n    this.update.emit(newValue);\n  }\n\n  /**\n   * @description\n   * Returns an array that represents the path from the top-level form to this control.\n   * Each index is the string name of the control on that level.\n   */\n  override get path(): string[] {\n    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent!);\n  }\n\n  /**\n   * @description\n   * The top-level directive for this group if present, otherwise null.\n   */\n  get formDirective(): any {\n    return this._parent ? this._parent.formDirective : null;\n  }\n\n  private _checkParentType(): void {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!(this._parent instanceof FormGroupName) &&\n          this._parent instanceof AbstractFormGroupDirective) {\n        throw ngModelGroupException();\n      } else if (\n          !(this._parent instanceof FormGroupName) &&\n          !(this._parent instanceof FormGroupDirective) &&\n          !(this._parent instanceof FormArrayName)) {\n        throw controlParentException();\n      }\n    }\n  }\n\n  private _setUpControl() {\n    this._checkParentType();\n    (this as Writable<this>).control = this.formDirective.addControl(this);\n    this._added = true;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, forwardRef, Host, Input, OnDestroy, Optional, Provider, Renderer2, RuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\n\nimport {BuiltInControlValueAccessor, ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\n\nconst SELECT_VALUE_ACCESSOR: Provider = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => SelectControlValueAccessor),\n  multi: true\n};\n\nfunction _buildValueString(id: string|null, value: any): string {\n  if (id == null) return `${value}`;\n  if (value && typeof value === 'object') value = 'Object';\n  return `${id}: ${value}`.slice(0, 50);\n}\n\nfunction _extractId(valueString: string): string {\n  return valueString.split(':')[0];\n}\n\n/**\n * @description\n * The `ControlValueAccessor` for writing select control values and listening to select control\n * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\n * `NgModel` directives.\n *\n * @usageNotes\n *\n * ### Using select controls in a reactive form\n *\n * The following examples show how to use a select control in a reactive form.\n *\n * {@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}\n *\n * ### Using select controls in a template-driven form\n *\n * To use a select in a template-driven form, simply add an `ngModel` and a `name`\n * attribute to the main `<select>` tag.\n *\n * {@example forms/ts/selectControl/select_control_example.ts region='Component'}\n *\n * ### Customizing option selection\n *\n * Angular uses object identity to select option. It's possible for the identities of items\n * to change while the data does not. This can happen, for example, if the items are produced\n * from an RPC to the server, and that RPC is re-run. Even if the data hasn't changed, the\n * second response will produce objects with different identities.\n *\n * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.\n * `compareWith` takes a **function** which has two arguments: `option1` and `option2`.\n * If `compareWith` is given, Angular selects option by the return value of the function.\n *\n * ```ts\n * const selectedCountriesControl = new FormControl();\n * ```\n *\n * ```\n * <select [compareWith]=\"compareFn\"  [formControl]=\"selectedCountriesControl\">\n *     <option *ngFor=\"let country of countries\" [ngValue]=\"country\">\n *         {{country.name}}\n *     </option>\n * </select>\n *\n * compareFn(c1: Country, c2: Country): boolean {\n *     return c1 && c2 ? c1.id === c2.id : c1 === c2;\n * }\n * ```\n *\n * **Note:** We listen to the 'change' event because 'input' events aren't fired\n * for selects in IE, see:\n * https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event#browser_compatibility\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector:\n      'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',\n  host: {'(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()'},\n  providers: [SELECT_VALUE_ACCESSOR]\n})\nexport class SelectControlValueAccessor extends BuiltInControlValueAccessor implements\n    ControlValueAccessor {\n  /** @nodoc */\n  value: any;\n\n  /** @internal */\n  _optionMap: Map<string, any> = new Map<string, any>();\n\n  /** @internal */\n  _idCounter: number = 0;\n\n  /**\n   * @description\n   * Tracks the option comparison algorithm for tracking identities when\n   * checking for changes.\n   */\n  @Input()\n  set compareWith(fn: (o1: any, o2: any) => boolean) {\n    if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw new RuntimeError(\n          RuntimeErrorCode.COMPAREWITH_NOT_A_FN,\n          `compareWith must be a function, but received ${JSON.stringify(fn)}`);\n    }\n    this._compareWith = fn;\n  }\n\n  private _compareWith: (o1: any, o2: any) => boolean = Object.is;\n\n  /**\n   * Sets the \"value\" property on the select element.\n   * @nodoc\n   */\n  writeValue(value: any): void {\n    this.value = value;\n    const id: string|null = this._getOptionId(value);\n    const valueString = _buildValueString(id, value);\n    this.setProperty('value', valueString);\n  }\n\n  /**\n   * Registers a function called when the control value changes.\n   * @nodoc\n   */\n  override registerOnChange(fn: (value: any) => any): void {\n    this.onChange = (valueString: string) => {\n      this.value = this._getOptionValue(valueString);\n      fn(this.value);\n    };\n  }\n\n  /** @internal */\n  _registerOption(): string {\n    return (this._idCounter++).toString();\n  }\n\n  /** @internal */\n  _getOptionId(value: any): string|null {\n    for (const id of this._optionMap.keys()) {\n      if (this._compareWith(this._optionMap.get(id), value)) return id;\n    }\n    return null;\n  }\n\n  /** @internal */\n  _getOptionValue(valueString: string): any {\n    const id: string = _extractId(valueString);\n    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;\n  }\n}\n\n/**\n * @description\n * Marks `<option>` as dynamic, so Angular can be notified when options change.\n *\n * @see {@link SelectControlValueAccessor}\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({selector: 'option'})\nexport class NgSelectOption implements OnDestroy {\n  /**\n   * @description\n   * ID of the option element\n   */\n  // TODO(issue/24571): remove '!'.\n  id!: string;\n\n  constructor(\n      private _element: ElementRef, private _renderer: Renderer2,\n      @Optional() @Host() private _select: SelectControlValueAccessor) {\n    if (this._select) this.id = this._select._registerOption();\n  }\n\n  /**\n   * @description\n   * Tracks the value bound to the option element. Unlike the value binding,\n   * ngValue supports binding to objects.\n   */\n  @Input('ngValue')\n  set ngValue(value: any) {\n    if (this._select == null) return;\n    this._select._optionMap.set(this.id, value);\n    this._setElementValue(_buildValueString(this.id, value));\n    this._select.writeValue(this._select.value);\n  }\n\n  /**\n   * @description\n   * Tracks simple string values bound to the option element.\n   * For objects, use the `ngValue` input binding.\n   */\n  @Input('value')\n  set value(value: any) {\n    this._setElementValue(value);\n    if (this._select) this._select.writeValue(this._select.value);\n  }\n\n  /** @internal */\n  _setElementValue(value: string): void {\n    this._renderer.setProperty(this._element.nativeElement, 'value', value);\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    if (this._select) {\n      this._select._optionMap.delete(this.id);\n      this._select.writeValue(this._select.value);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, forwardRef, Host, Input, OnDestroy, Optional, Provider, Renderer2, RuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\n\nimport {BuiltInControlValueAccessor, ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\n\nconst SELECT_MULTIPLE_VALUE_ACCESSOR: Provider = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => SelectMultipleControlValueAccessor),\n  multi: true\n};\n\nfunction _buildValueString(id: string, value: any): string {\n  if (id == null) return `${value}`;\n  if (typeof value === 'string') value = `'${value}'`;\n  if (value && typeof value === 'object') value = 'Object';\n  return `${id}: ${value}`.slice(0, 50);\n}\n\nfunction _extractId(valueString: string): string {\n  return valueString.split(':')[0];\n}\n\n/** Mock interface for HTML Options */\ninterface HTMLOption {\n  value: string;\n  selected: boolean;\n}\n\n/** Mock interface for HTMLCollection */\nabstract class HTMLCollection {\n  // TODO(issue/24571): remove '!'.\n  length!: number;\n  abstract item(_: number): HTMLOption;\n}\n\n/**\n * @description\n * The `ControlValueAccessor` for writing multi-select control values and listening to multi-select\n * control changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and\n * `NgModel` directives.\n *\n * @see {@link SelectControlValueAccessor}\n *\n * @usageNotes\n *\n * ### Using a multi-select control\n *\n * The follow example shows you how to use a multi-select control with a reactive form.\n *\n * ```ts\n * const countryControl = new FormControl();\n * ```\n *\n * ```\n * <select multiple name=\"countries\" [formControl]=\"countryControl\">\n *   <option *ngFor=\"let country of countries\" [ngValue]=\"country\">\n *     {{ country.name }}\n *   </option>\n * </select>\n * ```\n *\n * ### Customizing option selection\n *\n * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.\n * See the `SelectControlValueAccessor` for usage.\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector:\n      'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',\n  host: {'(change)': 'onChange($event.target)', '(blur)': 'onTouched()'},\n  providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]\n})\nexport class SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor implements\n    ControlValueAccessor {\n  /**\n   * The current value.\n   * @nodoc\n   */\n  value: any;\n\n  /** @internal */\n  _optionMap: Map<string, NgSelectMultipleOption> = new Map<string, NgSelectMultipleOption>();\n\n  /** @internal */\n  _idCounter: number = 0;\n\n  /**\n   * @description\n   * Tracks the option comparison algorithm for tracking identities when\n   * checking for changes.\n   */\n  @Input()\n  set compareWith(fn: (o1: any, o2: any) => boolean) {\n    if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw new RuntimeError(\n          RuntimeErrorCode.COMPAREWITH_NOT_A_FN,\n          `compareWith must be a function, but received ${JSON.stringify(fn)}`);\n    }\n    this._compareWith = fn;\n  }\n\n  private _compareWith: (o1: any, o2: any) => boolean = Object.is;\n\n  /**\n   * Sets the \"value\" property on one or of more of the select's options.\n   * @nodoc\n   */\n  writeValue(value: any): void {\n    this.value = value;\n    let optionSelectedStateSetter: (opt: NgSelectMultipleOption, o: any) => void;\n    if (Array.isArray(value)) {\n      // convert values to ids\n      const ids = value.map((v) => this._getOptionId(v));\n      optionSelectedStateSetter = (opt, o) => {\n        opt._setSelected(ids.indexOf(o.toString()) > -1);\n      };\n    } else {\n      optionSelectedStateSetter = (opt, o) => {\n        opt._setSelected(false);\n      };\n    }\n    this._optionMap.forEach(optionSelectedStateSetter);\n  }\n\n  /**\n   * Registers a function called when the control value changes\n   * and writes an array of the selected options.\n   * @nodoc\n   */\n  override registerOnChange(fn: (value: any) => any): void {\n    this.onChange = (element: HTMLSelectElement) => {\n      const selected: Array<any> = [];\n      const selectedOptions = element.selectedOptions;\n      if (selectedOptions !== undefined) {\n        const options = selectedOptions;\n        for (let i = 0; i < options.length; i++) {\n          const opt = options[i];\n          const val = this._getOptionValue(opt.value);\n          selected.push(val);\n        }\n      }\n      // Degrade to use `options` when `selectedOptions` property is not available.\n      // Note: the `selectedOptions` is available in all supported browsers, but the Domino lib\n      // doesn't have it currently, see https://github.com/fgnass/domino/issues/177.\n      else {\n        const options = element.options;\n        for (let i = 0; i < options.length; i++) {\n          const opt = options[i];\n          if (opt.selected) {\n            const val = this._getOptionValue(opt.value);\n            selected.push(val);\n          }\n        }\n      }\n      this.value = selected;\n      fn(selected);\n    };\n  }\n\n  /** @internal */\n  _registerOption(value: NgSelectMultipleOption): string {\n    const id: string = (this._idCounter++).toString();\n    this._optionMap.set(id, value);\n    return id;\n  }\n\n  /** @internal */\n  _getOptionId(value: any): string|null {\n    for (const id of this._optionMap.keys()) {\n      if (this._compareWith(this._optionMap.get(id)!._value, value)) return id;\n    }\n    return null;\n  }\n\n  /** @internal */\n  _getOptionValue(valueString: string): any {\n    const id: string = _extractId(valueString);\n    return this._optionMap.has(id) ? this._optionMap.get(id)!._value : valueString;\n  }\n}\n\n/**\n * @description\n * Marks `<option>` as dynamic, so Angular can be notified when options change.\n *\n * @see {@link SelectMultipleControlValueAccessor}\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({selector: 'option'})\nexport class NgSelectMultipleOption implements OnDestroy {\n  // TODO(issue/24571): remove '!'.\n  id!: string;\n  /** @internal */\n  _value: any;\n\n  constructor(\n      private _element: ElementRef, private _renderer: Renderer2,\n      @Optional() @Host() private _select: SelectMultipleControlValueAccessor) {\n    if (this._select) {\n      this.id = this._select._registerOption(this);\n    }\n  }\n\n  /**\n   * @description\n   * Tracks the value bound to the option element. Unlike the value binding,\n   * ngValue supports binding to objects.\n   */\n  @Input('ngValue')\n  set ngValue(value: any) {\n    if (this._select == null) return;\n    this._value = value;\n    this._setElementValue(_buildValueString(this.id, value));\n    this._select.writeValue(this._select.value);\n  }\n\n  /**\n   * @description\n   * Tracks simple string values bound to the option element.\n   * For objects, use the `ngValue` input binding.\n   */\n  @Input('value')\n  set value(value: any) {\n    if (this._select) {\n      this._value = value;\n      this._setElementValue(_buildValueString(this.id, value));\n      this._select.writeValue(this._select.value);\n    } else {\n      this._setElementValue(value);\n    }\n  }\n\n  /** @internal */\n  _setElementValue(value: string): void {\n    this._renderer.setProperty(this._element.nativeElement, 'value', value);\n  }\n\n  /** @internal */\n  _setSelected(selected: boolean) {\n    this._renderer.setProperty(this._element.nativeElement, 'selected', selected);\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    if (this._select) {\n      this._select._optionMap.delete(this.id);\n      this._select.writeValue(this._select.value);\n    }\n  }\n}\n\nexport {NgSelectMultipleOption as NgSelectMultipleOption};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {booleanAttribute, Directive, forwardRef, Input, OnChanges, Provider, SimpleChanges} from '@angular/core';\nimport {Observable} from 'rxjs';\n\nimport {AbstractControl} from '../model/abstract_model';\nimport {emailValidator, maxLengthValidator, maxValidator, minLengthValidator, minValidator, NG_VALIDATORS, nullValidator, patternValidator, requiredTrueValidator, requiredValidator} from '../validators';\n\n/**\n * Method that updates string to integer if not already a number\n *\n * @param value The value to convert to integer.\n * @returns value of parameter converted to number or integer.\n */\nfunction toInteger(value: string|number): number {\n  return typeof value === 'number' ? value : parseInt(value, 10);\n}\n\n/**\n * Method that ensures that provided value is a float (and converts it to float if needed).\n *\n * @param value The value to convert to float.\n * @returns value of parameter converted to number or float.\n */\nfunction toFloat(value: string|number): number {\n  return typeof value === 'number' ? value : parseFloat(value);\n}\n\n/**\n * @description\n * Defines the map of errors returned from failed validation checks.\n *\n * @publicApi\n */\nexport type ValidationErrors = {\n  [key: string]: any\n};\n\n/**\n * @description\n * An interface implemented by classes that perform synchronous validation.\n *\n * @usageNotes\n *\n * ### Provide a custom validator\n *\n * The following example implements the `Validator` interface to create a\n * validator directive with a custom error key.\n *\n * ```typescript\n * @Directive({\n *   selector: '[customValidator]',\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\n * })\n * class CustomValidatorDirective implements Validator {\n *   validate(control: AbstractControl): ValidationErrors|null {\n *     return {'custom': true};\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport interface Validator {\n  /**\n   * @description\n   * Method that performs synchronous validation against the provided control.\n   *\n   * @param control The control to validate against.\n   *\n   * @returns A map of validation errors if validation fails,\n   * otherwise null.\n   */\n  validate(control: AbstractControl): ValidationErrors|null;\n\n  /**\n   * @description\n   * Registers a callback function to call when the validator inputs change.\n   *\n   * @param fn The callback function\n   */\n  registerOnValidatorChange?(fn: () => void): void;\n}\n\n/**\n * A base class for Validator-based Directives. The class contains common logic shared across such\n * Directives.\n *\n * For internal use only, this class is not intended for use outside of the Forms package.\n */\n@Directive()\nabstract class AbstractValidatorDirective implements Validator, OnChanges {\n  private _validator: ValidatorFn = nullValidator;\n  private _onChange!: () => void;\n\n  /**\n   * A flag that tracks whether this validator is enabled.\n   *\n   * Marking it `internal` (vs `protected`), so that this flag can be used in host bindings of\n   * directive classes that extend this base class.\n   * @internal\n   */\n  _enabled?: boolean;\n\n  /**\n   * Name of an input that matches directive selector attribute (e.g. `minlength` for\n   * `MinLengthDirective`). An input with a given name might contain configuration information (like\n   * `minlength='10'`) or a flag that indicates whether validator should be enabled (like\n   * `[required]='false'`).\n   *\n   * @internal\n   */\n  abstract inputName: string;\n\n  /**\n   * Creates an instance of a validator (specific to a directive that extends this base class).\n   *\n   * @internal\n   */\n  abstract createValidator(input: unknown): ValidatorFn;\n\n  /**\n   * Performs the necessary input normalization based on a specific logic of a Directive.\n   * For example, the function might be used to convert string-based representation of the\n   * `minlength` input to an integer value that can later be used in the `Validators.minLength`\n   * validator.\n   *\n   * @internal\n   */\n  abstract normalizeInput(input: unknown): unknown;\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges): void {\n    if (this.inputName in changes) {\n      const input = this.normalizeInput(changes[this.inputName].currentValue);\n      this._enabled = this.enabled(input);\n      this._validator = this._enabled ? this.createValidator(input) : nullValidator;\n      if (this._onChange) {\n        this._onChange();\n      }\n    }\n  }\n\n  /** @nodoc */\n  validate(control: AbstractControl): ValidationErrors|null {\n    return this._validator(control);\n  }\n\n  /** @nodoc */\n  registerOnValidatorChange(fn: () => void): void {\n    this._onChange = fn;\n  }\n\n  /**\n   * @description\n   * Determines whether this validator should be active or not based on an input.\n   * Base class implementation checks whether an input is defined (if the value is different from\n   * `null` and `undefined`). Validator classes that extend this base class can override this\n   * function with the logic specific to a particular validator directive.\n   */\n  enabled(input: unknown): boolean {\n    return input != null /* both `null` and `undefined` */;\n  }\n}\n\n/**\n * @description\n * Provider which adds `MaxValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport const MAX_VALIDATOR: Provider = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MaxValidator),\n  multi: true\n};\n\n/**\n * A directive which installs the {@link MaxValidator} for any `formControlName`,\n * `formControl`, or control with `ngModel` that also has a `max` attribute.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a max validator\n *\n * The following example shows how to add a max validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input type=\"number\" ngModel max=\"4\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector:\n      'input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]',\n  providers: [MAX_VALIDATOR],\n  host: {'[attr.max]': '_enabled ? max : null'}\n})\nexport class MaxValidator extends AbstractValidatorDirective {\n  /**\n   * @description\n   * Tracks changes to the max bound to this directive.\n   */\n  @Input() max!: string|number|null;\n  /** @internal */\n  override inputName = 'max';\n  /** @internal */\n  override normalizeInput = (input: string|number): number => toFloat(input);\n  /** @internal */\n  override createValidator = (max: number): ValidatorFn => maxValidator(max);\n}\n\n/**\n * @description\n * Provider which adds `MinValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport const MIN_VALIDATOR: Provider = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MinValidator),\n  multi: true\n};\n\n/**\n * A directive which installs the {@link MinValidator} for any `formControlName`,\n * `formControl`, or control with `ngModel` that also has a `min` attribute.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a min validator\n *\n * The following example shows how to add a min validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input type=\"number\" ngModel min=\"4\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector:\n      'input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]',\n  providers: [MIN_VALIDATOR],\n  host: {'[attr.min]': '_enabled ? min : null'}\n})\nexport class MinValidator extends AbstractValidatorDirective {\n  /**\n   * @description\n   * Tracks changes to the min bound to this directive.\n   */\n  @Input() min!: string|number|null;\n  /** @internal */\n  override inputName = 'min';\n  /** @internal */\n  override normalizeInput = (input: string|number): number => toFloat(input);\n  /** @internal */\n  override createValidator = (min: number): ValidatorFn => minValidator(min);\n}\n\n/**\n * @description\n * An interface implemented by classes that perform asynchronous validation.\n *\n * @usageNotes\n *\n * ### Provide a custom async validator directive\n *\n * The following example implements the `AsyncValidator` interface to create an\n * async validator directive with a custom error key.\n *\n * ```typescript\n * import { of } from 'rxjs';\n *\n * @Directive({\n *   selector: '[customAsyncValidator]',\n *   providers: [{provide: NG_ASYNC_VALIDATORS, useExisting: CustomAsyncValidatorDirective, multi:\n * true}]\n * })\n * class CustomAsyncValidatorDirective implements AsyncValidator {\n *   validate(control: AbstractControl): Observable<ValidationErrors|null> {\n *     return of({'custom': true});\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport interface AsyncValidator extends Validator {\n  /**\n   * @description\n   * Method that performs async validation against the provided control.\n   *\n   * @param control The control to validate against.\n   *\n   * @returns A promise or observable that resolves a map of validation errors\n   * if validation fails, otherwise null.\n   */\n  validate(control: AbstractControl):\n      Promise<ValidationErrors|null>|Observable<ValidationErrors|null>;\n}\n\n/**\n * @description\n * Provider which adds `RequiredValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport const REQUIRED_VALIDATOR: Provider = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => RequiredValidator),\n  multi: true\n};\n\n/**\n * @description\n * Provider which adds `CheckboxRequiredValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport const CHECKBOX_REQUIRED_VALIDATOR: Provider = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => CheckboxRequiredValidator),\n  multi: true\n};\n\n\n/**\n * @description\n * A directive that adds the `required` validator to any controls marked with the\n * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a required validator using template-driven forms\n *\n * ```\n * <input name=\"fullName\" ngModel required>\n * ```\n *\n * @ngModule FormsModule\n * @ngModule ReactiveFormsModule\n * @publicApi\n */\n@Directive({\n  selector:\n      ':not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]',\n  providers: [REQUIRED_VALIDATOR],\n  host: {'[attr.required]': '_enabled ? \"\" : null'}\n})\nexport class RequiredValidator extends AbstractValidatorDirective {\n  /**\n   * @description\n   * Tracks changes to the required attribute bound to this directive.\n   */\n  @Input() required!: boolean|string;\n\n  /** @internal */\n  override inputName = 'required';\n\n  /** @internal */\n  override normalizeInput = booleanAttribute;\n\n  /** @internal */\n  override createValidator = (input: boolean): ValidatorFn => requiredValidator;\n\n  /** @nodoc */\n  override enabled(input: boolean): boolean {\n    return input;\n  }\n}\n\n\n/**\n * A Directive that adds the `required` validator to checkbox controls marked with the\n * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a required checkbox validator using template-driven forms\n *\n * The following example shows how to add a checkbox required validator to an input attached to an\n * ngModel binding.\n *\n * ```\n * <input type=\"checkbox\" name=\"active\" ngModel required>\n * ```\n *\n * @publicApi\n * @ngModule FormsModule\n * @ngModule ReactiveFormsModule\n */\n@Directive({\n  selector:\n      'input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]',\n  providers: [CHECKBOX_REQUIRED_VALIDATOR],\n  host: {'[attr.required]': '_enabled ? \"\" : null'}\n})\nexport class CheckboxRequiredValidator extends RequiredValidator {\n  /** @internal */\n  override createValidator = (input: unknown): ValidatorFn => requiredTrueValidator;\n}\n\n/**\n * @description\n * Provider which adds `EmailValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport const EMAIL_VALIDATOR: any = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => EmailValidator),\n  multi: true\n};\n\n/**\n * A directive that adds the `email` validator to controls marked with the\n * `email` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * The email validation is based on the WHATWG HTML specification with some enhancements to\n * incorporate more RFC rules. More information can be found on the [Validators.email\n * page](api/forms/Validators#email).\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding an email validator\n *\n * The following example shows how to add an email validator to an input attached to an ngModel\n * binding.\n *\n * ```\n * <input type=\"email\" name=\"email\" ngModel email>\n * <input type=\"email\" name=\"email\" ngModel email=\"true\">\n * <input type=\"email\" name=\"email\" ngModel [email]=\"true\">\n * ```\n *\n * @publicApi\n * @ngModule FormsModule\n * @ngModule ReactiveFormsModule\n */\n@Directive({\n  selector: '[email][formControlName],[email][formControl],[email][ngModel]',\n  providers: [EMAIL_VALIDATOR]\n})\nexport class EmailValidator extends AbstractValidatorDirective {\n  /**\n   * @description\n   * Tracks changes to the email attribute bound to this directive.\n   */\n  @Input() email!: boolean|string;\n\n  /** @internal */\n  override inputName = 'email';\n\n  /** @internal */\n  override normalizeInput = booleanAttribute;\n\n  /** @internal */\n  override createValidator = (input: number): ValidatorFn => emailValidator;\n\n  /** @nodoc */\n  override enabled(input: boolean): boolean {\n    return input;\n  }\n}\n\n/**\n * @description\n * A function that receives a control and synchronously returns a map of\n * validation errors if present, otherwise null.\n *\n * @publicApi\n */\nexport interface ValidatorFn {\n  (control: AbstractControl): ValidationErrors|null;\n}\n\n/**\n * @description\n * A function that receives a control and returns a Promise or observable\n * that emits validation errors if present, otherwise null.\n *\n * @publicApi\n */\nexport interface AsyncValidatorFn {\n  (control: AbstractControl): Promise<ValidationErrors|null>|Observable<ValidationErrors|null>;\n}\n\n/**\n * @description\n * Provider which adds `MinLengthValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport const MIN_LENGTH_VALIDATOR: any = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MinLengthValidator),\n  multi: true\n};\n\n/**\n * A directive that adds minimum length validation to controls marked with the\n * `minlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a minimum length validator\n *\n * The following example shows how to add a minimum length validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input name=\"firstName\" ngModel minlength=\"4\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',\n  providers: [MIN_LENGTH_VALIDATOR],\n  host: {'[attr.minlength]': '_enabled ? minlength : null'}\n})\nexport class MinLengthValidator extends AbstractValidatorDirective {\n  /**\n   * @description\n   * Tracks changes to the minimum length bound to this directive.\n   */\n  @Input() minlength!: string|number|null;\n\n  /** @internal */\n  override inputName = 'minlength';\n\n  /** @internal */\n  override normalizeInput = (input: string|number): number => toInteger(input);\n\n  /** @internal */\n  override createValidator = (minlength: number): ValidatorFn => minLengthValidator(minlength);\n}\n\n/**\n * @description\n * Provider which adds `MaxLengthValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport const MAX_LENGTH_VALIDATOR: any = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MaxLengthValidator),\n  multi: true\n};\n\n/**\n * A directive that adds max length validation to controls marked with the\n * `maxlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a maximum length validator\n *\n * The following example shows how to add a maximum length validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input name=\"firstName\" ngModel maxlength=\"25\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',\n  providers: [MAX_LENGTH_VALIDATOR],\n  host: {'[attr.maxlength]': '_enabled ? maxlength : null'}\n})\nexport class MaxLengthValidator extends AbstractValidatorDirective {\n  /**\n   * @description\n   * Tracks changes to the minimum length bound to this directive.\n   */\n  @Input() maxlength!: string|number|null;\n\n  /** @internal */\n  override inputName = 'maxlength';\n\n  /** @internal */\n  override normalizeInput = (input: string|number): number => toInteger(input);\n\n  /** @internal */\n  override createValidator = (maxlength: number): ValidatorFn => maxLengthValidator(maxlength);\n}\n\n/**\n * @description\n * Provider which adds `PatternValidator` to the `NG_VALIDATORS` multi-provider list.\n */\nexport const PATTERN_VALIDATOR: any = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => PatternValidator),\n  multi: true\n};\n\n\n/**\n * @description\n * A directive that adds regex pattern validation to controls marked with the\n * `pattern` attribute. The regex must match the entire control value.\n * The directive is provided with the `NG_VALIDATORS` multi-provider list.\n *\n * @see [Form Validation](guide/form-validation)\n *\n * @usageNotes\n *\n * ### Adding a pattern validator\n *\n * The following example shows how to add a pattern validator to an input attached to an\n * ngModel binding.\n *\n * ```html\n * <input name=\"firstName\" ngModel pattern=\"[a-zA-Z ]*\">\n * ```\n *\n * @ngModule ReactiveFormsModule\n * @ngModule FormsModule\n * @publicApi\n */\n@Directive({\n  selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',\n  providers: [PATTERN_VALIDATOR],\n  host: {'[attr.pattern]': '_enabled ? pattern : null'}\n})\nexport class PatternValidator extends AbstractValidatorDirective {\n  /**\n   * @description\n   * Tracks changes to the pattern bound to this directive.\n   */\n  @Input()\n  pattern!: string|RegExp;  // This input is always defined, since the name matches selector.\n\n  /** @internal */\n  override inputName = 'pattern';\n\n  /** @internal */\n  override normalizeInput = (input: string|RegExp): string|RegExp => input;\n\n  /** @internal */\n  override createValidator = (input: string|RegExp): ValidatorFn => patternValidator(input);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule, Type} from '@angular/core';\n\nimport {CheckboxControlValueAccessor} from './directives/checkbox_value_accessor';\nimport {DefaultValueAccessor} from './directives/default_value_accessor';\nimport {NgControlStatus, NgControlStatusGroup} from './directives/ng_control_status';\nimport {NgForm} from './directives/ng_form';\nimport {NgModel} from './directives/ng_model';\nimport {NgModelGroup} from './directives/ng_model_group';\nimport {NgNoValidate} from './directives/ng_no_validate_directive';\nimport {NumberValueAccessor} from './directives/number_value_accessor';\nimport {RadioControlRegistryModule, RadioControlValueAccessor} from './directives/radio_control_value_accessor';\nimport {RangeValueAccessor} from './directives/range_value_accessor';\nimport {FormControlDirective} from './directives/reactive_directives/form_control_directive';\nimport {FormControlName} from './directives/reactive_directives/form_control_name';\nimport {FormGroupDirective} from './directives/reactive_directives/form_group_directive';\nimport {FormArrayName, FormGroupName} from './directives/reactive_directives/form_group_name';\nimport {NgSelectOption, SelectControlValueAccessor} from './directives/select_control_value_accessor';\nimport {NgSelectMultipleOption, SelectMultipleControlValueAccessor} from './directives/select_multiple_control_value_accessor';\nimport {CheckboxRequiredValidator, EmailValidator, MaxLengthValidator, MaxValidator, MinLengthValidator, MinValidator, PatternValidator, RequiredValidator} from './directives/validators';\n\nexport {CheckboxControlValueAccessor} from './directives/checkbox_value_accessor';\nexport {ControlValueAccessor} from './directives/control_value_accessor';\nexport {DefaultValueAccessor} from './directives/default_value_accessor';\nexport {NgControl} from './directives/ng_control';\nexport {NgControlStatus, NgControlStatusGroup} from './directives/ng_control_status';\nexport {NgForm} from './directives/ng_form';\nexport {NgModel} from './directives/ng_model';\nexport {NgModelGroup} from './directives/ng_model_group';\nexport {NumberValueAccessor} from './directives/number_value_accessor';\nexport {RadioControlValueAccessor} from './directives/radio_control_value_accessor';\nexport {RangeValueAccessor} from './directives/range_value_accessor';\nexport {FormControlDirective, NG_MODEL_WITH_FORM_CONTROL_WARNING} from './directives/reactive_directives/form_control_directive';\nexport {FormControlName} from './directives/reactive_directives/form_control_name';\nexport {FormGroupDirective} from './directives/reactive_directives/form_group_directive';\nexport {FormArrayName, FormGroupName} from './directives/reactive_directives/form_group_name';\nexport {NgSelectOption, SelectControlValueAccessor} from './directives/select_control_value_accessor';\nexport {NgSelectMultipleOption, SelectMultipleControlValueAccessor} from './directives/select_multiple_control_value_accessor';\nexport {CALL_SET_DISABLED_STATE} from './directives/shared';\n\nexport const SHARED_FORM_DIRECTIVES: Type<any>[] = [\n  NgNoValidate,\n  NgSelectOption,\n  NgSelectMultipleOption,\n  DefaultValueAccessor,\n  NumberValueAccessor,\n  RangeValueAccessor,\n  CheckboxControlValueAccessor,\n  SelectControlValueAccessor,\n  SelectMultipleControlValueAccessor,\n  RadioControlValueAccessor,\n  NgControlStatus,\n  NgControlStatusGroup,\n  RequiredValidator,\n  MinLengthValidator,\n  MaxLengthValidator,\n  PatternValidator,\n  CheckboxRequiredValidator,\n  EmailValidator,\n  MinValidator,\n  MaxValidator,\n];\n\nexport const TEMPLATE_DRIVEN_DIRECTIVES: Type<any>[] = [NgModel, NgModelGroup, NgForm];\n\nexport const REACTIVE_DRIVEN_DIRECTIVES: Type<any>[] =\n    [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];\n\n/**\n * Internal module used for sharing directives between FormsModule and ReactiveFormsModule\n */\n@NgModule({\n  declarations: SHARED_FORM_DIRECTIVES,\n  imports: [RadioControlRegistryModule],\n  exports: SHARED_FORM_DIRECTIVES,\n})\nexport class InternalFormsSharedModule {\n}\n\nexport {InternalFormsSharedModule as InternalFormsSharedModule};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Writable as Writable} from '@angular/core';\n\nimport {AsyncValidatorFn, ValidatorFn} from '../directives/validators';\n\nimport {AbstractControl, AbstractControlOptions, assertAllValuesPresent, assertControlPresent, pickAsyncValidators, pickValidators, RawValue, TypedOrUntyped, Value} from './abstract_model';\n\n/**\n * FormArrayValue extracts the type of `.value` from a FormArray's element type, and wraps it in an\n * array.\n *\n * Angular uses this type internally to support Typed Forms; do not use it directly. The untyped\n * case falls back to any[].\n */\nexport type FormArrayValue<T extends AbstractControl<any>> =\n    TypedOrUntyped<T, Array<Value<T>>, any[]>;\n\n/**\n * FormArrayRawValue extracts the type of `.getRawValue()` from a FormArray's element type, and\n * wraps it in an array. The untyped case falls back to any[].\n *\n * Angular uses this type internally to support Typed Forms; do not use it directly.\n */\nexport type FormArrayRawValue<T extends AbstractControl<any>> =\n    TypedOrUntyped<T, Array<RawValue<T>>, any[]>;\n\n/**\n * Tracks the value and validity state of an array of `FormControl`,\n * `FormGroup` or `FormArray` instances.\n *\n * A `FormArray` aggregates the values of each child `FormControl` into an array.\n * It calculates its status by reducing the status values of its children. For example, if one of\n * the controls in a `FormArray` is invalid, the entire array becomes invalid.\n *\n * `FormArray` accepts one generic argument, which is the type of the controls inside.\n * If you need a heterogenous array, use {@link UntypedFormArray}.\n *\n * `FormArray` is one of the four fundamental building blocks used to define forms in Angular,\n * along with `FormControl`, `FormGroup`, and `FormRecord`.\n *\n * @usageNotes\n *\n * ### Create an array of form controls\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy', Validators.minLength(2)),\n *   new FormControl('Drew'),\n * ]);\n *\n * console.log(arr.value);   // ['Nancy', 'Drew']\n * console.log(arr.status);  // 'VALID'\n * ```\n *\n * ### Create a form array with array-level validators\n *\n * You include array-level validators and async validators. These come in handy\n * when you want to perform validation that considers the value of more than one child\n * control.\n *\n * The two types of validators are passed in separately as the second and third arg\n * respectively, or together as part of an options object.\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy'),\n *   new FormControl('Drew')\n * ], {validators: myValidator, asyncValidators: myAsyncValidator});\n * ```\n *\n * ### Set the updateOn property for all controls in a form array\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * array level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const arr = new FormArray([\n *    new FormControl()\n * ], {updateOn: 'blur'});\n * ```\n *\n * ### Adding or removing controls from a form array\n *\n * To change the controls in the array, use the `push`, `insert`, `removeAt` or `clear` methods\n * in `FormArray` itself. These methods ensure the controls are properly tracked in the\n * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\n * the `FormArray` directly, as that result in strange and unexpected behavior such\n * as broken change detection.\n *\n * @publicApi\n */\nexport class FormArray<TControl extends AbstractControl<any> = any> extends AbstractControl<\n    TypedOrUntyped<TControl, FormArrayValue<TControl>, any>,\n    TypedOrUntyped<TControl, FormArrayRawValue<TControl>, any>> {\n  /**\n   * Creates a new `FormArray` instance.\n   *\n   * @param controls An array of child controls. Each child control is given an index\n   * where it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   */\n  constructor(\n      controls: Array<TControl>,\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    this.controls = controls;\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n      // `VALID` or `INVALID`.\n      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`\n      // to `true` to allow that during the control creation process.\n      emitEvent: !!this.asyncValidator\n    });\n  }\n\n  public controls: TypedOrUntyped<TControl, Array<TControl>, Array<AbstractControl<any>>>;\n\n  /**\n   * Get the `AbstractControl` at the given `index` in the array.\n   *\n   * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap\n   *     around from the back, and if index is greatly negative (less than `-length`), the result is\n   * undefined. This behavior is the same as `Array.at(index)`.\n   */\n  at(index: number): TypedOrUntyped<TControl, TControl, AbstractControl<any>> {\n    return (this.controls as any)[this._adjustIndex(index)];\n  }\n\n  /**\n   * Insert a new `AbstractControl` at the end of the array.\n   *\n   * @param control Form control to be inserted\n   * @param options Specifies whether this FormArray instance should emit events after a new\n   *     control is added.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * inserted. When false, no events are emitted.\n   */\n  push(control: TControl, options: {emitEvent?: boolean} = {}): void {\n    this.controls.push(control);\n    this._registerControl(control);\n    this.updateValueAndValidity({emitEvent: options.emitEvent});\n    this._onCollectionChange();\n  }\n\n  /**\n   * Insert a new `AbstractControl` at the given `index` in the array.\n   *\n   * @param index Index in the array to insert the control. If `index` is negative, wraps around\n   *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.\n   * This behavior is the same as `Array.splice(index, 0, control)`.\n   * @param control Form control to be inserted\n   * @param options Specifies whether this FormArray instance should emit events after a new\n   *     control is inserted.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * inserted. When false, no events are emitted.\n   */\n  insert(index: number, control: TControl, options: {emitEvent?: boolean} = {}): void {\n    this.controls.splice(index, 0, control);\n\n    this._registerControl(control);\n    this.updateValueAndValidity({emitEvent: options.emitEvent});\n  }\n\n  /**\n   * Remove the control at the given `index` in the array.\n   *\n   * @param index Index in the array to remove the control.  If `index` is negative, wraps around\n   *     from the back. If `index` is greatly negative (less than `-length`), removes the first\n   *     element. This behavior is the same as `Array.splice(index, 1)`.\n   * @param options Specifies whether this FormArray instance should emit events after a\n   *     control is removed.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * removed. When false, no events are emitted.\n   */\n  removeAt(index: number, options: {emitEvent?: boolean} = {}): void {\n    // Adjust the index, then clamp it at no less than 0 to prevent undesired underflows.\n    let adjustedIndex = this._adjustIndex(index);\n    if (adjustedIndex < 0) adjustedIndex = 0;\n\n    if (this.controls[adjustedIndex])\n      this.controls[adjustedIndex]._registerOnCollectionChange(() => {});\n    this.controls.splice(adjustedIndex, 1);\n    this.updateValueAndValidity({emitEvent: options.emitEvent});\n  }\n\n  /**\n   * Replace an existing control.\n   *\n   * @param index Index in the array to replace the control. If `index` is negative, wraps around\n   *     from the back. If `index` is greatly negative (less than `-length`), replaces the first\n   *     element. This behavior is the same as `Array.splice(index, 1, control)`.\n   * @param control The `AbstractControl` control to replace the existing control\n   * @param options Specifies whether this FormArray instance should emit events after an\n   *     existing control is replaced with a new one.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * replaced with a new one. When false, no events are emitted.\n   */\n  setControl(index: number, control: TControl, options: {emitEvent?: boolean} = {}): void {\n    // Adjust the index, then clamp it at no less than 0 to prevent undesired underflows.\n    let adjustedIndex = this._adjustIndex(index);\n    if (adjustedIndex < 0) adjustedIndex = 0;\n\n    if (this.controls[adjustedIndex])\n      this.controls[adjustedIndex]._registerOnCollectionChange(() => {});\n    this.controls.splice(adjustedIndex, 1);\n\n    if (control) {\n      this.controls.splice(adjustedIndex, 0, control);\n      this._registerControl(control);\n    }\n\n    this.updateValueAndValidity({emitEvent: options.emitEvent});\n    this._onCollectionChange();\n  }\n\n  /**\n   * Length of the control array.\n   */\n  get length(): number {\n    return this.controls.length;\n  }\n\n  /**\n   * Sets the value of the `FormArray`. It accepts an array that matches\n   * the structure of the control.\n   *\n   * This method performs strict checks, and throws an error if you try\n   * to set the value of a control that doesn't exist or if you exclude the\n   * value of a control.\n   *\n   * @usageNotes\n   * ### Set the values for the controls in the form array\n   *\n   * ```\n   * const arr = new FormArray([\n   *   new FormControl(),\n   *   new FormControl()\n   * ]);\n   * console.log(arr.value);   // [null, null]\n   *\n   * arr.setValue(['Nancy', 'Drew']);\n   * console.log(arr.value);   // ['Nancy', 'Drew']\n   * ```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  override setValue(value: FormArrayRawValue<TControl>, options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean\n  } = {}): void {\n    assertAllValuesPresent(this, false, value);\n    value.forEach((newValue: any, index: number) => {\n      assertControlPresent(this, false, index);\n      this.at(index).setValue(newValue, {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of the `FormArray`. It accepts an array that matches the\n   * structure of the control, and does its best to match the values to the correct\n   * controls in the group.\n   *\n   * It accepts both super-sets and sub-sets of the array without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the values for controls in a form array\n   *\n   * ```\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * console.log(arr.value);   // [null, null]\n   *\n   * arr.patchValue(['Nancy']);\n   * console.log(arr.value);   // ['Nancy', null]\n   * ```\n   *\n   * @param value Array of latest values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control\n   * value is updated. When false, no events are emitted. The configuration options are passed to\n   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n   */\n  override patchValue(value: FormArrayValue<TControl>, options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean\n  } = {}): void {\n    // Even though the `value` argument type doesn't allow `null` and `undefined` values, the\n    // `patchValue` can be called recursively and inner data structures might have these values,\n    // so we just ignore such cases when a field containing FormArray instance receives `null` or\n    // `undefined` as a value.\n    if (value == null /* both `null` and `undefined` */) return;\n\n    value.forEach((newValue, index) => {\n      if (this.at(index)) {\n        this.at(index).patchValue(newValue, {onlySelf: true, emitEvent: options.emitEvent});\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\n   * value of all descendants to null or null maps.\n   *\n   * You reset to a specific form state by passing in an array of states\n   * that matches the structure of the control. The state is a standalone value\n   * or a form state object with both a value and a disabled status.\n   *\n   * @usageNotes\n   * ### Reset the values in a form array\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * arr.reset(['name', 'last name']);\n   *\n   * console.log(arr.value);  // ['name', 'last name']\n   * ```\n   *\n   * ### Reset the values in a form array and the disabled status for the first control\n   *\n   * ```\n   * arr.reset([\n   *   {value: 'name', disabled: true},\n   *   'last'\n   * ]);\n   *\n   * console.log(arr.value);  // ['last']\n   * console.log(arr.at(0).status);  // 'DISABLED'\n   * ```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  override reset(value: TypedOrUntyped<TControl, FormArrayValue<TControl>, any> = [], options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean\n  } = {}): void {\n    this._forEachChild((control: AbstractControl, index: number) => {\n      control.reset(value[index], {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this._updatePristine(options);\n    this._updateTouched(options);\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * The aggregate value of the array, including any disabled controls.\n   *\n   * Reports all values regardless of disabled status.\n   */\n  override getRawValue(): FormArrayRawValue<TControl> {\n    return this.controls.map((control: AbstractControl) => control.getRawValue());\n  }\n\n  /**\n   * Remove all controls in the `FormArray`.\n   *\n   * @param options Specifies whether this FormArray instance should emit events after all\n   *     controls are removed.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when all controls\n   * in this FormArray instance are removed. When false, no events are emitted.\n   *\n   * @usageNotes\n   * ### Remove all elements from a FormArray\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * console.log(arr.length);  // 2\n   *\n   * arr.clear();\n   * console.log(arr.length);  // 0\n   * ```\n   *\n   * It's a simpler and more efficient alternative to removing all elements one by one:\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   *\n   * while (arr.length) {\n   *    arr.removeAt(0);\n   * }\n   * ```\n   */\n  clear(options: {emitEvent?: boolean} = {}): void {\n    if (this.controls.length < 1) return;\n    this._forEachChild((control) => control._registerOnCollectionChange(() => {}));\n    this.controls.splice(0);\n    this.updateValueAndValidity({emitEvent: options.emitEvent});\n  }\n\n  /**\n   * Adjusts a negative index by summing it with the length of the array. For very negative\n   * indices, the result may remain negative.\n   * @internal\n   */\n  private _adjustIndex(index: number): number {\n    return index < 0 ? index + this.length : index;\n  }\n\n  /** @internal */\n  override _syncPendingControls(): boolean {\n    let subtreeUpdated = (this.controls as any).reduce((updated: any, child: any) => {\n      return child._syncPendingControls() ? true : updated;\n    }, false);\n    if (subtreeUpdated) this.updateValueAndValidity({onlySelf: true});\n    return subtreeUpdated;\n  }\n\n  /** @internal */\n  override _forEachChild(cb: (c: AbstractControl, index: number) => void): void {\n    this.controls.forEach((control: AbstractControl, index: number) => {\n      cb(control, index);\n    });\n  }\n\n  /** @internal */\n  override _updateValue(): void {\n    (this as Writable<this>).value =\n        this.controls.filter((control) => control.enabled || this.disabled)\n            .map((control) => control.value);\n  }\n\n  /** @internal */\n  override _anyControls(condition: (c: AbstractControl) => boolean): boolean {\n    return this.controls.some((control) => control.enabled && condition(control));\n  }\n\n  /** @internal */\n  _setUpControls(): void {\n    this._forEachChild((control) => this._registerControl(control));\n  }\n\n  /** @internal */\n  override _allControlsDisabled(): boolean {\n    for (const control of this.controls) {\n      if (control.enabled) return false;\n    }\n    return this.controls.length > 0 || this.disabled;\n  }\n\n  private _registerControl(control: AbstractControl) {\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n  }\n\n  /** @internal */\n  override _find(name: string|number): AbstractControl|null {\n    return this.at(name as number) ?? null;\n  }\n}\n\ninterface UntypedFormArrayCtor {\n  new(controls: AbstractControl[],\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): UntypedFormArray;\n\n  /**\n   * The presence of an explicit `prototype` property provides backwards-compatibility for apps that\n   * manually inspect the prototype chain.\n   */\n  prototype: FormArray<any>;\n}\n\n/**\n * UntypedFormArray is a non-strongly-typed version of `FormArray`, which\n * permits heterogenous controls.\n */\nexport type UntypedFormArray = FormArray<any>;\n\nexport const UntypedFormArray: UntypedFormArrayCtor = FormArray;\n\n/**\n * @description\n * Asserts that the given control is an instance of `FormArray`\n *\n * @publicApi\n */\nexport const isFormArray = (control: unknown): control is FormArray => control instanceof FormArray;\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {inject, Injectable} from '@angular/core';\n\nimport {AsyncValidatorFn, ValidatorFn} from './directives/validators';\nimport {AbstractControl, AbstractControlOptions, FormHooks} from './model/abstract_model';\nimport {FormArray, UntypedFormArray} from './model/form_array';\nimport {FormControl, FormControlOptions, FormControlState, UntypedFormControl} from './model/form_control';\nimport {FormGroup, FormRecord, UntypedFormGroup} from './model/form_group';\n\nfunction isAbstractControlOptions(options: AbstractControlOptions|{[key: string]: any}|null|\n                                  undefined): options is AbstractControlOptions {\n  return !!options &&\n      ((options as AbstractControlOptions).asyncValidators !== undefined ||\n       (options as AbstractControlOptions).validators !== undefined ||\n       (options as AbstractControlOptions).updateOn !== undefined);\n}\n\n/**\n * The union of all validator types that can be accepted by a ControlConfig.\n */\ntype ValidatorConfig = ValidatorFn|AsyncValidatorFn|ValidatorFn[]|AsyncValidatorFn[];\n\n/**\n * The compiler may not always be able to prove that the elements of the control config are a tuple\n * (i.e. occur in a fixed order). This slightly looser type is used for inference, to catch cases\n * where the compiler cannot prove order and position.\n *\n * For example, consider the simple case `fb.group({foo: ['bar', Validators.required]})`. The\n * compiler will infer this as an array, not as a tuple.\n */\ntype PermissiveControlConfig<T> = Array<T|FormControlState<T>|ValidatorConfig>;\n\n/**\n * Helper type to allow the compiler to accept [XXXX, { updateOn: string }] as a valid shorthand\n * argument for .group()\n */\ninterface PermissiveAbstractControlOptions extends Omit<AbstractControlOptions, 'updateOn'> {\n  updateOn?: string;\n}\n\n/**\n * ControlConfig<T> is a tuple containing a value of type T, plus optional validators and async\n * validators.\n *\n * @publicApi\n */\nexport type ControlConfig<T> = [T|FormControlState<T>, (ValidatorFn|(ValidatorFn[]))?, (AsyncValidatorFn|AsyncValidatorFn[])?];\n\n// Disable clang-format to produce clearer formatting for this multiline type.\n// clang-format off\n\n/**\n * FormBuilder accepts values in various container shapes, as well as raw values.\n * Element returns the appropriate corresponding model class, given the container T.\n * The flag N, if not never, makes the resulting `FormControl` have N in its type.\n */\nexport type Element<T, N extends null> =\n  // The `extends` checks are wrapped in arrays in order to prevent TypeScript from applying type unions\n  // through the distributive conditional type. This is the officially recommended solution:\n  // https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n  //\n  // Identify FormControl container types.\n  [T] extends [FormControl<infer U>] ? FormControl<U> :\n  // Or FormControl containers that are optional in their parent group.\n  [T] extends [FormControl<infer U>|undefined] ? FormControl<U> :\n  // FormGroup containers.\n  [T] extends [FormGroup<infer U>] ? FormGroup<U> :\n  // Optional FormGroup containers.\n  [T] extends [FormGroup<infer U>|undefined] ? FormGroup<U> :\n  // FormRecord containers.\n  [T] extends [FormRecord<infer U>] ? FormRecord<U> :\n  // Optional FormRecord containers.\n  [T] extends [FormRecord<infer U>|undefined] ? FormRecord<U> :\n  // FormArray containers.\n  [T] extends [FormArray<infer U>] ? FormArray<U> :\n  // Optional FormArray containers.\n  [T] extends [FormArray<infer U>|undefined] ? FormArray<U> :\n  // Otherwise unknown AbstractControl containers.\n  [T] extends [AbstractControl<infer U>] ? AbstractControl<U> :\n  // Optional AbstractControl containers.\n  [T] extends [AbstractControl<infer U>|undefined] ? AbstractControl<U> :\n  // FormControlState object container, which produces a nullable control.\n  [T] extends [FormControlState<infer U>] ? FormControl<U|N> :\n  // A ControlConfig tuple, which produces a nullable control.\n  [T] extends [PermissiveControlConfig<infer U>] ? FormControl<Exclude<U, ValidatorConfig| PermissiveAbstractControlOptions>|N> :\n  FormControl<T|N>;\n\n// clang-format on\n\n/**\n * @description\n * Creates an `AbstractControl` from a user-specified configuration.\n *\n * The `FormBuilder` provides syntactic sugar that shortens creating instances of a\n * `FormControl`, `FormGroup`, or `FormArray`. It reduces the amount of boilerplate needed to\n * build complex forms.\n *\n * @see [Reactive Forms Guide](guide/reactive-forms)\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class FormBuilder {\n  private useNonNullable: boolean = false;\n\n  /**\n   * @description\n   * Returns a FormBuilder in which automatically constructed `FormControl` elements\n   * have `{nonNullable: true}` and are non-nullable.\n   *\n   * **Constructing non-nullable controls**\n   *\n   * When constructing a control, it will be non-nullable, and will reset to its initial value.\n   *\n   * ```ts\n   * let nnfb = new FormBuilder().nonNullable;\n   * let name = nnfb.control('Alex'); // FormControl<string>\n   * name.reset();\n   * console.log(name); // 'Alex'\n   * ```\n   *\n   * **Constructing non-nullable groups or arrays**\n   *\n   * When constructing a group or array, all automatically created inner controls will be\n   * non-nullable, and will reset to their initial values.\n   *\n   * ```ts\n   * let nnfb = new FormBuilder().nonNullable;\n   * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>\n   * name.reset();\n   * console.log(name); // {who: 'Alex'}\n   * ```\n   * **Constructing *nullable* fields on groups or arrays**\n   *\n   * It is still possible to have a nullable field. In particular, any `FormControl` which is\n   * *already* constructed will not be altered. For example:\n   *\n   * ```ts\n   * let nnfb = new FormBuilder().nonNullable;\n   * // FormGroup<{who: FormControl<string|null>}>\n   * let name = nnfb.group({who: new FormControl('Alex')});\n   * name.reset(); console.log(name); // {who: null}\n   * ```\n   *\n   * Because the inner control is constructed explicitly by the caller, the builder has\n   * no control over how it is created, and cannot exclude the `null`.\n   */\n  get nonNullable(): NonNullableFormBuilder {\n    const nnfb = new FormBuilder();\n    nnfb.useNonNullable = true;\n    return nnfb as NonNullableFormBuilder;\n  }\n\n  /**\n   * @description\n   * Constructs a new `FormGroup` instance. Accepts a single generic argument, which is an object\n   * containing all the keys and corresponding inner control types.\n   *\n   * @param controls A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param options Configuration options object for the `FormGroup`. The object should have the\n   * `AbstractControlOptions` type and might contain the following fields:\n   * * `validators`: A synchronous validator function, or an array of validator functions.\n   * * `asyncValidators`: A single async validator or array of async validator functions.\n   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'\n   * | submit').\n   */\n  group<T extends {}>(\n      controls: T,\n      options?: AbstractControlOptions|null,\n      ): FormGroup<{[K in keyof T]: Element<T[K], null>}>;\n\n  /**\n   * @description\n   * Constructs a new `FormGroup` instance.\n   *\n   * @deprecated This API is not typesafe and can result in issues with Closure Compiler renaming.\n   * Use the `FormBuilder#group` overload with `AbstractControlOptions` instead.\n   * Note that `AbstractControlOptions` expects `validators` and `asyncValidators` to be valid\n   * validators. If you have custom validators, make sure their validation function parameter is\n   * `AbstractControl` and not a sub-class, such as `FormGroup`. These functions will be called\n   * with an object of type `AbstractControl` and that cannot be automatically downcast to a\n   * subclass, so TypeScript sees this as an error. For example, change the `(group: FormGroup) =>\n   * ValidationErrors|null` signature to be `(group: AbstractControl) => ValidationErrors|null`.\n   *\n   * @param controls A record of child controls. The key for each child is the name\n   * under which the control is registered.\n   *\n   * @param options Configuration options object for the `FormGroup`. The legacy configuration\n   * object consists of:\n   * * `validator`: A synchronous validator function, or an array of validator functions.\n   * * `asyncValidator`: A single async validator or array of async validator functions\n   * Note: the legacy format is deprecated and might be removed in one of the next major versions\n   * of Angular.\n   */\n  group(\n      controls: {[key: string]: any},\n      options: {[key: string]: any},\n      ): FormGroup;\n\n  group(controls: {[key: string]: any}, options: AbstractControlOptions|{[key: string]:\n                                                                             any}|null = null):\n      FormGroup {\n    const reducedControls = this._reduceControls(controls);\n    let newOptions: FormControlOptions = {};\n    if (isAbstractControlOptions(options)) {\n      // `options` are `AbstractControlOptions`\n      newOptions = options;\n    } else if (options !== null) {\n      // `options` are legacy form group options\n      newOptions.validators = (options as any).validator;\n      newOptions.asyncValidators = (options as any).asyncValidator;\n    }\n    return new FormGroup(reducedControls, newOptions);\n  }\n\n  /**\n   * @description\n   * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object\n   * containing all the keys and corresponding inner control types.\n   *\n   * @param controls A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param options Configuration options object for the `FormRecord`. The object should have the\n   * `AbstractControlOptions` type and might contain the following fields:\n   * * `validators`: A synchronous validator function, or an array of validator functions.\n   * * `asyncValidators`: A single async validator or array of async validator functions.\n   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'\n   * | submit').\n   */\n  record<T>(controls: {[key: string]: T}, options: AbstractControlOptions|null = null):\n      FormRecord<Element<T, null>> {\n    const reducedControls = this._reduceControls(controls);\n    // Cast to `any` because the inferred types are not as specific as Element.\n    return new FormRecord(reducedControls, options) as any;\n  }\n\n  /** @deprecated Use `nonNullable` instead. */\n  control<T>(formState: T|FormControlState<T>, opts: FormControlOptions&{\n    initialValueIsDefault: true\n  }): FormControl<T>;\n\n  control<T>(formState: T|FormControlState<T>, opts: FormControlOptions&{nonNullable: true}):\n      FormControl<T>;\n\n  /**\n   * @deprecated When passing an `options` argument, the `asyncValidator` argument has no effect.\n   */\n  control<T>(\n      formState: T|FormControlState<T>, opts: FormControlOptions,\n      asyncValidator: AsyncValidatorFn|AsyncValidatorFn[]): FormControl<T|null>;\n\n  control<T>(\n      formState: T|FormControlState<T>,\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|FormControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): FormControl<T|null>;\n\n  /**\n   * @description\n   * Constructs a new `FormControl` with the given state, validators and options. Sets\n   * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the\n   * control will be nullable. Accepts a single generic argument, which is the type  of the\n   * control's value.\n   *\n   * @param formState Initializes the control with an initial state value, or\n   * with an object that contains both a value and a disabled status.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or a `FormControlOptions` object that contains\n   * validation functions and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator\n   * functions.\n   *\n   * @usageNotes\n   *\n   * ### Initialize a control as disabled\n   *\n   * The following example returns a control with an initial value in a disabled state.\n   *\n   * <code-example path=\"forms/ts/formBuilder/form_builder_example.ts\" region=\"disabled-control\">\n   * </code-example>\n   */\n  control<T>(\n      formState: T|FormControlState<T>,\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|FormControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): FormControl {\n    let newOptions: FormControlOptions = {};\n    if (!this.useNonNullable) {\n      return new FormControl(formState, validatorOrOpts, asyncValidator);\n    }\n    if (isAbstractControlOptions(validatorOrOpts)) {\n      // If the second argument is options, then they are copied.\n      newOptions = validatorOrOpts;\n    } else {\n      // If the other arguments are validators, they are copied into an options object.\n      newOptions.validators = validatorOrOpts;\n      newOptions.asyncValidators = asyncValidator;\n    }\n    return new FormControl<T>(formState, {...newOptions, nonNullable: true});\n  }\n\n  /**\n   * Constructs a new `FormArray` from the given array of configurations,\n   * validators and options. Accepts a single generic argument, which is the type of each control\n   * inside the array.\n   *\n   * @param controls An array of child controls or control configs. Each child control is given an\n   *     index when it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an\n   *     `AbstractControlOptions` object that contains\n   * validation functions and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions.\n   */\n  array<T>(\n      controls: Array<T>, validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): FormArray<Element<T, null>> {\n    const createdControls = controls.map(c => this._createControl(c));\n    // Cast to `any` because the inferred types are not as specific as Element.\n    return new FormArray(createdControls, validatorOrOpts, asyncValidator) as any;\n  }\n\n  /** @internal */\n  _reduceControls<T>(controls:\n                         {[k: string]: T|ControlConfig<T>|FormControlState<T>|AbstractControl<T>}):\n      {[key: string]: AbstractControl} {\n    const createdControls: {[key: string]: AbstractControl} = {};\n    Object.keys(controls).forEach(controlName => {\n      createdControls[controlName] = this._createControl(controls[controlName]);\n    });\n    return createdControls;\n  }\n\n  /** @internal */\n  _createControl<T>(controls: T|FormControlState<T>|ControlConfig<T>|FormControl<T>|\n                    AbstractControl<T>): FormControl<T>|FormControl<T|null>|AbstractControl<T> {\n    if (controls instanceof FormControl) {\n      return controls as FormControl<T>;\n    } else if (controls instanceof AbstractControl) {  // A control; just return it\n      return controls;\n    } else if (Array.isArray(controls)) {  // ControlConfig Tuple\n      const value: T|FormControlState<T> = controls[0];\n      const validator: ValidatorFn|ValidatorFn[]|null = controls.length > 1 ? controls[1]! : null;\n      const asyncValidator: AsyncValidatorFn|AsyncValidatorFn[]|null =\n          controls.length > 2 ? controls[2]! : null;\n      return this.control<T>(value, validator, asyncValidator);\n    } else {  // T or FormControlState<T>\n      return this.control<T>(controls);\n    }\n  }\n}\n\n/**\n * @description\n * `NonNullableFormBuilder` is similar to {@link FormBuilder}, but automatically constructed\n * {@link FormControl} elements have `{nonNullable: true}` and are non-nullable.\n *\n * @publicApi\n */\n@Injectable({\n  providedIn: 'root',\n  useFactory: () => inject(FormBuilder).nonNullable,\n})\nexport abstract class NonNullableFormBuilder {\n  /**\n   * Similar to `FormBuilder#group`, except any implicitly constructed `FormControl`\n   * will be non-nullable (i.e. it will have `nonNullable` set to true). Note\n   * that already-constructed controls will not be altered.\n   */\n  abstract group<T extends {}>(\n      controls: T,\n      options?: AbstractControlOptions|null,\n      ): FormGroup<{[K in keyof T]: Element<T[K], never>}>;\n\n  /**\n   * Similar to `FormBuilder#record`, except any implicitly constructed `FormControl`\n   * will be non-nullable (i.e. it will have `nonNullable` set to true). Note\n   * that already-constructed controls will not be altered.\n   */\n  abstract record<T>(\n      controls: {[key: string]: T},\n      options?: AbstractControlOptions|null,\n      ): FormRecord<Element<T, never>>;\n\n  /**\n   * Similar to `FormBuilder#array`, except any implicitly constructed `FormControl`\n   * will be non-nullable (i.e. it will have `nonNullable` set to true). Note\n   * that already-constructed controls will not be altered.\n   */\n  abstract array<T>(\n      controls: Array<T>, validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): FormArray<Element<T, never>>;\n\n  /**\n   * Similar to `FormBuilder#control`, except this overridden version of `control` forces\n   * `nonNullable` to be `true`, resulting in the control always being non-nullable.\n   */\n  abstract control<T>(\n      formState: T|FormControlState<T>,\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): FormControl<T>;\n}\n\n/**\n * UntypedFormBuilder is the same as `FormBuilder`, but it provides untyped controls.\n */\n@Injectable({providedIn: 'root'})\nexport class UntypedFormBuilder extends FormBuilder {\n  /**\n   * Like `FormBuilder#group`, except the resulting group is untyped.\n   */\n  override group(\n      controlsConfig: {[key: string]: any},\n      options?: AbstractControlOptions|null,\n      ): UntypedFormGroup;\n\n  /**\n   * @deprecated This API is not typesafe and can result in issues with Closure Compiler renaming.\n   * Use the `FormBuilder#group` overload with `AbstractControlOptions` instead.\n   */\n  override group(\n      controlsConfig: {[key: string]: any},\n      options: {[key: string]: any},\n      ): UntypedFormGroup;\n\n  override group(\n      controlsConfig: {[key: string]: any},\n      options: AbstractControlOptions|{[key: string]: any}|null = null): UntypedFormGroup {\n    return super.group(controlsConfig, options);\n  }\n\n  /**\n   * Like `FormBuilder#control`, except the resulting control is untyped.\n   */\n  override control(\n      formState: any, validatorOrOpts?: ValidatorFn|ValidatorFn[]|FormControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): UntypedFormControl {\n    return super.control(formState, validatorOrOpts, asyncValidator);\n  }\n\n  /**\n   * Like `FormBuilder#array`, except the resulting array is untyped.\n   */\n  override array(\n      controlsConfig: any[],\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): UntypedFormArray {\n    return super.array(controlsConfig, validatorOrOpts, asyncValidator);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the forms package.\n */\n\nimport {Version} from '@angular/core';\n\n/**\n * @publicApi\n */\nexport const VERSION = new Version('17.0.3');\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ModuleWithProviders, NgModule} from '@angular/core';\n\nimport {InternalFormsSharedModule, NG_MODEL_WITH_FORM_CONTROL_WARNING, REACTIVE_DRIVEN_DIRECTIVES, TEMPLATE_DRIVEN_DIRECTIVES} from './directives';\nimport {CALL_SET_DISABLED_STATE, setDisabledStateDefault, SetDisabledStateOption} from './directives/shared';\n\n/**\n * Exports the required providers and directives for template-driven forms,\n * making them available for import by NgModules that import this module.\n *\n * Providers associated with this module:\n * * `RadioControlRegistry`\n *\n * @see [Forms Overview](/guide/forms-overview)\n * @see [Template-driven Forms Guide](/guide/forms)\n *\n * @publicApi\n */\n@NgModule({\n  declarations: TEMPLATE_DRIVEN_DIRECTIVES,\n  exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]\n})\nexport class FormsModule {\n  /**\n   * @description\n   * Provides options for configuring the forms module.\n   *\n   * @param opts An object of configuration options\n   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more\n   * correct, or to only call it `whenDisabled`, which is the legacy behavior.\n   */\n  static withConfig(opts: {\n    callSetDisabledState?: SetDisabledStateOption,\n  }): ModuleWithProviders<FormsModule> {\n    return {\n      ngModule: FormsModule,\n      providers: [{\n        provide: CALL_SET_DISABLED_STATE,\n        useValue: opts.callSetDisabledState ?? setDisabledStateDefault\n      }]\n    };\n  }\n}\n\n/**\n * Exports the required infrastructure and directives for reactive forms,\n * making them available for import by NgModules that import this module.\n *\n * Providers associated with this module:\n * * `RadioControlRegistry`\n *\n * @see [Forms Overview](guide/forms-overview)\n * @see [Reactive Forms Guide](guide/reactive-forms)\n *\n * @publicApi\n */\n@NgModule({\n  declarations: [REACTIVE_DRIVEN_DIRECTIVES],\n  exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]\n})\nexport class ReactiveFormsModule {\n  /**\n   * @description\n   * Provides options for configuring the reactive forms module.\n   *\n   * @param opts An object of configuration options\n   * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`\n   * binding is used with reactive form directives.\n   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more\n   * correct, or to only call it `whenDisabled`, which is the legacy behavior.\n   */\n  static withConfig(opts: {\n                    /** @deprecated as of v6 */ warnOnNgModelWithFormControl?: 'never'|'once'|\n                                                                            'always',\n                    callSetDisabledState?: SetDisabledStateOption,\n                    }): ModuleWithProviders<ReactiveFormsModule> {\n    return {\n      ngModule: ReactiveFormsModule,\n      providers: [\n        {\n          provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,\n          useValue: opts.warnOnNgModelWithFormControl ?? 'always'\n        },\n        {\n          provide: CALL_SET_DISABLED_STATE,\n          useValue: opts.callSetDisabledState ?? setDisabledStateDefault\n        }\n      ]\n    };\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * This module is used for handling user input, by defining and building a `FormGroup` that\n * consists of `FormControl` objects, and mapping them onto the DOM. `FormControl`\n * objects can then be used to read information from the form DOM elements.\n *\n * Forms providers are not included in default providers; you must import these providers\n * explicitly.\n */\n\nexport {InternalFormsSharedModule} from './directives';\nexport {AbstractControlDirective} from './directives/abstract_control_directive';\nexport {AbstractFormGroupDirective} from './directives/abstract_form_group_directive';\nexport {CheckboxControlValueAccessor} from './directives/checkbox_value_accessor';\nexport {ControlContainer} from './directives/control_container';\nexport {ControlValueAccessor, NG_VALUE_ACCESSOR} from './directives/control_value_accessor';\nexport {COMPOSITION_BUFFER_MODE, DefaultValueAccessor} from './directives/default_value_accessor';\nexport {Form} from './directives/form_interface';\nexport {NgControl} from './directives/ng_control';\nexport {NgControlStatus, NgControlStatusGroup} from './directives/ng_control_status';\nexport {NgForm} from './directives/ng_form';\nexport {NgModel} from './directives/ng_model';\nexport {NgModelGroup} from './directives/ng_model_group';\nexport {NgNoValidate} from './directives/ng_no_validate_directive';\nexport {NumberValueAccessor} from './directives/number_value_accessor';\nexport {RadioControlValueAccessor} from './directives/radio_control_value_accessor';\nexport {RangeValueAccessor} from './directives/range_value_accessor';\nexport {FormControlDirective} from './directives/reactive_directives/form_control_directive';\nexport {FormControlName} from './directives/reactive_directives/form_control_name';\nexport {FormGroupDirective} from './directives/reactive_directives/form_group_directive';\nexport {FormArrayName, FormGroupName} from './directives/reactive_directives/form_group_name';\nexport {NgSelectOption, SelectControlValueAccessor} from './directives/select_control_value_accessor';\nexport {SelectMultipleControlValueAccessor, NgSelectMultipleOption} from './directives/select_multiple_control_value_accessor';\nexport {SetDisabledStateOption} from './directives/shared';\nexport {AsyncValidator, AsyncValidatorFn, CheckboxRequiredValidator, EmailValidator, MaxLengthValidator, MaxValidator, MinLengthValidator, MinValidator, PatternValidator, RequiredValidator, ValidationErrors, Validator, ValidatorFn} from './directives/validators';\nexport {ControlConfig, FormBuilder, NonNullableFormBuilder, UntypedFormBuilder, Element} from './form_builder';\nexport {AbstractControl, AbstractControlOptions, FormControlStatus, CoerceStrArrToNumArr, GetProperty, Navigate, RawValue, Tokenize, TypedOrUntyped, Value, Writeable} from './model/abstract_model';\nexport {FormArray, isFormArray, UntypedFormArray, FormArrayRawValue, FormArrayValue} from './model/form_array';\nexport {FormControl, FormControlOptions, FormControlState, isFormControl, UntypedFormControl, FormControlCtor} from './model/form_control';\nexport {FormGroup, FormRecord, isFormGroup, isFormRecord, UntypedFormGroup, FormGroupRawValue, FormGroupValue, OptionalKeys} from './model/form_group';\nexport {NG_ASYNC_VALIDATORS, NG_VALIDATORS, Validators} from './validators';\nexport {VERSION} from './version';\n\nexport * from './form_providers';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\nexport * from './src/forms';\n\n// This file only reexports content of the `src` folder. Keep it that way.\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// This file is not used to build this module. It is only used during editing\n// by the TypeScript language service and during build for verification. `ngc`\n// replaces this file with production index.ts when it rewrites private symbol\n// names.\n\nexport * from './public_api';\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Platform, normalizePassiveListenerOptions} from '@angular/cdk/platform';\nimport {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Injectable,\n  NgZone,\n  OnDestroy,\n  OnInit,\n  Output,\n} from '@angular/core';\nimport {coerceElement} from '@angular/cdk/coercion';\nimport {EMPTY, Observable, Subject} from 'rxjs';\n\n/** An event that is emitted when the autofill state of an input changes. */\nexport type AutofillEvent = {\n  /** The element whose autofill state changes. */\n  target: Element;\n  /** Whether the element is currently autofilled. */\n  isAutofilled: boolean;\n};\n\n/** Used to track info about currently monitored elements. */\ntype MonitoredElementInfo = {\n  readonly subject: Subject<AutofillEvent>;\n  unlisten: () => void;\n};\n\n/** Options to pass to the animationstart listener. */\nconst listenerOptions = normalizePassiveListenerOptions({passive: true});\n\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\n@Injectable({providedIn: 'root'})\nexport class AutofillMonitor implements OnDestroy {\n  private _monitoredElements = new Map<Element, MonitoredElementInfo>();\n\n  constructor(private _platform: Platform, private _ngZone: NgZone) {}\n\n  /**\n   * Monitor for changes in the autofill state of the given input element.\n   * @param element The element to monitor.\n   * @return A stream of autofill state changes.\n   */\n  monitor(element: Element): Observable<AutofillEvent>;\n\n  /**\n   * Monitor for changes in the autofill state of the given input element.\n   * @param element The element to monitor.\n   * @return A stream of autofill state changes.\n   */\n  monitor(element: ElementRef<Element>): Observable<AutofillEvent>;\n\n  monitor(elementOrRef: Element | ElementRef<Element>): Observable<AutofillEvent> {\n    if (!this._platform.isBrowser) {\n      return EMPTY;\n    }\n\n    const element = coerceElement(elementOrRef);\n    const info = this._monitoredElements.get(element);\n\n    if (info) {\n      return info.subject;\n    }\n\n    const result = new Subject<AutofillEvent>();\n    const cssClass = 'cdk-text-field-autofilled';\n    const listener = ((event: AnimationEvent) => {\n      // Animation events fire on initial element render, we check for the presence of the autofill\n      // CSS class to make sure this is a real change in state, not just the initial render before\n      // we fire off events.\n      if (\n        event.animationName === 'cdk-text-field-autofill-start' &&\n        !element.classList.contains(cssClass)\n      ) {\n        element.classList.add(cssClass);\n        this._ngZone.run(() => result.next({target: event.target as Element, isAutofilled: true}));\n      } else if (\n        event.animationName === 'cdk-text-field-autofill-end' &&\n        element.classList.contains(cssClass)\n      ) {\n        element.classList.remove(cssClass);\n        this._ngZone.run(() => result.next({target: event.target as Element, isAutofilled: false}));\n      }\n    }) as EventListenerOrEventListenerObject;\n\n    this._ngZone.runOutsideAngular(() => {\n      element.addEventListener('animationstart', listener, listenerOptions);\n      element.classList.add('cdk-text-field-autofill-monitored');\n    });\n\n    this._monitoredElements.set(element, {\n      subject: result,\n      unlisten: () => {\n        element.removeEventListener('animationstart', listener, listenerOptions);\n      },\n    });\n\n    return result;\n  }\n\n  /**\n   * Stop monitoring the autofill state of the given input element.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: Element): void;\n\n  /**\n   * Stop monitoring the autofill state of the given input element.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: ElementRef<Element>): void;\n\n  stopMonitoring(elementOrRef: Element | ElementRef<Element>): void {\n    const element = coerceElement(elementOrRef);\n    const info = this._monitoredElements.get(element);\n\n    if (info) {\n      info.unlisten();\n      info.subject.complete();\n      element.classList.remove('cdk-text-field-autofill-monitored');\n      element.classList.remove('cdk-text-field-autofilled');\n      this._monitoredElements.delete(element);\n    }\n  }\n\n  ngOnDestroy() {\n    this._monitoredElements.forEach((_info, element) => this.stopMonitoring(element));\n  }\n}\n\n/** A directive that can be used to monitor the autofill state of an input. */\n@Directive({\n  selector: '[cdkAutofill]',\n})\nexport class CdkAutofill implements OnDestroy, OnInit {\n  /** Emits when the autofill state of the element changes. */\n  @Output() readonly cdkAutofill = new EventEmitter<AutofillEvent>();\n\n  constructor(\n    private _elementRef: ElementRef<HTMLElement>,\n    private _autofillMonitor: AutofillMonitor,\n  ) {}\n\n  ngOnInit() {\n    this._autofillMonitor\n      .monitor(this._elementRef)\n      .subscribe(event => this.cdkAutofill.emit(event));\n  }\n\n  ngOnDestroy() {\n    this._autofillMonitor.stopMonitoring(this._elementRef);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NumberInput, coerceNumberProperty} from '@angular/cdk/coercion';\nimport {\n  Directive,\n  ElementRef,\n  Input,\n  AfterViewInit,\n  DoCheck,\n  OnDestroy,\n  NgZone,\n  Optional,\n  Inject,\n  booleanAttribute,\n} from '@angular/core';\nimport {Platform} from '@angular/cdk/platform';\nimport {auditTime, takeUntil} from 'rxjs/operators';\nimport {fromEvent, Subject} from 'rxjs';\nimport {DOCUMENT} from '@angular/common';\n\n/** Directive to automatically resize a textarea to fit its content. */\n@Directive({\n  selector: 'textarea[cdkTextareaAutosize]',\n  exportAs: 'cdkTextareaAutosize',\n  host: {\n    'class': 'cdk-textarea-autosize',\n    // Textarea elements that have the directive applied should have a single row by default.\n    // Browsers normally show two rows by default and therefore this limits the minRows binding.\n    'rows': '1',\n    '(input)': '_noopInputHandler()',\n  },\n})\nexport class CdkTextareaAutosize implements AfterViewInit, DoCheck, OnDestroy {\n  /** Keep track of the previous textarea value to avoid resizing when the value hasn't changed. */\n  private _previousValue?: string;\n  private _initialHeight: string | undefined;\n  private readonly _destroyed = new Subject<void>();\n\n  private _minRows: number;\n  private _maxRows: number;\n  private _enabled: boolean = true;\n\n  /**\n   * Value of minRows as of last resize. If the minRows has decreased, the\n   * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight\n   * does not have the same problem because it does not affect the textarea's scrollHeight.\n   */\n  private _previousMinRows: number = -1;\n\n  private _textareaElement: HTMLTextAreaElement;\n\n  /** Minimum amount of rows in the textarea. */\n  @Input('cdkAutosizeMinRows')\n  get minRows(): number {\n    return this._minRows;\n  }\n  set minRows(value: NumberInput) {\n    this._minRows = coerceNumberProperty(value);\n    this._setMinHeight();\n  }\n\n  /** Maximum amount of rows in the textarea. */\n  @Input('cdkAutosizeMaxRows')\n  get maxRows(): number {\n    return this._maxRows;\n  }\n  set maxRows(value: NumberInput) {\n    this._maxRows = coerceNumberProperty(value);\n    this._setMaxHeight();\n  }\n\n  /** Whether autosizing is enabled or not */\n  @Input({alias: 'cdkTextareaAutosize', transform: booleanAttribute})\n  get enabled(): boolean {\n    return this._enabled;\n  }\n  set enabled(value: boolean) {\n    // Only act if the actual value changed. This specifically helps to not run\n    // resizeToFitContent too early (i.e. before ngAfterViewInit)\n    if (this._enabled !== value) {\n      (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();\n    }\n  }\n\n  @Input()\n  get placeholder(): string {\n    return this._textareaElement.placeholder;\n  }\n  set placeholder(value: string) {\n    this._cachedPlaceholderHeight = undefined;\n\n    if (value) {\n      this._textareaElement.setAttribute('placeholder', value);\n    } else {\n      this._textareaElement.removeAttribute('placeholder');\n    }\n\n    this._cacheTextareaPlaceholderHeight();\n  }\n\n  /** Cached height of a textarea with a single row. */\n  private _cachedLineHeight: number;\n  /** Cached height of a textarea with only the placeholder. */\n  private _cachedPlaceholderHeight?: number;\n\n  /** Used to reference correct document/window */\n  protected _document?: Document;\n\n  private _hasFocus: boolean;\n\n  private _isViewInited = false;\n\n  constructor(\n    private _elementRef: ElementRef<HTMLElement>,\n    private _platform: Platform,\n    private _ngZone: NgZone,\n    /** @breaking-change 11.0.0 make document required */\n    @Optional() @Inject(DOCUMENT) document?: any,\n  ) {\n    this._document = document;\n\n    this._textareaElement = this._elementRef.nativeElement as HTMLTextAreaElement;\n  }\n\n  /** Sets the minimum height of the textarea as determined by minRows. */\n  _setMinHeight(): void {\n    const minHeight =\n      this.minRows && this._cachedLineHeight ? `${this.minRows * this._cachedLineHeight}px` : null;\n\n    if (minHeight) {\n      this._textareaElement.style.minHeight = minHeight;\n    }\n  }\n\n  /** Sets the maximum height of the textarea as determined by maxRows. */\n  _setMaxHeight(): void {\n    const maxHeight =\n      this.maxRows && this._cachedLineHeight ? `${this.maxRows * this._cachedLineHeight}px` : null;\n\n    if (maxHeight) {\n      this._textareaElement.style.maxHeight = maxHeight;\n    }\n  }\n\n  ngAfterViewInit() {\n    if (this._platform.isBrowser) {\n      // Remember the height which we started with in case autosizing is disabled\n      this._initialHeight = this._textareaElement.style.height;\n      this.resizeToFitContent();\n\n      this._ngZone.runOutsideAngular(() => {\n        const window = this._getWindow();\n\n        fromEvent(window, 'resize')\n          .pipe(auditTime(16), takeUntil(this._destroyed))\n          .subscribe(() => this.resizeToFitContent(true));\n\n        this._textareaElement.addEventListener('focus', this._handleFocusEvent);\n        this._textareaElement.addEventListener('blur', this._handleFocusEvent);\n      });\n\n      this._isViewInited = true;\n      this.resizeToFitContent(true);\n    }\n  }\n\n  ngOnDestroy() {\n    this._textareaElement.removeEventListener('focus', this._handleFocusEvent);\n    this._textareaElement.removeEventListener('blur', this._handleFocusEvent);\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /**\n   * Cache the height of a single-row textarea if it has not already been cached.\n   *\n   * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n   * maxRows. For the initial version, we will assume that the height of a single line in the\n   * textarea does not ever change.\n   */\n  private _cacheTextareaLineHeight(): void {\n    if (this._cachedLineHeight) {\n      return;\n    }\n\n    // Use a clone element because we have to override some styles.\n    let textareaClone = this._textareaElement.cloneNode(false) as HTMLTextAreaElement;\n    textareaClone.rows = 1;\n\n    // Use `position: absolute` so that this doesn't cause a browser layout and use\n    // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n    // would affect the height.\n    textareaClone.style.position = 'absolute';\n    textareaClone.style.visibility = 'hidden';\n    textareaClone.style.border = 'none';\n    textareaClone.style.padding = '0';\n    textareaClone.style.height = '';\n    textareaClone.style.minHeight = '';\n    textareaClone.style.maxHeight = '';\n\n    // In Firefox it happens that textarea elements are always bigger than the specified amount\n    // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n    // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n    // to hidden. This ensures that there is no invalid calculation of the line height.\n    // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n    textareaClone.style.overflow = 'hidden';\n\n    this._textareaElement.parentNode!.appendChild(textareaClone);\n    this._cachedLineHeight = textareaClone.clientHeight;\n    textareaClone.remove();\n\n    // Min and max heights have to be re-calculated if the cached line height changes\n    this._setMinHeight();\n    this._setMaxHeight();\n  }\n\n  private _measureScrollHeight(): number {\n    const element = this._textareaElement;\n    const previousMargin = element.style.marginBottom || '';\n    const isFirefox = this._platform.FIREFOX;\n    const needsMarginFiller = isFirefox && this._hasFocus;\n    const measuringClass = isFirefox\n      ? 'cdk-textarea-autosize-measuring-firefox'\n      : 'cdk-textarea-autosize-measuring';\n\n    // In some cases the page might move around while we're measuring the `textarea` on Firefox. We\n    // work around it by assigning a temporary margin with the same height as the `textarea` so that\n    // it occupies the same amount of space. See #23233.\n    if (needsMarginFiller) {\n      element.style.marginBottom = `${element.clientHeight}px`;\n    }\n\n    // Reset the textarea height to auto in order to shrink back to its default size.\n    // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n    element.classList.add(measuringClass);\n    // The measuring class includes a 2px padding to workaround an issue with Chrome,\n    // so we account for that extra space here by subtracting 4 (2px top + 2px bottom).\n    const scrollHeight = element.scrollHeight - 4;\n    element.classList.remove(measuringClass);\n\n    if (needsMarginFiller) {\n      element.style.marginBottom = previousMargin;\n    }\n\n    return scrollHeight;\n  }\n\n  private _cacheTextareaPlaceholderHeight(): void {\n    if (!this._isViewInited || this._cachedPlaceholderHeight != undefined) {\n      return;\n    }\n    if (!this.placeholder) {\n      this._cachedPlaceholderHeight = 0;\n      return;\n    }\n\n    const value = this._textareaElement.value;\n\n    this._textareaElement.value = this._textareaElement.placeholder;\n    this._cachedPlaceholderHeight = this._measureScrollHeight();\n    this._textareaElement.value = value;\n  }\n\n  /** Handles `focus` and `blur` events. */\n  private _handleFocusEvent = (event: FocusEvent) => {\n    this._hasFocus = event.type === 'focus';\n  };\n\n  ngDoCheck() {\n    if (this._platform.isBrowser) {\n      this.resizeToFitContent();\n    }\n  }\n\n  /**\n   * Resize the textarea to fit its content.\n   * @param force Whether to force a height recalculation. By default the height will be\n   *    recalculated only if the value changed since the last call.\n   */\n  resizeToFitContent(force: boolean = false) {\n    // If autosizing is disabled, just skip everything else\n    if (!this._enabled) {\n      return;\n    }\n\n    this._cacheTextareaLineHeight();\n    this._cacheTextareaPlaceholderHeight();\n\n    // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n    // in checking the height of the textarea.\n    if (!this._cachedLineHeight) {\n      return;\n    }\n\n    const textarea = this._elementRef.nativeElement as HTMLTextAreaElement;\n    const value = textarea.value;\n\n    // Only resize if the value or minRows have changed since these calculations can be expensive.\n    if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {\n      return;\n    }\n\n    const scrollHeight = this._measureScrollHeight();\n    const height = Math.max(scrollHeight, this._cachedPlaceholderHeight || 0);\n\n    // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n    textarea.style.height = `${height}px`;\n\n    this._ngZone.runOutsideAngular(() => {\n      if (typeof requestAnimationFrame !== 'undefined') {\n        requestAnimationFrame(() => this._scrollToCaretPosition(textarea));\n      } else {\n        setTimeout(() => this._scrollToCaretPosition(textarea));\n      }\n    });\n\n    this._previousValue = value;\n    this._previousMinRows = this._minRows;\n  }\n\n  /**\n   * Resets the textarea to its original size\n   */\n  reset() {\n    // Do not try to change the textarea, if the initialHeight has not been determined yet\n    // This might potentially remove styles when reset() is called before ngAfterViewInit\n    if (this._initialHeight !== undefined) {\n      this._textareaElement.style.height = this._initialHeight;\n    }\n  }\n\n  _noopInputHandler() {\n    // no-op handler that ensures we're running change detection on input events.\n  }\n\n  /** Access injected document if available or fallback to global document reference */\n  private _getDocument(): Document {\n    return this._document || document;\n  }\n\n  /** Use defaultView of injected document if available or fallback to global window reference */\n  private _getWindow(): Window {\n    const doc = this._getDocument();\n    return doc.defaultView || window;\n  }\n\n  /**\n   * Scrolls a textarea to the caret position. On Firefox resizing the textarea will\n   * prevent it from scrolling to the caret position. We need to re-set the selection\n   * in order for it to scroll to the proper position.\n   */\n  private _scrollToCaretPosition(textarea: HTMLTextAreaElement) {\n    const {selectionStart, selectionEnd} = textarea;\n\n    // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n    // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n    // between the time we requested the animation frame and when it was executed.\n    // Also note that we have to assert that the textarea is focused before we set the\n    // selection range. Setting the selection range on a non-focused textarea will cause\n    // it to receive focus on IE and Edge.\n    if (!this._destroyed.isStopped && this._hasFocus) {\n      textarea.setSelectionRange(selectionStart, selectionEnd);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {CdkAutofill} from './autofill';\nimport {CdkTextareaAutosize} from './autosize';\n\n@NgModule({\n  declarations: [CdkAutofill, CdkTextareaAutosize],\n  exports: [CdkAutofill, CdkTextareaAutosize],\n})\nexport class TextFieldModule {}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** @docs-private */\nexport function getMatInputUnsupportedTypeError(type: string): Error {\n  return Error(`Input type \"${type}\" isn't supported by matInput.`);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nexport const MAT_INPUT_VALUE_ACCESSOR = new InjectionToken<{value: any}>(\n  'MAT_INPUT_VALUE_ACCESSOR',\n);\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {getSupportedInputTypes, Platform} from '@angular/cdk/platform';\nimport {AutofillMonitor} from '@angular/cdk/text-field';\nimport {\n  AfterViewInit,\n  Directive,\n  DoCheck,\n  ElementRef,\n  Inject,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Self,\n} from '@angular/core';\nimport {FormGroupDirective, NgControl, NgForm, Validators} from '@angular/forms';\nimport {CanUpdateErrorState, ErrorStateMatcher, mixinErrorState} from '@angular/material/core';\nimport {MatFormFieldControl, MatFormField, MAT_FORM_FIELD} from '@angular/material/form-field';\nimport {Subject} from 'rxjs';\nimport {getMatInputUnsupportedTypeError} from './input-errors';\nimport {MAT_INPUT_VALUE_ACCESSOR} from './input-value-accessor';\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = [\n  'button',\n  'checkbox',\n  'file',\n  'hidden',\n  'image',\n  'radio',\n  'range',\n  'reset',\n  'submit',\n];\n\nlet nextUniqueId = 0;\n\n// Boilerplate for applying mixins to MatInput.\n/** @docs-private */\nconst _MatInputBase = mixinErrorState(\n  class {\n    /**\n     * Emits whenever the component state changes and should cause the parent\n     * form field to update. Implemented as part of `MatFormFieldControl`.\n     * @docs-private\n     */\n    readonly stateChanges = new Subject<void>();\n\n    constructor(\n      public _defaultErrorStateMatcher: ErrorStateMatcher,\n      public _parentForm: NgForm,\n      public _parentFormGroup: FormGroupDirective,\n      /**\n       * Form control bound to the component.\n       * Implemented as part of `MatFormFieldControl`.\n       * @docs-private\n       */\n      public ngControl: NgControl,\n    ) {}\n  },\n);\n\n@Directive({\n  selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n  exportAs: 'matInput',\n  host: {\n    'class': 'mat-mdc-input-element',\n    // The BaseMatInput parent class adds `mat-input-element`, `mat-form-field-control` and\n    // `mat-form-field-autofill-control` to the CSS class list, but this should not be added for\n    // this MDC equivalent input.\n    '[class.mat-input-server]': '_isServer',\n    '[class.mat-mdc-form-field-textarea-control]': '_isInFormField && _isTextarea',\n    '[class.mat-mdc-form-field-input-control]': '_isInFormField',\n    '[class.mdc-text-field__input]': '_isInFormField',\n    '[class.mat-mdc-native-select-inline]': '_isInlineSelect()',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[id]': 'id',\n    '[disabled]': 'disabled',\n    '[required]': 'required',\n    '[attr.name]': 'name || null',\n    '[attr.readonly]': 'readonly && !_isNativeSelect || null',\n    // Only mark the input as invalid for assistive technology if it has a value since the\n    // state usually overlaps with `aria-required` when the input is empty and can be redundant.\n    '[attr.aria-invalid]': '(empty && required) ? null : errorState',\n    '[attr.aria-required]': 'required',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[attr.id]': 'id',\n    '(focus)': '_focusChanged(true)',\n    '(blur)': '_focusChanged(false)',\n    '(input)': '_onInput()',\n  },\n  providers: [{provide: MatFormFieldControl, useExisting: MatInput}],\n})\nexport class MatInput\n  extends _MatInputBase\n  implements\n    MatFormFieldControl<any>,\n    OnChanges,\n    OnDestroy,\n    AfterViewInit,\n    DoCheck,\n    CanUpdateErrorState\n{\n  protected _uid = `mat-input-${nextUniqueId++}`;\n  protected _previousNativeValue: any;\n  private _inputValueAccessor: {value: any};\n  private _previousPlaceholder: string | null;\n\n  /** Whether the component is being rendered on the server. */\n  readonly _isServer: boolean;\n\n  /** Whether the component is a native html select. */\n  readonly _isNativeSelect: boolean;\n\n  /** Whether the component is a textarea. */\n  readonly _isTextarea: boolean;\n\n  /** Whether the input is inside of a form field. */\n  readonly _isInFormField: boolean;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  focused: boolean = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  override readonly stateChanges: Subject<void> = new Subject<void>();\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  controlType: string = 'mat-input';\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  autofilled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n\n    // Browsers may not fire the blur event if the input is disabled too quickly.\n    // Reset from here to ensure that the element doesn't become stuck.\n    if (this.focused) {\n      this.focused = false;\n      this.stateChanges.next();\n    }\n  }\n  protected _disabled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get id(): string {\n    return this._id;\n  }\n  set id(value: string) {\n    this._id = value || this._uid;\n  }\n  protected _id: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input() placeholder: string;\n\n  /**\n   * Name of the input.\n   * @docs-private\n   */\n  @Input() name: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get required(): boolean {\n    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n  protected _required: boolean | undefined;\n\n  /** Input type of the element. */\n  @Input()\n  get type(): string {\n    return this._type;\n  }\n  set type(value: string) {\n    this._type = value || 'text';\n    this._validateType();\n\n    // When using Angular inputs, developers are no longer able to set the properties on the native\n    // input element. To ensure that bindings for `type` work, we need to sync the setter\n    // with the native property. Textarea elements don't support the type property or attribute.\n    if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n      (this._elementRef.nativeElement as HTMLInputElement).type = this._type;\n    }\n  }\n  protected _type = 'text';\n\n  /** An object used to control when error messages are shown. */\n  @Input() override errorStateMatcher: ErrorStateMatcher;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input('aria-describedby') userAriaDescribedBy: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get value(): string {\n    return this._inputValueAccessor.value;\n  }\n  set value(value: any) {\n    if (value !== this.value) {\n      this._inputValueAccessor.value = value;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Whether the element is readonly. */\n  @Input()\n  get readonly(): boolean {\n    return this._readonly;\n  }\n  set readonly(value: BooleanInput) {\n    this._readonly = coerceBooleanProperty(value);\n  }\n  private _readonly = false;\n\n  protected _neverEmptyInputTypes = [\n    'date',\n    'datetime',\n    'datetime-local',\n    'month',\n    'time',\n    'week',\n  ].filter(t => getSupportedInputTypes().has(t));\n\n  constructor(\n    protected _elementRef: ElementRef<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>,\n    protected _platform: Platform,\n    @Optional() @Self() ngControl: NgControl,\n    @Optional() _parentForm: NgForm,\n    @Optional() _parentFormGroup: FormGroupDirective,\n    _defaultErrorStateMatcher: ErrorStateMatcher,\n    @Optional() @Self() @Inject(MAT_INPUT_VALUE_ACCESSOR) inputValueAccessor: any,\n    private _autofillMonitor: AutofillMonitor,\n    ngZone: NgZone,\n    // TODO: Remove this once the legacy appearance has been removed. We only need\n    // to inject the form field for determining whether the placeholder has been promoted.\n    @Optional() @Inject(MAT_FORM_FIELD) protected _formField?: MatFormField,\n  ) {\n    super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n\n    const element = this._elementRef.nativeElement;\n    const nodeName = element.nodeName.toLowerCase();\n\n    // If no input value accessor was explicitly specified, use the element as the input value\n    // accessor.\n    this._inputValueAccessor = inputValueAccessor || element;\n\n    this._previousNativeValue = this.value;\n\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n\n    // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n    // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n    // exists on iOS, we only bother to install the listener on iOS.\n    if (_platform.IOS) {\n      ngZone.runOutsideAngular(() => {\n        _elementRef.nativeElement.addEventListener('keyup', this._iOSKeyupListener);\n      });\n    }\n\n    this._isServer = !this._platform.isBrowser;\n    this._isNativeSelect = nodeName === 'select';\n    this._isTextarea = nodeName === 'textarea';\n    this._isInFormField = !!_formField;\n\n    if (this._isNativeSelect) {\n      this.controlType = (element as HTMLSelectElement).multiple\n        ? 'mat-native-select-multiple'\n        : 'mat-native-select';\n    }\n  }\n\n  ngAfterViewInit() {\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n        this.autofilled = event.isAutofilled;\n        this.stateChanges.next();\n      });\n    }\n  }\n\n  ngOnChanges() {\n    this.stateChanges.next();\n  }\n\n  ngOnDestroy() {\n    this.stateChanges.complete();\n\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    }\n\n    if (this._platform.IOS) {\n      this._elementRef.nativeElement.removeEventListener('keyup', this._iOSKeyupListener);\n    }\n  }\n\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n\n      // Since the input isn't a `ControlValueAccessor`, we don't have a good way of knowing when\n      // the disabled state has changed. We can't use the `ngControl.statusChanges`, because it\n      // won't fire if the input is disabled with `emitEvents = false`, despite the input becoming\n      // disabled.\n      if (this.ngControl.disabled !== null && this.ngControl.disabled !== this.disabled) {\n        this.disabled = this.ngControl.disabled;\n        this.stateChanges.next();\n      }\n    }\n\n    // We need to dirty-check the native element's value, because there are some cases where\n    // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n    // updating the value using `emitEvent: false`).\n    this._dirtyCheckNativeValue();\n\n    // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n    // present or not depends on a query which is prone to \"changed after checked\" errors.\n    this._dirtyCheckPlaceholder();\n  }\n\n  /** Focuses the input. */\n  focus(options?: FocusOptions): void {\n    this._elementRef.nativeElement.focus(options);\n  }\n\n  /** Callback for the cases where the focused state of the input changes. */\n  _focusChanged(isFocused: boolean) {\n    if (isFocused !== this.focused) {\n      this.focused = isFocused;\n      this.stateChanges.next();\n    }\n  }\n\n  _onInput() {\n    // This is a noop function and is used to let Angular know whenever the value changes.\n    // Angular will run a new change detection each time the `input` event has been dispatched.\n    // It's necessary that Angular recognizes the value change, because when floatingLabel\n    // is set to false and Angular forms aren't used, the placeholder won't recognize the\n    // value changes and will not disappear.\n    // Listening to the input event wouldn't be necessary when the input is using the\n    // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n  }\n\n  /** Does some manual dirty checking on the native input `value` property. */\n  protected _dirtyCheckNativeValue() {\n    const newValue = this._elementRef.nativeElement.value;\n\n    if (this._previousNativeValue !== newValue) {\n      this._previousNativeValue = newValue;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Does some manual dirty checking on the native input `placeholder` attribute. */\n  private _dirtyCheckPlaceholder() {\n    const placeholder = this._getPlaceholder();\n    if (placeholder !== this._previousPlaceholder) {\n      const element = this._elementRef.nativeElement;\n      this._previousPlaceholder = placeholder;\n      placeholder\n        ? element.setAttribute('placeholder', placeholder)\n        : element.removeAttribute('placeholder');\n    }\n  }\n\n  /** Gets the current placeholder of the form field. */\n  protected _getPlaceholder(): string | null {\n    return this.placeholder || null;\n  }\n\n  /** Make sure the input is a supported type. */\n  protected _validateType() {\n    if (\n      MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 &&\n      (typeof ngDevMode === 'undefined' || ngDevMode)\n    ) {\n      throw getMatInputUnsupportedTypeError(this._type);\n    }\n  }\n\n  /** Checks whether the input type is one of the types that are never empty. */\n  protected _isNeverEmpty() {\n    return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n  }\n\n  /** Checks whether the input is invalid based on the native validation. */\n  protected _isBadInput() {\n    // The `validity` property won't be present on platform-server.\n    let validity = (this._elementRef.nativeElement as HTMLInputElement).validity;\n    return validity && validity.badInput;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get empty(): boolean {\n    return (\n      !this._isNeverEmpty() &&\n      !this._elementRef.nativeElement.value &&\n      !this._isBadInput() &&\n      !this.autofilled\n    );\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get shouldLabelFloat(): boolean {\n    if (this._isNativeSelect) {\n      // For a single-selection `<select>`, the label should float when the selected option has\n      // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n      // overlapping the label with the options.\n      const selectElement = this._elementRef.nativeElement as HTMLSelectElement;\n      const firstOption: HTMLOptionElement | undefined = selectElement.options[0];\n\n      // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n      // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n      return (\n        this.focused ||\n        selectElement.multiple ||\n        !this.empty ||\n        !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label)\n      );\n    } else {\n      return this.focused || !this.empty;\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]) {\n    if (ids.length) {\n      this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      this._elementRef.nativeElement.removeAttribute('aria-describedby');\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  onContainerClick() {\n    // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n    // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n    // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n    if (!this.focused) {\n      this.focus();\n    }\n  }\n\n  /** Whether the form control is a native select that is displayed inline. */\n  _isInlineSelect(): boolean {\n    const element = this._elementRef.nativeElement as HTMLSelectElement;\n    return this._isNativeSelect && (element.multiple || element.size > 1);\n  }\n\n  private _iOSKeyupListener = (event: Event): void => {\n    const el = event.target as HTMLInputElement;\n\n    // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\n    // indicate different things. If the value is 0, it means that the caret is at the start\n    // of the input, whereas a value of `null` means that the input doesn't support\n    // manipulating the selection range. Inputs that don't support setting the selection range\n    // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\n    // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n    if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\n      // Note: Just setting `0, 0` doesn't fix the issue. Setting\n      // `1, 1` fixes it for the first time that you type text and\n      // then hold delete. Toggling to `1, 1` and then back to\n      // `0, 0` seems to completely fix it.\n      el.setSelectionRange(1, 1);\n      el.setSelectionRange(0, 0);\n    }\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TextFieldModule} from '@angular/cdk/text-field';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule} from '@angular/material/core';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {MatInput} from './input';\n\n@NgModule({\n  imports: [MatCommonModule, MatFormFieldModule],\n  exports: [MatInput, MatFormFieldModule, TextFieldModule, MatCommonModule],\n  declarations: [MatInput],\n})\nexport class MatInputModule {}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** @docs-private */\nexport function createMissingDateImplError(provider: string) {\n  return Error(\n    `MatDatepicker: No provider found for ${provider}. You must import one of the following ` +\n      `modules at your application root: MatNativeDateModule, MatDateFnsModule, MatLuxonDateModule, MatMomentDateModule, or provide a ` +\n      `custom implementation.`,\n  );\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '@angular/core';\nimport {Subject} from 'rxjs';\n\n/** Datepicker data that requires internationalization. */\n@Injectable({providedIn: 'root'})\nexport class MatDatepickerIntl {\n  /**\n   * Stream that emits whenever the labels here are changed. Use this to notify\n   * components if the labels have changed after initialization.\n   */\n  readonly changes: Subject<void> = new Subject<void>();\n\n  /** A label for the calendar popup (used by screen readers). */\n  calendarLabel = 'Calendar';\n\n  /** A label for the button used to open the calendar popup (used by screen readers). */\n  openCalendarLabel = 'Open calendar';\n\n  /** Label for the button used to close the calendar popup. */\n  closeCalendarLabel = 'Close calendar';\n\n  /** A label for the previous month button (used by screen readers). */\n  prevMonthLabel = 'Previous month';\n\n  /** A label for the next month button (used by screen readers). */\n  nextMonthLabel = 'Next month';\n\n  /** A label for the previous year button (used by screen readers). */\n  prevYearLabel = 'Previous year';\n\n  /** A label for the next year button (used by screen readers). */\n  nextYearLabel = 'Next year';\n\n  /** A label for the previous multi-year button (used by screen readers). */\n  prevMultiYearLabel = 'Previous 24 years';\n\n  /** A label for the next multi-year button (used by screen readers). */\n  nextMultiYearLabel = 'Next 24 years';\n\n  /** A label for the 'switch to month view' button (used by screen readers). */\n  switchToMonthViewLabel = 'Choose date';\n\n  /** A label for the 'switch to year view' button (used by screen readers). */\n  switchToMultiYearViewLabel = 'Choose month and year';\n\n  /**\n   * A label for the first date of a range of dates (used by screen readers).\n   * @deprecated Provide your own internationalization string.\n   * @breaking-change 17.0.0\n   */\n  startDateLabel = 'Start date';\n\n  /**\n   * A label for the last date of a range of dates (used by screen readers).\n   * @deprecated Provide your own internationalization string.\n   * @breaking-change 17.0.0\n   */\n  endDateLabel = 'End date';\n\n  /** Formats a range of years (used for visuals). */\n  formatYearRange(start: string, end: string): string {\n    return `${start} \\u2013 ${end}`;\n  }\n\n  /** Formats a label for a range of years (used by screen readers). */\n  formatYearRangeLabel(start: string, end: string): string {\n    return `${start} to ${end}`;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Platform, normalizePassiveListenerOptions} from '@angular/cdk/platform';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  EventEmitter,\n  Input,\n  Output,\n  ViewEncapsulation,\n  NgZone,\n  OnChanges,\n  SimpleChanges,\n  OnDestroy,\n  AfterViewChecked,\n  inject,\n} from '@angular/core';\nimport {take} from 'rxjs/operators';\n\n/** Extra CSS classes that can be associated with a calendar cell. */\nexport type MatCalendarCellCssClasses = string | string[] | Set<string> | {[key: string]: any};\n\n/** Function that can generate the extra classes that should be added to a calendar cell. */\nexport type MatCalendarCellClassFunction<D> = (\n  date: D,\n  view: 'month' | 'year' | 'multi-year',\n) => MatCalendarCellCssClasses;\n\n/**\n * An internal class that represents the data corresponding to a single calendar cell.\n * @docs-private\n */\nexport class MatCalendarCell<D = any> {\n  constructor(\n    public value: number,\n    public displayValue: string,\n    public ariaLabel: string,\n    public enabled: boolean,\n    public cssClasses: MatCalendarCellCssClasses = {},\n    public compareValue = value,\n    public rawValue?: D,\n  ) {}\n}\n\n/** Event emitted when a date inside the calendar is triggered as a result of a user action. */\nexport interface MatCalendarUserEvent<D> {\n  value: D;\n  event: Event;\n}\n\nlet calendarBodyId = 1;\n\n/** Event options that can be used to bind an active, capturing event. */\nconst activeCapturingEventOptions = normalizePassiveListenerOptions({\n  passive: false,\n  capture: true,\n});\n\n/** Event options that can be used to bind a passive, capturing event. */\nconst passiveCapturingEventOptions = normalizePassiveListenerOptions({\n  passive: true,\n  capture: true,\n});\n\n/** Event options that can be used to bind a passive, non-capturing event. */\nconst passiveEventOptions = normalizePassiveListenerOptions({passive: true});\n\n/**\n * An internal component used to display calendar data in a table.\n * @docs-private\n */\n@Component({\n  selector: '[mat-calendar-body]',\n  templateUrl: 'calendar-body.html',\n  styleUrls: ['calendar-body.css'],\n  host: {\n    'class': 'mat-calendar-body',\n  },\n  exportAs: 'matCalendarBody',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatCalendarBody<D = any> implements OnChanges, OnDestroy, AfterViewChecked {\n  private _platform = inject(Platform);\n\n  /**\n   * Used to skip the next focus event when rendering the preview range.\n   * We need a flag like this, because some browsers fire focus events asynchronously.\n   */\n  private _skipNextFocus: boolean;\n\n  /**\n   * Used to focus the active cell after change detection has run.\n   */\n  private _focusActiveCellAfterViewChecked = false;\n\n  /** The label for the table. (e.g. \"Jan 2017\"). */\n  @Input() label: string;\n\n  /** The cells to display in the table. */\n  @Input() rows: MatCalendarCell[][];\n\n  /** The value in the table that corresponds to today. */\n  @Input() todayValue: number;\n\n  /** Start value of the selected date range. */\n  @Input() startValue: number;\n\n  /** End value of the selected date range. */\n  @Input() endValue: number;\n\n  /** The minimum number of free cells needed to fit the label in the first row. */\n  @Input() labelMinRequiredCells: number;\n\n  /** The number of columns in the table. */\n  @Input() numCols: number = 7;\n\n  /** The cell number of the active cell in the table. */\n  @Input() activeCell: number = 0;\n\n  ngAfterViewChecked() {\n    if (this._focusActiveCellAfterViewChecked) {\n      this._focusActiveCell();\n      this._focusActiveCellAfterViewChecked = false;\n    }\n  }\n\n  /** Whether a range is being selected. */\n  @Input() isRange: boolean = false;\n\n  /**\n   * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be\n   * maintained even as the table resizes.\n   */\n  @Input() cellAspectRatio: number = 1;\n\n  /** Start of the comparison range. */\n  @Input() comparisonStart: number | null;\n\n  /** End of the comparison range. */\n  @Input() comparisonEnd: number | null;\n\n  /** Start of the preview range. */\n  @Input() previewStart: number | null = null;\n\n  /** End of the preview range. */\n  @Input() previewEnd: number | null = null;\n\n  /** ARIA Accessible name of the `<input matStartDate/>` */\n  @Input() startDateAccessibleName: string | null;\n\n  /** ARIA Accessible name of the `<input matEndDate/>` */\n  @Input() endDateAccessibleName: string | null;\n\n  /** Emits when a new value is selected. */\n  @Output() readonly selectedValueChange = new EventEmitter<MatCalendarUserEvent<number>>();\n\n  /** Emits when the preview has changed as a result of a user action. */\n  @Output() readonly previewChange = new EventEmitter<\n    MatCalendarUserEvent<MatCalendarCell | null>\n  >();\n\n  @Output() readonly activeDateChange = new EventEmitter<MatCalendarUserEvent<number>>();\n\n  /** Emits the date at the possible start of a drag event. */\n  @Output() readonly dragStarted = new EventEmitter<MatCalendarUserEvent<D>>();\n\n  /** Emits the date at the conclusion of a drag, or null if mouse was not released on a date. */\n  @Output() readonly dragEnded = new EventEmitter<MatCalendarUserEvent<D | null>>();\n\n  /** The number of blank cells to put at the beginning for the first row. */\n  _firstRowOffset: number;\n\n  /** Padding for the individual date cells. */\n  _cellPadding: string;\n\n  /** Width of an individual cell. */\n  _cellWidth: string;\n\n  private _didDragSinceMouseDown = false;\n\n  constructor(\n    private _elementRef: ElementRef<HTMLElement>,\n    private _ngZone: NgZone,\n  ) {\n    _ngZone.runOutsideAngular(() => {\n      const element = _elementRef.nativeElement;\n\n      // `touchmove` is active since we need to call `preventDefault`.\n      element.addEventListener('touchmove', this._touchmoveHandler, activeCapturingEventOptions);\n\n      element.addEventListener('mouseenter', this._enterHandler, passiveCapturingEventOptions);\n      element.addEventListener('focus', this._enterHandler, passiveCapturingEventOptions);\n      element.addEventListener('mouseleave', this._leaveHandler, passiveCapturingEventOptions);\n      element.addEventListener('blur', this._leaveHandler, passiveCapturingEventOptions);\n\n      element.addEventListener('mousedown', this._mousedownHandler, passiveEventOptions);\n      element.addEventListener('touchstart', this._mousedownHandler, passiveEventOptions);\n\n      if (this._platform.isBrowser) {\n        window.addEventListener('mouseup', this._mouseupHandler);\n        window.addEventListener('touchend', this._touchendHandler);\n      }\n    });\n  }\n\n  /** Called when a cell is clicked. */\n  _cellClicked(cell: MatCalendarCell, event: MouseEvent): void {\n    // Ignore \"clicks\" that are actually canceled drags (eg the user dragged\n    // off and then went back to this cell to undo).\n    if (this._didDragSinceMouseDown) {\n      return;\n    }\n\n    if (cell.enabled) {\n      this.selectedValueChange.emit({value: cell.value, event});\n    }\n  }\n\n  _emitActiveDateChange(cell: MatCalendarCell, event: FocusEvent): void {\n    if (cell.enabled) {\n      this.activeDateChange.emit({value: cell.value, event});\n    }\n  }\n\n  /** Returns whether a cell should be marked as selected. */\n  _isSelected(value: number) {\n    return this.startValue === value || this.endValue === value;\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    const columnChanges = changes['numCols'];\n    const {rows, numCols} = this;\n\n    if (changes['rows'] || columnChanges) {\n      this._firstRowOffset = rows && rows.length && rows[0].length ? numCols - rows[0].length : 0;\n    }\n\n    if (changes['cellAspectRatio'] || columnChanges || !this._cellPadding) {\n      this._cellPadding = `${(50 * this.cellAspectRatio) / numCols}%`;\n    }\n\n    if (columnChanges || !this._cellWidth) {\n      this._cellWidth = `${100 / numCols}%`;\n    }\n  }\n\n  ngOnDestroy() {\n    const element = this._elementRef.nativeElement;\n\n    element.removeEventListener('touchmove', this._touchmoveHandler, activeCapturingEventOptions);\n\n    element.removeEventListener('mouseenter', this._enterHandler, passiveCapturingEventOptions);\n    element.removeEventListener('focus', this._enterHandler, passiveCapturingEventOptions);\n    element.removeEventListener('mouseleave', this._leaveHandler, passiveCapturingEventOptions);\n    element.removeEventListener('blur', this._leaveHandler, passiveCapturingEventOptions);\n\n    element.removeEventListener('mousedown', this._mousedownHandler, passiveEventOptions);\n    element.removeEventListener('touchstart', this._mousedownHandler, passiveEventOptions);\n\n    if (this._platform.isBrowser) {\n      window.removeEventListener('mouseup', this._mouseupHandler);\n      window.removeEventListener('touchend', this._touchendHandler);\n    }\n  }\n\n  /** Returns whether a cell is active. */\n  _isActiveCell(rowIndex: number, colIndex: number): boolean {\n    let cellNumber = rowIndex * this.numCols + colIndex;\n\n    // Account for the fact that the first row may not have as many cells.\n    if (rowIndex) {\n      cellNumber -= this._firstRowOffset;\n    }\n\n    return cellNumber == this.activeCell;\n  }\n\n  /**\n   * Focuses the active cell after the microtask queue is empty.\n   *\n   * Adding a 0ms setTimeout seems to fix Voiceover losing focus when pressing PageUp/PageDown\n   * (issue #24330).\n   *\n   * Determined a 0ms by gradually increasing duration from 0 and testing two use cases with screen\n   * reader enabled:\n   *\n   * 1. Pressing PageUp/PageDown repeatedly with pausing between each key press.\n   * 2. Pressing and holding the PageDown key with repeated keys enabled.\n   *\n   * Test 1 worked roughly 95-99% of the time with 0ms and got a little bit better as the duration\n   * increased. Test 2 got slightly better until the duration was long enough to interfere with\n   * repeated keys. If the repeated key speed was faster than the timeout duration, then pressing\n   * and holding pagedown caused the entire page to scroll.\n   *\n   * Since repeated key speed can verify across machines, determined that any duration could\n   * potentially interfere with repeated keys. 0ms would be best because it almost entirely\n   * eliminates the focus being lost in Voiceover (#24330) without causing unintended side effects.\n   * Adding delay also complicates writing tests.\n   */\n  _focusActiveCell(movePreview = true) {\n    this._ngZone.runOutsideAngular(() => {\n      this._ngZone.onStable.pipe(take(1)).subscribe(() => {\n        setTimeout(() => {\n          const activeCell: HTMLElement | null = this._elementRef.nativeElement.querySelector(\n            '.mat-calendar-body-active',\n          );\n\n          if (activeCell) {\n            if (!movePreview) {\n              this._skipNextFocus = true;\n            }\n\n            activeCell.focus();\n          }\n        });\n      });\n    });\n  }\n\n  /** Focuses the active cell after change detection has run and the microtask queue is empty. */\n  _scheduleFocusActiveCellAfterViewChecked() {\n    this._focusActiveCellAfterViewChecked = true;\n  }\n\n  /** Gets whether a value is the start of the main range. */\n  _isRangeStart(value: number) {\n    return isStart(value, this.startValue, this.endValue);\n  }\n\n  /** Gets whether a value is the end of the main range. */\n  _isRangeEnd(value: number) {\n    return isEnd(value, this.startValue, this.endValue);\n  }\n\n  /** Gets whether a value is within the currently-selected range. */\n  _isInRange(value: number): boolean {\n    return isInRange(value, this.startValue, this.endValue, this.isRange);\n  }\n\n  /** Gets whether a value is the start of the comparison range. */\n  _isComparisonStart(value: number) {\n    return isStart(value, this.comparisonStart, this.comparisonEnd);\n  }\n\n  /** Whether the cell is a start bridge cell between the main and comparison ranges. */\n  _isComparisonBridgeStart(value: number, rowIndex: number, colIndex: number) {\n    if (!this._isComparisonStart(value) || this._isRangeStart(value) || !this._isInRange(value)) {\n      return false;\n    }\n\n    let previousCell: MatCalendarCell | undefined = this.rows[rowIndex][colIndex - 1];\n\n    if (!previousCell) {\n      const previousRow = this.rows[rowIndex - 1];\n      previousCell = previousRow && previousRow[previousRow.length - 1];\n    }\n\n    return previousCell && !this._isRangeEnd(previousCell.compareValue);\n  }\n\n  /** Whether the cell is an end bridge cell between the main and comparison ranges. */\n  _isComparisonBridgeEnd(value: number, rowIndex: number, colIndex: number) {\n    if (!this._isComparisonEnd(value) || this._isRangeEnd(value) || !this._isInRange(value)) {\n      return false;\n    }\n\n    let nextCell: MatCalendarCell | undefined = this.rows[rowIndex][colIndex + 1];\n\n    if (!nextCell) {\n      const nextRow = this.rows[rowIndex + 1];\n      nextCell = nextRow && nextRow[0];\n    }\n\n    return nextCell && !this._isRangeStart(nextCell.compareValue);\n  }\n\n  /** Gets whether a value is the end of the comparison range. */\n  _isComparisonEnd(value: number) {\n    return isEnd(value, this.comparisonStart, this.comparisonEnd);\n  }\n\n  /** Gets whether a value is within the current comparison range. */\n  _isInComparisonRange(value: number) {\n    return isInRange(value, this.comparisonStart, this.comparisonEnd, this.isRange);\n  }\n\n  /**\n   * Gets whether a value is the same as the start and end of the comparison range.\n   * For context, the functions that we use to determine whether something is the start/end of\n   * a range don't allow for the start and end to be on the same day, because we'd have to use\n   * much more specific CSS selectors to style them correctly in all scenarios. This is fine for\n   * the regular range, because when it happens, the selected styles take over and still show where\n   * the range would've been, however we don't have these selected styles for a comparison range.\n   * This function is used to apply a class that serves the same purpose as the one for selected\n   * dates, but it only applies in the context of a comparison range.\n   */\n  _isComparisonIdentical(value: number) {\n    // Note that we don't need to null check the start/end\n    // here, because the `value` will always be defined.\n    return this.comparisonStart === this.comparisonEnd && value === this.comparisonStart;\n  }\n\n  /** Gets whether a value is the start of the preview range. */\n  _isPreviewStart(value: number) {\n    return isStart(value, this.previewStart, this.previewEnd);\n  }\n\n  /** Gets whether a value is the end of the preview range. */\n  _isPreviewEnd(value: number) {\n    return isEnd(value, this.previewStart, this.previewEnd);\n  }\n\n  /** Gets whether a value is inside the preview range. */\n  _isInPreview(value: number) {\n    return isInRange(value, this.previewStart, this.previewEnd, this.isRange);\n  }\n\n  /** Gets ids of aria descriptions for the start and end of a date range. */\n  _getDescribedby(value: number): string | null {\n    if (!this.isRange) {\n      return null;\n    }\n\n    if (this.startValue === value && this.endValue === value) {\n      return `${this._startDateLabelId} ${this._endDateLabelId}`;\n    } else if (this.startValue === value) {\n      return this._startDateLabelId;\n    } else if (this.endValue === value) {\n      return this._endDateLabelId;\n    }\n    return null;\n  }\n\n  /**\n   * Event handler for when the user enters an element\n   * inside the calendar body (e.g. by hovering in or focus).\n   */\n  private _enterHandler = (event: Event) => {\n    if (this._skipNextFocus && event.type === 'focus') {\n      this._skipNextFocus = false;\n      return;\n    }\n\n    // We only need to hit the zone when we're selecting a range.\n    if (event.target && this.isRange) {\n      const cell = this._getCellFromElement(event.target as HTMLElement);\n\n      if (cell) {\n        this._ngZone.run(() => this.previewChange.emit({value: cell.enabled ? cell : null, event}));\n      }\n    }\n  };\n\n  private _touchmoveHandler = (event: TouchEvent) => {\n    if (!this.isRange) return;\n\n    const target = getActualTouchTarget(event);\n    const cell = target ? this._getCellFromElement(target as HTMLElement) : null;\n\n    if (target !== event.target) {\n      this._didDragSinceMouseDown = true;\n    }\n\n    // If the initial target of the touch is a date cell, prevent default so\n    // that the move is not handled as a scroll.\n    if (getCellElement(event.target as HTMLElement)) {\n      event.preventDefault();\n    }\n\n    this._ngZone.run(() => this.previewChange.emit({value: cell?.enabled ? cell : null, event}));\n  };\n\n  /**\n   * Event handler for when the user's pointer leaves an element\n   * inside the calendar body (e.g. by hovering out or blurring).\n   */\n  private _leaveHandler = (event: Event) => {\n    // We only need to hit the zone when we're selecting a range.\n    if (this.previewEnd !== null && this.isRange) {\n      if (event.type !== 'blur') {\n        this._didDragSinceMouseDown = true;\n      }\n\n      // Only reset the preview end value when leaving cells. This looks better, because\n      // we have a gap between the cells and the rows and we don't want to remove the\n      // range just for it to show up again when the user moves a few pixels to the side.\n      if (\n        event.target &&\n        this._getCellFromElement(event.target as HTMLElement) &&\n        !(\n          (event as MouseEvent).relatedTarget &&\n          this._getCellFromElement((event as MouseEvent).relatedTarget as HTMLElement)\n        )\n      ) {\n        this._ngZone.run(() => this.previewChange.emit({value: null, event}));\n      }\n    }\n  };\n\n  /**\n   * Triggered on mousedown or touchstart on a date cell.\n   * Respsonsible for starting a drag sequence.\n   */\n  private _mousedownHandler = (event: Event) => {\n    if (!this.isRange) return;\n\n    this._didDragSinceMouseDown = false;\n    // Begin a drag if a cell within the current range was targeted.\n    const cell = event.target && this._getCellFromElement(event.target as HTMLElement);\n    if (!cell || !this._isInRange(cell.compareValue)) {\n      return;\n    }\n\n    this._ngZone.run(() => {\n      this.dragStarted.emit({\n        value: cell.rawValue,\n        event,\n      });\n    });\n  };\n\n  /** Triggered on mouseup anywhere. Respsonsible for ending a drag sequence. */\n  private _mouseupHandler = (event: Event) => {\n    if (!this.isRange) return;\n\n    const cellElement = getCellElement(event.target as HTMLElement);\n    if (!cellElement) {\n      // Mouseup happened outside of datepicker. Cancel drag.\n      this._ngZone.run(() => {\n        this.dragEnded.emit({value: null, event});\n      });\n      return;\n    }\n\n    if (cellElement.closest('.mat-calendar-body') !== this._elementRef.nativeElement) {\n      // Mouseup happened inside a different month instance.\n      // Allow it to handle the event.\n      return;\n    }\n\n    this._ngZone.run(() => {\n      const cell = this._getCellFromElement(cellElement);\n      this.dragEnded.emit({value: cell?.rawValue ?? null, event});\n    });\n  };\n\n  /** Triggered on touchend anywhere. Respsonsible for ending a drag sequence. */\n  private _touchendHandler = (event: TouchEvent) => {\n    const target = getActualTouchTarget(event);\n\n    if (target) {\n      this._mouseupHandler({target} as unknown as Event);\n    }\n  };\n\n  /** Finds the MatCalendarCell that corresponds to a DOM node. */\n  private _getCellFromElement(element: HTMLElement): MatCalendarCell | null {\n    const cell = getCellElement(element);\n\n    if (cell) {\n      const row = cell.getAttribute('data-mat-row');\n      const col = cell.getAttribute('data-mat-col');\n\n      if (row && col) {\n        return this.rows[parseInt(row)][parseInt(col)];\n      }\n    }\n\n    return null;\n  }\n\n  private _id = `mat-calendar-body-${calendarBodyId++}`;\n\n  _startDateLabelId = `${this._id}-start-date`;\n\n  _endDateLabelId = `${this._id}-end-date`;\n}\n\n/** Checks whether a node is a table cell element. */\nfunction isTableCell(node: Node | undefined | null): node is HTMLTableCellElement {\n  return node?.nodeName === 'TD';\n}\n\n/**\n * Gets the date table cell element that is or contains the specified element.\n * Or returns null if element is not part of a date cell.\n */\nfunction getCellElement(element: HTMLElement): HTMLElement | null {\n  let cell: HTMLElement | undefined;\n  if (isTableCell(element)) {\n    cell = element;\n  } else if (isTableCell(element.parentNode)) {\n    cell = element.parentNode as HTMLElement;\n  } else if (isTableCell(element.parentNode?.parentNode)) {\n    cell = element.parentNode!.parentNode as HTMLElement;\n  }\n\n  return cell?.getAttribute('data-mat-row') != null ? cell : null;\n}\n\n/** Checks whether a value is the start of a range. */\nfunction isStart(value: number, start: number | null, end: number | null): boolean {\n  return end !== null && start !== end && value < end && value === start;\n}\n\n/** Checks whether a value is the end of a range. */\nfunction isEnd(value: number, start: number | null, end: number | null): boolean {\n  return start !== null && start !== end && value >= start && value === end;\n}\n\n/** Checks whether a value is inside of a range. */\nfunction isInRange(\n  value: number,\n  start: number | null,\n  end: number | null,\n  rangeEnabled: boolean,\n): boolean {\n  return (\n    rangeEnabled &&\n    start !== null &&\n    end !== null &&\n    start !== end &&\n    value >= start &&\n    value <= end\n  );\n}\n\n/**\n * Extracts the element that actually corresponds to a touch event's location\n * (rather than the element that initiated the sequence of touch events).\n */\nfunction getActualTouchTarget(event: TouchEvent): Element | null {\n  const touchLocation = event.changedTouches[0];\n  return document.elementFromPoint(touchLocation.clientX, touchLocation.clientY);\n}\n", "<!--\n  If there's not enough space in the first row, create a separate label row. We mark this row as\n  aria-hidden because we don't want it to be read out as one of the weeks in the month.\n-->\n@if (_firstRowOffset < labelMinRequiredCells) {\n  <tr aria-hidden=\"true\">\n    <td class=\"mat-calendar-body-label\"\n        [attr.colspan]=\"numCols\"\n        [style.paddingTop]=\"_cellPadding\"\n        [style.paddingBottom]=\"_cellPadding\">\n      {{label}}\n    </td>\n  </tr>\n}\n\n<!-- Create the first row separately so we can include a special spacer cell. -->\n@for (row of rows; track row; let rowIndex = $index) {\n  <tr role=\"row\">\n    <!--\n      This cell is purely decorative, but we can't put `aria-hidden` or `role=\"presentation\"` on it,\n      because it throws off the week days for the rest of the row on NVDA. The aspect ratio of the\n      table cells is maintained by setting the top and bottom padding as a percentage of the width\n      (a variant of the trick described here: https://www.w3schools.com/howto/howto_css_aspect_ratio.asp).\n    -->\n    @if (rowIndex === 0 && _firstRowOffset) {\n      <td\n        class=\"mat-calendar-body-label\"\n        [attr.colspan]=\"_firstRowOffset\"\n        [style.paddingTop]=\"_cellPadding\"\n        [style.paddingBottom]=\"_cellPadding\">\n        {{_firstRowOffset >= labelMinRequiredCells ? label : ''}}\n      </td>\n    }\n    <!--\n      Each gridcell in the calendar contains a button, which signals to assistive technology that the\n      cell is interactable, as well as the selection state via `aria-pressed`. See #23476 for\n      background.\n    -->\n    @for (item of row; track item; let colIndex = $index) {\n      <td\n        role=\"gridcell\"\n        class=\"mat-calendar-body-cell-container\"\n        [style.width]=\"_cellWidth\"\n        [style.paddingTop]=\"_cellPadding\"\n        [style.paddingBottom]=\"_cellPadding\"\n        [attr.data-mat-row]=\"rowIndex\"\n        [attr.data-mat-col]=\"colIndex\"\n      >\n        <button\n            type=\"button\"\n            class=\"mat-calendar-body-cell\"\n            [ngClass]=\"item.cssClasses\"\n            [tabindex]=\"_isActiveCell(rowIndex, colIndex) ? 0 : -1\"\n            [class.mat-calendar-body-disabled]=\"!item.enabled\"\n            [class.mat-calendar-body-active]=\"_isActiveCell(rowIndex, colIndex)\"\n            [class.mat-calendar-body-range-start]=\"_isRangeStart(item.compareValue)\"\n            [class.mat-calendar-body-range-end]=\"_isRangeEnd(item.compareValue)\"\n            [class.mat-calendar-body-in-range]=\"_isInRange(item.compareValue)\"\n            [class.mat-calendar-body-comparison-bridge-start]=\"_isComparisonBridgeStart(item.compareValue, rowIndex, colIndex)\"\n            [class.mat-calendar-body-comparison-bridge-end]=\"_isComparisonBridgeEnd(item.compareValue, rowIndex, colIndex)\"\n            [class.mat-calendar-body-comparison-start]=\"_isComparisonStart(item.compareValue)\"\n            [class.mat-calendar-body-comparison-end]=\"_isComparisonEnd(item.compareValue)\"\n            [class.mat-calendar-body-in-comparison-range]=\"_isInComparisonRange(item.compareValue)\"\n            [class.mat-calendar-body-preview-start]=\"_isPreviewStart(item.compareValue)\"\n            [class.mat-calendar-body-preview-end]=\"_isPreviewEnd(item.compareValue)\"\n            [class.mat-calendar-body-in-preview]=\"_isInPreview(item.compareValue)\"\n            [attr.aria-label]=\"item.ariaLabel\"\n            [attr.aria-disabled]=\"!item.enabled || null\"\n            [attr.aria-pressed]=\"_isSelected(item.compareValue)\"\n            [attr.aria-current]=\"todayValue === item.compareValue ? 'date' : null\"\n            [attr.aria-describedby]=\"_getDescribedby(item.compareValue)\"\n            (click)=\"_cellClicked(item, $event)\"\n            (focus)=\"_emitActiveDateChange(item, $event)\">\n            <span class=\"mat-calendar-body-cell-content mat-focus-indicator\"\n              [class.mat-calendar-body-selected]=\"_isSelected(item.compareValue)\"\n              [class.mat-calendar-body-comparison-identical]=\"_isComparisonIdentical(item.compareValue)\"\n              [class.mat-calendar-body-today]=\"todayValue === item.compareValue\">\n              {{item.displayValue}}\n            </span>\n            <span class=\"mat-calendar-body-cell-preview\" aria-hidden=\"true\"></span>\n        </button>\n      </td>\n    }\n  </tr>\n}\n\n<label [id]=\"_startDateLabelId\" class=\"mat-calendar-body-hidden-label\">\n  {{startDateAccessibleName}}\n</label>\n<label [id]=\"_endDateLabelId\" class=\"mat-calendar-body-hidden-label\">\n  {{endDateAccessibleName}}\n</label>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {FactoryProvider, Injectable, Optional, SkipSelf, OnDestroy} from '@angular/core';\nimport {DateAdapter} from '@angular/material/core';\nimport {Observable, Subject} from 'rxjs';\n\n/** A class representing a range of dates. */\nexport class DateRange<D> {\n  /**\n   * Ensures that objects with a `start` and `end` property can't be assigned to a variable that\n   * expects a `DateRange`\n   */\n  // tslint:disable-next-line:no-unused-variable\n  private _disableStructuralEquivalency: never;\n\n  constructor(\n    /** The start date of the range. */\n    readonly start: D | null,\n    /** The end date of the range. */\n    readonly end: D | null,\n  ) {}\n}\n\n/**\n * Conditionally picks the date type, if a DateRange is passed in.\n * @docs-private\n */\nexport type ExtractDateTypeFromSelection<T> = T extends DateRange<infer D> ? D : NonNullable<T>;\n\n/**\n * Event emitted by the date selection model when its selection changes.\n * @docs-private\n */\nexport interface DateSelectionModelChange<S> {\n  /** New value for the selection. */\n  selection: S;\n\n  /** Object that triggered the change. */\n  source: unknown;\n\n  /** Previous value */\n  oldValue?: S;\n}\n\n/**\n * A selection model containing a date selection.\n * @docs-private\n */\n@Injectable()\nexport abstract class MatDateSelectionModel<S, D = ExtractDateTypeFromSelection<S>>\n  implements OnDestroy\n{\n  private readonly _selectionChanged = new Subject<DateSelectionModelChange<S>>();\n\n  /** Emits when the selection has changed. */\n  selectionChanged: Observable<DateSelectionModelChange<S>> = this._selectionChanged;\n\n  protected constructor(\n    /** The current selection. */\n    readonly selection: S,\n    protected _adapter: DateAdapter<D>,\n  ) {\n    this.selection = selection;\n  }\n\n  /**\n   * Updates the current selection in the model.\n   * @param value New selection that should be assigned.\n   * @param source Object that triggered the selection change.\n   */\n  updateSelection(value: S, source: unknown) {\n    const oldValue = (this as {selection: S}).selection;\n    (this as {selection: S}).selection = value;\n    this._selectionChanged.next({selection: value, source, oldValue});\n  }\n\n  ngOnDestroy() {\n    this._selectionChanged.complete();\n  }\n\n  protected _isValidDateInstance(date: D): boolean {\n    return this._adapter.isDateInstance(date) && this._adapter.isValid(date);\n  }\n\n  /** Adds a date to the current selection. */\n  abstract add(date: D | null): void;\n\n  /** Checks whether the current selection is valid. */\n  abstract isValid(): boolean;\n\n  /** Checks whether the current selection is complete. */\n  abstract isComplete(): boolean;\n\n  /** Clones the selection model. */\n  abstract clone(): MatDateSelectionModel<S, D>;\n}\n\n/**\n * A selection model that contains a single date.\n * @docs-private\n */\n@Injectable()\nexport class MatSingleDateSelectionModel<D> extends MatDateSelectionModel<D | null, D> {\n  constructor(adapter: DateAdapter<D>) {\n    super(null, adapter);\n  }\n\n  /**\n   * Adds a date to the current selection. In the case of a single date selection, the added date\n   * simply overwrites the previous selection\n   */\n  add(date: D | null) {\n    super.updateSelection(date, this);\n  }\n\n  /** Checks whether the current selection is valid. */\n  isValid(): boolean {\n    return this.selection != null && this._isValidDateInstance(this.selection);\n  }\n\n  /**\n   * Checks whether the current selection is complete. In the case of a single date selection, this\n   * is true if the current selection is not null.\n   */\n  isComplete() {\n    return this.selection != null;\n  }\n\n  /** Clones the selection model. */\n  clone() {\n    const clone = new MatSingleDateSelectionModel<D>(this._adapter);\n    clone.updateSelection(this.selection, this);\n    return clone;\n  }\n}\n\n/**\n * A selection model that contains a date range.\n * @docs-private\n */\n@Injectable()\nexport class MatRangeDateSelectionModel<D> extends MatDateSelectionModel<DateRange<D>, D> {\n  constructor(adapter: DateAdapter<D>) {\n    super(new DateRange<D>(null, null), adapter);\n  }\n\n  /**\n   * Adds a date to the current selection. In the case of a date range selection, the added date\n   * fills in the next `null` value in the range. If both the start and the end already have a date,\n   * the selection is reset so that the given date is the new `start` and the `end` is null.\n   */\n  add(date: D | null): void {\n    let {start, end} = this.selection;\n\n    if (start == null) {\n      start = date;\n    } else if (end == null) {\n      end = date;\n    } else {\n      start = date;\n      end = null;\n    }\n\n    super.updateSelection(new DateRange<D>(start, end), this);\n  }\n\n  /** Checks whether the current selection is valid. */\n  isValid(): boolean {\n    const {start, end} = this.selection;\n\n    // Empty ranges are valid.\n    if (start == null && end == null) {\n      return true;\n    }\n\n    // Complete ranges are only valid if both dates are valid and the start is before the end.\n    if (start != null && end != null) {\n      return (\n        this._isValidDateInstance(start) &&\n        this._isValidDateInstance(end) &&\n        this._adapter.compareDate(start, end) <= 0\n      );\n    }\n\n    // Partial ranges are valid if the start/end is valid.\n    return (\n      (start == null || this._isValidDateInstance(start)) &&\n      (end == null || this._isValidDateInstance(end))\n    );\n  }\n\n  /**\n   * Checks whether the current selection is complete. In the case of a date range selection, this\n   * is true if the current selection has a non-null `start` and `end`.\n   */\n  isComplete(): boolean {\n    return this.selection.start != null && this.selection.end != null;\n  }\n\n  /** Clones the selection model. */\n  clone() {\n    const clone = new MatRangeDateSelectionModel<D>(this._adapter);\n    clone.updateSelection(this.selection, this);\n    return clone;\n  }\n}\n\n/** @docs-private */\nexport function MAT_SINGLE_DATE_SELECTION_MODEL_FACTORY(\n  parent: MatSingleDateSelectionModel<unknown>,\n  adapter: DateAdapter<unknown>,\n) {\n  return parent || new MatSingleDateSelectionModel(adapter);\n}\n\n/**\n * Used to provide a single selection model to a component.\n * @docs-private\n */\nexport const MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER: FactoryProvider = {\n  provide: MatDateSelectionModel,\n  deps: [[new Optional(), new SkipSelf(), MatDateSelectionModel], DateAdapter],\n  useFactory: MAT_SINGLE_DATE_SELECTION_MODEL_FACTORY,\n};\n\n/** @docs-private */\nexport function MAT_RANGE_DATE_SELECTION_MODEL_FACTORY(\n  parent: MatSingleDateSelectionModel<unknown>,\n  adapter: DateAdapter<unknown>,\n) {\n  return parent || new MatRangeDateSelectionModel(adapter);\n}\n\n/**\n * Used to provide a range selection model to a component.\n * @docs-private\n */\nexport const MAT_RANGE_DATE_SELECTION_MODEL_PROVIDER: FactoryProvider = {\n  provide: MatDateSelectionModel,\n  deps: [[new Optional(), new SkipSelf(), MatDateSelectionModel], DateAdapter],\n  useFactory: MAT_RANGE_DATE_SELECTION_MODEL_FACTORY,\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, InjectionToken, Optional, SkipSelf, FactoryProvider} from '@angular/core';\nimport {DateAdapter} from '@angular/material/core';\nimport {DateRange} from './date-selection-model';\n\n/** Injection token used to customize the date range selection behavior. */\nexport const MAT_DATE_RANGE_SELECTION_STRATEGY = new InjectionToken<\n  MatDateRangeSelectionStrategy<any>\n>('MAT_DATE_RANGE_SELECTION_STRATEGY');\n\n/** Object that can be provided in order to customize the date range selection behavior. */\nexport interface MatDateRangeSelectionStrategy<D> {\n  /**\n   * Called when the user has finished selecting a value.\n   * @param date Date that was selected. Will be null if the user cleared the selection.\n   * @param currentRange Range that is currently show in the calendar.\n   * @param event DOM event that triggered the selection. Currently only corresponds to a `click`\n   *    event, but it may get expanded in the future.\n   */\n  selectionFinished(date: D | null, currentRange: DateRange<D>, event: Event): DateRange<D>;\n\n  /**\n   * Called when the user has activated a new date (e.g. by hovering over\n   * it or moving focus) and the calendar tries to display a date range.\n   *\n   * @param activeDate Date that the user has activated. Will be null if the user moved\n   *    focus to an element that's no a calendar cell.\n   * @param currentRange Range that is currently shown in the calendar.\n   * @param event DOM event that caused the preview to be changed. Will be either a\n   *    `mouseenter`/`mouseleave` or `focus`/`blur` depending on how the user is navigating.\n   */\n  createPreview(activeDate: D | null, currentRange: DateRange<D>, event: Event): DateRange<D>;\n\n  /**\n   * Called when the user has dragged a date in the currently selected range to another\n   * date. Returns the date updated range that should result from this interaction.\n   *\n   * @param dateOrigin The date the user started dragging from.\n   * @param originalRange The originally selected date range.\n   * @param newDate The currently targeted date in the drag operation.\n   * @param event DOM event that triggered the updated drag state. Will be\n   *     `mouseenter`/`mouseup` or `touchmove`/`touchend` depending on the device type.\n   */\n  createDrag?(\n    dragOrigin: D,\n    originalRange: DateRange<D>,\n    newDate: D,\n    event: Event,\n  ): DateRange<D> | null;\n}\n\n/** Provides the default date range selection behavior. */\n@Injectable()\nexport class DefaultMatCalendarRangeStrategy<D> implements MatDateRangeSelectionStrategy<D> {\n  constructor(private _dateAdapter: DateAdapter<D>) {}\n\n  selectionFinished(date: D, currentRange: DateRange<D>) {\n    let {start, end} = currentRange;\n\n    if (start == null) {\n      start = date;\n    } else if (end == null && date && this._dateAdapter.compareDate(date, start) >= 0) {\n      end = date;\n    } else {\n      start = date;\n      end = null;\n    }\n\n    return new DateRange<D>(start, end);\n  }\n\n  createPreview(activeDate: D | null, currentRange: DateRange<D>) {\n    let start: D | null = null;\n    let end: D | null = null;\n\n    if (currentRange.start && !currentRange.end && activeDate) {\n      start = currentRange.start;\n      end = activeDate;\n    }\n\n    return new DateRange<D>(start, end);\n  }\n\n  createDrag(dragOrigin: D, originalRange: DateRange<D>, newDate: D) {\n    let start = originalRange.start;\n    let end = originalRange.end;\n\n    if (!start || !end) {\n      // Can't drag from an incomplete range.\n      return null;\n    }\n\n    const adapter = this._dateAdapter;\n\n    const isRange = adapter.compareDate(start, end) !== 0;\n    const diffYears = adapter.getYear(newDate) - adapter.getYear(dragOrigin);\n    const diffMonths = adapter.getMonth(newDate) - adapter.getMonth(dragOrigin);\n    const diffDays = adapter.getDate(newDate) - adapter.getDate(dragOrigin);\n\n    if (isRange && adapter.sameDate(dragOrigin, originalRange.start)) {\n      start = newDate;\n      if (adapter.compareDate(newDate, end) > 0) {\n        end = adapter.addCalendarYears(end, diffYears);\n        end = adapter.addCalendarMonths(end, diffMonths);\n        end = adapter.addCalendarDays(end, diffDays);\n      }\n    } else if (isRange && adapter.sameDate(dragOrigin, originalRange.end)) {\n      end = newDate;\n      if (adapter.compareDate(newDate, start) < 0) {\n        start = adapter.addCalendarYears(start, diffYears);\n        start = adapter.addCalendarMonths(start, diffMonths);\n        start = adapter.addCalendarDays(start, diffDays);\n      }\n    } else {\n      start = adapter.addCalendarYears(start, diffYears);\n      start = adapter.addCalendarMonths(start, diffMonths);\n      start = adapter.addCalendarDays(start, diffDays);\n      end = adapter.addCalendarYears(end, diffYears);\n      end = adapter.addCalendarMonths(end, diffMonths);\n      end = adapter.addCalendarDays(end, diffDays);\n    }\n\n    return new DateRange<D>(start, end);\n  }\n}\n\n/** @docs-private */\nexport function MAT_CALENDAR_RANGE_STRATEGY_PROVIDER_FACTORY(\n  parent: MatDateRangeSelectionStrategy<unknown>,\n  adapter: DateAdapter<unknown>,\n) {\n  return parent || new DefaultMatCalendarRangeStrategy(adapter);\n}\n\n/** @docs-private */\nexport const MAT_CALENDAR_RANGE_STRATEGY_PROVIDER: FactoryProvider = {\n  provide: MAT_DATE_RANGE_SELECTION_STRATEGY,\n  deps: [[new Optional(), new SkipSelf(), MAT_DATE_RANGE_SELECTION_STRATEGY], DateAdapter],\n  useFactory: MAT_CALENDAR_RANGE_STRATEGY_PROVIDER_FACTORY,\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  DOWN_ARROW,\n  END,\n  ENTER,\n  HOME,\n  LEFT_ARROW,\n  PAGE_DOWN,\n  PAGE_UP,\n  RIGHT_ARROW,\n  UP_ARROW,\n  SPACE,\n  ESCAPE,\n  hasModifierKey,\n} from '@angular/cdk/keycodes';\nimport {\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  EventEmitter,\n  Inject,\n  Input,\n  Optional,\n  Output,\n  ViewEncapsulation,\n  ViewChild,\n  OnDestroy,\n  SimpleChanges,\n  OnChanges,\n} from '@angular/core';\nimport {DateAdapter, MAT_DATE_FORMATS, MatDateFormats} from '@angular/material/core';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {\n  MatCalendarBody,\n  MatCalendarCell,\n  MatCalendarUserEvent,\n  MatCalendarCellClassFunction,\n} from './calendar-body';\nimport {createMissingDateImplError} from './datepicker-errors';\nimport {Subscription} from 'rxjs';\nimport {startWith} from 'rxjs/operators';\nimport {DateRange} from './date-selection-model';\nimport {\n  MatDateRangeSelectionStrategy,\n  MAT_DATE_RANGE_SELECTION_STRATEGY,\n} from './date-range-selection-strategy';\n\nconst DAYS_PER_WEEK = 7;\n\n/**\n * An internal component used to display a single month in the datepicker.\n * @docs-private\n */\n@Component({\n  selector: 'mat-month-view',\n  templateUrl: 'month-view.html',\n  exportAs: 'matMonthView',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatMonthView<D> implements AfterContentInit, OnChanges, OnDestroy {\n  private _rerenderSubscription = Subscription.EMPTY;\n\n  /** Flag used to filter out space/enter keyup events that originated outside of the view. */\n  private _selectionKeyPressed: boolean;\n\n  /**\n   * The date to display in this month view (everything other than the month and year is ignored).\n   */\n  @Input()\n  get activeDate(): D {\n    return this._activeDate;\n  }\n  set activeDate(value: D) {\n    const oldActiveDate = this._activeDate;\n    const validDate =\n      this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value)) ||\n      this._dateAdapter.today();\n    this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n    if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {\n      this._init();\n    }\n  }\n  private _activeDate: D;\n\n  /** The currently selected date. */\n  @Input()\n  get selected(): DateRange<D> | D | null {\n    return this._selected;\n  }\n  set selected(value: DateRange<D> | D | null) {\n    if (value instanceof DateRange) {\n      this._selected = value;\n    } else {\n      this._selected = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n\n    this._setRanges(this._selected);\n  }\n  private _selected: DateRange<D> | D | null;\n\n  /** The minimum selectable date. */\n  @Input()\n  get minDate(): D | null {\n    return this._minDate;\n  }\n  set minDate(value: D | null) {\n    this._minDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n  }\n  private _minDate: D | null;\n\n  /** The maximum selectable date. */\n  @Input()\n  get maxDate(): D | null {\n    return this._maxDate;\n  }\n  set maxDate(value: D | null) {\n    this._maxDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n  }\n  private _maxDate: D | null;\n\n  /** Function used to filter which dates are selectable. */\n  @Input() dateFilter: (date: D) => boolean;\n\n  /** Function that can be used to add custom CSS classes to dates. */\n  @Input() dateClass: MatCalendarCellClassFunction<D>;\n\n  /** Start of the comparison range. */\n  @Input() comparisonStart: D | null;\n\n  /** End of the comparison range. */\n  @Input() comparisonEnd: D | null;\n\n  /** ARIA Accessible name of the `<input matStartDate/>` */\n  @Input() startDateAccessibleName: string | null;\n\n  /** ARIA Accessible name of the `<input matEndDate/>` */\n  @Input() endDateAccessibleName: string | null;\n\n  /** Origin of active drag, or null when dragging is not active. */\n  @Input() activeDrag: MatCalendarUserEvent<D> | null = null;\n\n  /** Emits when a new date is selected. */\n  @Output() readonly selectedChange: EventEmitter<D | null> = new EventEmitter<D | null>();\n\n  /** Emits when any date is selected. */\n  @Output() readonly _userSelection: EventEmitter<MatCalendarUserEvent<D | null>> =\n    new EventEmitter<MatCalendarUserEvent<D | null>>();\n\n  /** Emits when the user initiates a date range drag via mouse or touch. */\n  @Output() readonly dragStarted = new EventEmitter<MatCalendarUserEvent<D>>();\n\n  /**\n   * Emits when the user completes or cancels a date range drag.\n   * Emits null when the drag was canceled or the newly selected date range if completed.\n   */\n  @Output() readonly dragEnded = new EventEmitter<MatCalendarUserEvent<DateRange<D> | null>>();\n\n  /** Emits when any date is activated. */\n  @Output() readonly activeDateChange: EventEmitter<D> = new EventEmitter<D>();\n\n  /** The body of calendar table */\n  @ViewChild(MatCalendarBody) _matCalendarBody: MatCalendarBody;\n\n  /** The label for this month (e.g. \"January 2017\"). */\n  _monthLabel: string;\n\n  /** Grid of calendar cells representing the dates of the month. */\n  _weeks: MatCalendarCell[][];\n\n  /** The number of blank cells in the first row before the 1st of the month. */\n  _firstWeekOffset: number;\n\n  /** Start value of the currently-shown date range. */\n  _rangeStart: number | null;\n\n  /** End value of the currently-shown date range. */\n  _rangeEnd: number | null;\n\n  /** Start value of the currently-shown comparison date range. */\n  _comparisonRangeStart: number | null;\n\n  /** End value of the currently-shown comparison date range. */\n  _comparisonRangeEnd: number | null;\n\n  /** Start of the preview range. */\n  _previewStart: number | null;\n\n  /** End of the preview range. */\n  _previewEnd: number | null;\n\n  /** Whether the user is currently selecting a range of dates. */\n  _isRange: boolean;\n\n  /** The date of the month that today falls on. Null if today is in another month. */\n  _todayDate: number | null;\n\n  /** The names of the weekdays. */\n  _weekdays: {long: string; narrow: string}[];\n\n  constructor(\n    readonly _changeDetectorRef: ChangeDetectorRef,\n    @Optional() @Inject(MAT_DATE_FORMATS) private _dateFormats: MatDateFormats,\n    @Optional() public _dateAdapter: DateAdapter<D>,\n    @Optional() private _dir?: Directionality,\n    @Inject(MAT_DATE_RANGE_SELECTION_STRATEGY)\n    @Optional()\n    private _rangeStrategy?: MatDateRangeSelectionStrategy<D>,\n  ) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n      if (!this._dateFormats) {\n        throw createMissingDateImplError('MAT_DATE_FORMATS');\n      }\n    }\n\n    this._activeDate = this._dateAdapter.today();\n  }\n\n  ngAfterContentInit() {\n    this._rerenderSubscription = this._dateAdapter.localeChanges\n      .pipe(startWith(null))\n      .subscribe(() => this._init());\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    const comparisonChange = changes['comparisonStart'] || changes['comparisonEnd'];\n\n    if (comparisonChange && !comparisonChange.firstChange) {\n      this._setRanges(this.selected);\n    }\n\n    if (changes['activeDrag'] && !this.activeDrag) {\n      this._clearPreview();\n    }\n  }\n\n  ngOnDestroy() {\n    this._rerenderSubscription.unsubscribe();\n  }\n\n  /** Handles when a new date is selected. */\n  _dateSelected(event: MatCalendarUserEvent<number>) {\n    const date = event.value;\n    const selectedDate = this._getDateFromDayOfMonth(date);\n    let rangeStartDate: number | null;\n    let rangeEndDate: number | null;\n\n    if (this._selected instanceof DateRange) {\n      rangeStartDate = this._getDateInCurrentMonth(this._selected.start);\n      rangeEndDate = this._getDateInCurrentMonth(this._selected.end);\n    } else {\n      rangeStartDate = rangeEndDate = this._getDateInCurrentMonth(this._selected);\n    }\n\n    if (rangeStartDate !== date || rangeEndDate !== date) {\n      this.selectedChange.emit(selectedDate);\n    }\n\n    this._userSelection.emit({value: selectedDate, event: event.event});\n    this._clearPreview();\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Takes the index of a calendar body cell wrapped in an event as argument. For the date that\n   * corresponds to the given cell, set `activeDate` to that date and fire `activeDateChange` with\n   * that date.\n   *\n   * This function is used to match each component's model of the active date with the calendar\n   * body cell that was focused. It updates its value of `activeDate` synchronously and updates the\n   * parent's value asynchronously via the `activeDateChange` event. The child component receives an\n   * updated value asynchronously via the `activeCell` Input.\n   */\n  _updateActiveDate(event: MatCalendarUserEvent<number>) {\n    const month = event.value;\n    const oldActiveDate = this._activeDate;\n    this.activeDate = this._getDateFromDayOfMonth(month);\n\n    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n      this.activeDateChange.emit(this._activeDate);\n    }\n  }\n\n  /** Handles keydown events on the calendar body when calendar is in month view. */\n  _handleCalendarBodyKeydown(event: KeyboardEvent): void {\n    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\n    // disabled ones from being selected. This may not be ideal, we should look into whether\n    // navigation should skip over disabled dates, and if so, how to implement that efficiently.\n\n    const oldActiveDate = this._activeDate;\n    const isRtl = this._isRtl();\n\n    switch (event.keyCode) {\n      case LEFT_ARROW:\n        this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? 1 : -1);\n        break;\n      case RIGHT_ARROW:\n        this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? -1 : 1);\n        break;\n      case UP_ARROW:\n        this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);\n        break;\n      case DOWN_ARROW:\n        this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);\n        break;\n      case HOME:\n        this.activeDate = this._dateAdapter.addCalendarDays(\n          this._activeDate,\n          1 - this._dateAdapter.getDate(this._activeDate),\n        );\n        break;\n      case END:\n        this.activeDate = this._dateAdapter.addCalendarDays(\n          this._activeDate,\n          this._dateAdapter.getNumDaysInMonth(this._activeDate) -\n            this._dateAdapter.getDate(this._activeDate),\n        );\n        break;\n      case PAGE_UP:\n        this.activeDate = event.altKey\n          ? this._dateAdapter.addCalendarYears(this._activeDate, -1)\n          : this._dateAdapter.addCalendarMonths(this._activeDate, -1);\n        break;\n      case PAGE_DOWN:\n        this.activeDate = event.altKey\n          ? this._dateAdapter.addCalendarYears(this._activeDate, 1)\n          : this._dateAdapter.addCalendarMonths(this._activeDate, 1);\n        break;\n      case ENTER:\n      case SPACE:\n        this._selectionKeyPressed = true;\n\n        if (this._canSelect(this._activeDate)) {\n          // Prevent unexpected default actions such as form submission.\n          // Note that we only prevent the default action here while the selection happens in\n          // `keyup` below. We can't do the selection here, because it can cause the calendar to\n          // reopen if focus is restored immediately. We also can't call `preventDefault` on `keyup`\n          // because it's too late (see #23305).\n          event.preventDefault();\n        }\n        return;\n      case ESCAPE:\n        // Abort the current range selection if the user presses escape mid-selection.\n        if (this._previewEnd != null && !hasModifierKey(event)) {\n          this._clearPreview();\n          // If a drag is in progress, cancel the drag without changing the\n          // current selection.\n          if (this.activeDrag) {\n            this.dragEnded.emit({value: null, event});\n          } else {\n            this.selectedChange.emit(null);\n            this._userSelection.emit({value: null, event});\n          }\n          event.preventDefault();\n          event.stopPropagation(); // Prevents the overlay from closing.\n        }\n        return;\n      default:\n        // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n        return;\n    }\n\n    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n      this.activeDateChange.emit(this.activeDate);\n\n      this._focusActiveCellAfterViewChecked();\n    }\n\n    // Prevent unexpected default actions such as form submission.\n    event.preventDefault();\n  }\n\n  /** Handles keyup events on the calendar body when calendar is in month view. */\n  _handleCalendarBodyKeyup(event: KeyboardEvent): void {\n    if (event.keyCode === SPACE || event.keyCode === ENTER) {\n      if (this._selectionKeyPressed && this._canSelect(this._activeDate)) {\n        this._dateSelected({value: this._dateAdapter.getDate(this._activeDate), event});\n      }\n\n      this._selectionKeyPressed = false;\n    }\n  }\n\n  /** Initializes this month view. */\n  _init() {\n    this._setRanges(this.selected);\n    this._todayDate = this._getCellCompareValue(this._dateAdapter.today());\n    this._monthLabel = this._dateFormats.display.monthLabel\n      ? this._dateAdapter.format(this.activeDate, this._dateFormats.display.monthLabel)\n      : this._dateAdapter\n          .getMonthNames('short')\n          [this._dateAdapter.getMonth(this.activeDate)].toLocaleUpperCase();\n\n    let firstOfMonth = this._dateAdapter.createDate(\n      this._dateAdapter.getYear(this.activeDate),\n      this._dateAdapter.getMonth(this.activeDate),\n      1,\n    );\n    this._firstWeekOffset =\n      (DAYS_PER_WEEK +\n        this._dateAdapter.getDayOfWeek(firstOfMonth) -\n        this._dateAdapter.getFirstDayOfWeek()) %\n      DAYS_PER_WEEK;\n\n    this._initWeekdays();\n    this._createWeekCells();\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /** Focuses the active cell after the microtask queue is empty. */\n  _focusActiveCell(movePreview?: boolean) {\n    this._matCalendarBody._focusActiveCell(movePreview);\n  }\n\n  /** Focuses the active cell after change detection has run and the microtask queue is empty. */\n  _focusActiveCellAfterViewChecked() {\n    this._matCalendarBody._scheduleFocusActiveCellAfterViewChecked();\n  }\n\n  /** Called when the user has activated a new cell and the preview needs to be updated. */\n  _previewChanged({event, value: cell}: MatCalendarUserEvent<MatCalendarCell<D> | null>) {\n    if (this._rangeStrategy) {\n      // We can assume that this will be a range, because preview\n      // events aren't fired for single date selections.\n      const value = cell ? cell.rawValue! : null;\n      const previewRange = this._rangeStrategy.createPreview(\n        value,\n        this.selected as DateRange<D>,\n        event,\n      );\n      this._previewStart = this._getCellCompareValue(previewRange.start);\n      this._previewEnd = this._getCellCompareValue(previewRange.end);\n\n      if (this.activeDrag && value) {\n        const dragRange = this._rangeStrategy.createDrag?.(\n          this.activeDrag.value,\n          this.selected as DateRange<D>,\n          value,\n          event,\n        );\n\n        if (dragRange) {\n          this._previewStart = this._getCellCompareValue(dragRange.start);\n          this._previewEnd = this._getCellCompareValue(dragRange.end);\n        }\n      }\n\n      // Note that here we need to use `detectChanges`, rather than `markForCheck`, because\n      // the way `_focusActiveCell` is set up at the moment makes it fire at the wrong time\n      // when navigating one month back using the keyboard which will cause this handler\n      // to throw a \"changed after checked\" error when updating the preview state.\n      this._changeDetectorRef.detectChanges();\n    }\n  }\n\n  /**\n   * Called when the user has ended a drag. If the drag/drop was successful,\n   * computes and emits the new range selection.\n   */\n  protected _dragEnded(event: MatCalendarUserEvent<D | null>) {\n    if (!this.activeDrag) return;\n\n    if (event.value) {\n      // Propagate drag effect\n      const dragDropResult = this._rangeStrategy?.createDrag?.(\n        this.activeDrag.value,\n        this.selected as DateRange<D>,\n        event.value,\n        event.event,\n      );\n\n      this.dragEnded.emit({value: dragDropResult ?? null, event: event.event});\n    } else {\n      this.dragEnded.emit({value: null, event: event.event});\n    }\n  }\n\n  /**\n   * Takes a day of the month and returns a new date in the same month and year as the currently\n   *  active date. The returned date will have the same day of the month as the argument date.\n   */\n  private _getDateFromDayOfMonth(dayOfMonth: number): D {\n    return this._dateAdapter.createDate(\n      this._dateAdapter.getYear(this.activeDate),\n      this._dateAdapter.getMonth(this.activeDate),\n      dayOfMonth,\n    );\n  }\n\n  /** Initializes the weekdays. */\n  private _initWeekdays() {\n    const firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();\n    const narrowWeekdays = this._dateAdapter.getDayOfWeekNames('narrow');\n    const longWeekdays = this._dateAdapter.getDayOfWeekNames('long');\n\n    // Rotate the labels for days of the week based on the configured first day of the week.\n    let weekdays = longWeekdays.map((long, i) => {\n      return {long, narrow: narrowWeekdays[i]};\n    });\n    this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));\n  }\n\n  /** Creates MatCalendarCells for the dates in this month. */\n  private _createWeekCells() {\n    const daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);\n    const dateNames = this._dateAdapter.getDateNames();\n    this._weeks = [[]];\n    for (let i = 0, cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {\n      if (cell == DAYS_PER_WEEK) {\n        this._weeks.push([]);\n        cell = 0;\n      }\n      const date = this._dateAdapter.createDate(\n        this._dateAdapter.getYear(this.activeDate),\n        this._dateAdapter.getMonth(this.activeDate),\n        i + 1,\n      );\n      const enabled = this._shouldEnableDate(date);\n      const ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);\n      const cellClasses = this.dateClass ? this.dateClass(date, 'month') : undefined;\n\n      this._weeks[this._weeks.length - 1].push(\n        new MatCalendarCell<D>(\n          i + 1,\n          dateNames[i],\n          ariaLabel,\n          enabled,\n          cellClasses,\n          this._getCellCompareValue(date)!,\n          date,\n        ),\n      );\n    }\n  }\n\n  /** Date filter for the month */\n  private _shouldEnableDate(date: D): boolean {\n    return (\n      !!date &&\n      (!this.minDate || this._dateAdapter.compareDate(date, this.minDate) >= 0) &&\n      (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate) <= 0) &&\n      (!this.dateFilter || this.dateFilter(date))\n    );\n  }\n\n  /**\n   * Gets the date in this month that the given Date falls on.\n   * Returns null if the given Date is in another month.\n   */\n  private _getDateInCurrentMonth(date: D | null): number | null {\n    return date && this._hasSameMonthAndYear(date, this.activeDate)\n      ? this._dateAdapter.getDate(date)\n      : null;\n  }\n\n  /** Checks whether the 2 dates are non-null and fall within the same month of the same year. */\n  private _hasSameMonthAndYear(d1: D | null, d2: D | null): boolean {\n    return !!(\n      d1 &&\n      d2 &&\n      this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) &&\n      this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2)\n    );\n  }\n\n  /** Gets the value that will be used to one cell to another. */\n  private _getCellCompareValue(date: D | null): number | null {\n    if (date) {\n      // We use the time since the Unix epoch to compare dates in this view, rather than the\n      // cell values, because we need to support ranges that span across multiple months/years.\n      const year = this._dateAdapter.getYear(date);\n      const month = this._dateAdapter.getMonth(date);\n      const day = this._dateAdapter.getDate(date);\n      return new Date(year, month, day).getTime();\n    }\n\n    return null;\n  }\n\n  /** Determines whether the user has the RTL layout direction. */\n  private _isRtl() {\n    return this._dir && this._dir.value === 'rtl';\n  }\n\n  /** Sets the current range based on a model value. */\n  private _setRanges(selectedValue: DateRange<D> | D | null) {\n    if (selectedValue instanceof DateRange) {\n      this._rangeStart = this._getCellCompareValue(selectedValue.start);\n      this._rangeEnd = this._getCellCompareValue(selectedValue.end);\n      this._isRange = true;\n    } else {\n      this._rangeStart = this._rangeEnd = this._getCellCompareValue(selectedValue);\n      this._isRange = false;\n    }\n\n    this._comparisonRangeStart = this._getCellCompareValue(this.comparisonStart);\n    this._comparisonRangeEnd = this._getCellCompareValue(this.comparisonEnd);\n  }\n\n  /** Gets whether a date can be selected in the month view. */\n  private _canSelect(date: D) {\n    return !this.dateFilter || this.dateFilter(date);\n  }\n\n  /** Clears out preview state. */\n  private _clearPreview() {\n    this._previewStart = this._previewEnd = null;\n  }\n}\n", "<table class=\"mat-calendar-table\" role=\"grid\">\n  <thead class=\"mat-calendar-table-header\">\n    <tr>\n      @for (day of _weekdays; track day) {\n        <th scope=\"col\">\n          <span class=\"cdk-visually-hidden\">{{day.long}}</span>\n          <span aria-hidden=\"true\">{{day.narrow}}</span>\n        </th>\n      }\n    </tr>\n    <tr><th aria-hidden=\"true\" class=\"mat-calendar-table-header-divider\" colspan=\"7\"></th></tr>\n  </thead>\n  <tbody mat-calendar-body\n         [label]=\"_monthLabel\"\n         [rows]=\"_weeks\"\n         [todayValue]=\"_todayDate!\"\n         [startValue]=\"_rangeStart!\"\n         [endValue]=\"_rangeEnd!\"\n         [comparisonStart]=\"_comparisonRangeStart\"\n         [comparisonEnd]=\"_comparisonRangeEnd\"\n         [previewStart]=\"_previewStart\"\n         [previewEnd]=\"_previewEnd\"\n         [isRange]=\"_isRange\"\n         [labelMinRequiredCells]=\"3\"\n         [activeCell]=\"_dateAdapter.getDate(activeDate) - 1\"\n         [startDateAccessibleName]=\"startDateAccessibleName\"\n         [endDateAccessibleName]=\"endDateAccessibleName\"\n         (selectedValueChange)=\"_dateSelected($event)\"\n         (activeDateChange)=\"_updateActiveDate($event)\"\n         (previewChange)=\"_previewChanged($event)\"\n         (dragStarted)=\"dragStarted.emit($event)\"\n         (dragEnded)=\"_dragEnded($event)\"\n         (keyup)=\"_handleCalendarBodyKeyup($event)\"\n         (keydown)=\"_handleCalendarBodyKeydown($event)\">\n  </tbody>\n</table>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  DOWN_ARROW,\n  END,\n  ENTER,\n  HOME,\n  LEFT_ARROW,\n  PAGE_DOWN,\n  PAGE_UP,\n  RIGHT_ARROW,\n  UP_ARROW,\n  SPACE,\n} from '@angular/cdk/keycodes';\nimport {\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  EventEmitter,\n  Input,\n  Optional,\n  Output,\n  ViewChild,\n  ViewEncapsulation,\n  OnDestroy,\n} from '@angular/core';\nimport {DateAdapter} from '@angular/material/core';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {\n  MatCalendarBody,\n  MatCalendarCell,\n  MatCalendarUserEvent,\n  MatCalendarCellClassFunction,\n} from './calendar-body';\nimport {createMissingDateImplError} from './datepicker-errors';\nimport {Subscription} from 'rxjs';\nimport {startWith} from 'rxjs/operators';\nimport {DateRange} from './date-selection-model';\n\nexport const yearsPerPage = 24;\n\nexport const yearsPerRow = 4;\n\n/**\n * An internal component used to display a year selector in the datepicker.\n * @docs-private\n */\n@Component({\n  selector: 'mat-multi-year-view',\n  templateUrl: 'multi-year-view.html',\n  exportAs: 'matMultiYearView',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatMultiYearView<D> implements AfterContentInit, OnDestroy {\n  private _rerenderSubscription = Subscription.EMPTY;\n\n  /** Flag used to filter out space/enter keyup events that originated outside of the view. */\n  private _selectionKeyPressed: boolean;\n\n  /** The date to display in this multi-year view (everything other than the year is ignored). */\n  @Input()\n  get activeDate(): D {\n    return this._activeDate;\n  }\n  set activeDate(value: D) {\n    let oldActiveDate = this._activeDate;\n    const validDate =\n      this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value)) ||\n      this._dateAdapter.today();\n    this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n\n    if (\n      !isSameMultiYearView(\n        this._dateAdapter,\n        oldActiveDate,\n        this._activeDate,\n        this.minDate,\n        this.maxDate,\n      )\n    ) {\n      this._init();\n    }\n  }\n  private _activeDate: D;\n\n  /** The currently selected date. */\n  @Input()\n  get selected(): DateRange<D> | D | null {\n    return this._selected;\n  }\n  set selected(value: DateRange<D> | D | null) {\n    if (value instanceof DateRange) {\n      this._selected = value;\n    } else {\n      this._selected = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n\n    this._setSelectedYear(value);\n  }\n  private _selected: DateRange<D> | D | null;\n\n  /** The minimum selectable date. */\n  @Input()\n  get minDate(): D | null {\n    return this._minDate;\n  }\n  set minDate(value: D | null) {\n    this._minDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n  }\n  private _minDate: D | null;\n\n  /** The maximum selectable date. */\n  @Input()\n  get maxDate(): D | null {\n    return this._maxDate;\n  }\n  set maxDate(value: D | null) {\n    this._maxDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n  }\n  private _maxDate: D | null;\n\n  /** A function used to filter which dates are selectable. */\n  @Input() dateFilter: (date: D) => boolean;\n\n  /** Function that can be used to add custom CSS classes to date cells. */\n  @Input() dateClass: MatCalendarCellClassFunction<D>;\n\n  /** Emits when a new year is selected. */\n  @Output() readonly selectedChange: EventEmitter<D> = new EventEmitter<D>();\n\n  /** Emits the selected year. This doesn't imply a change on the selected date */\n  @Output() readonly yearSelected: EventEmitter<D> = new EventEmitter<D>();\n\n  /** Emits when any date is activated. */\n  @Output() readonly activeDateChange: EventEmitter<D> = new EventEmitter<D>();\n\n  /** The body of calendar table */\n  @ViewChild(MatCalendarBody) _matCalendarBody: MatCalendarBody;\n\n  /** Grid of calendar cells representing the currently displayed years. */\n  _years: MatCalendarCell[][];\n\n  /** The year that today falls on. */\n  _todayYear: number;\n\n  /** The year of the selected date. Null if the selected date is null. */\n  _selectedYear: number | null;\n\n  constructor(\n    private _changeDetectorRef: ChangeDetectorRef,\n    @Optional() public _dateAdapter: DateAdapter<D>,\n    @Optional() private _dir?: Directionality,\n  ) {\n    if (!this._dateAdapter && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw createMissingDateImplError('DateAdapter');\n    }\n\n    this._activeDate = this._dateAdapter.today();\n  }\n\n  ngAfterContentInit() {\n    this._rerenderSubscription = this._dateAdapter.localeChanges\n      .pipe(startWith(null))\n      .subscribe(() => this._init());\n  }\n\n  ngOnDestroy() {\n    this._rerenderSubscription.unsubscribe();\n  }\n\n  /** Initializes this multi-year view. */\n  _init() {\n    this._todayYear = this._dateAdapter.getYear(this._dateAdapter.today());\n\n    // We want a range years such that we maximize the number of\n    // enabled dates visible at once. This prevents issues where the minimum year\n    // is the last item of a page OR the maximum year is the first item of a page.\n\n    // The offset from the active year to the \"slot\" for the starting year is the\n    // *actual* first rendered year in the multi-year view.\n    const activeYear = this._dateAdapter.getYear(this._activeDate);\n    const minYearOfPage =\n      activeYear - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);\n\n    this._years = [];\n    for (let i = 0, row: number[] = []; i < yearsPerPage; i++) {\n      row.push(minYearOfPage + i);\n      if (row.length == yearsPerRow) {\n        this._years.push(row.map(year => this._createCellForYear(year)));\n        row = [];\n      }\n    }\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /** Handles when a new year is selected. */\n  _yearSelected(event: MatCalendarUserEvent<number>) {\n    const year = event.value;\n    const selectedYear = this._dateAdapter.createDate(year, 0, 1);\n    const selectedDate = this._getDateFromYear(year);\n\n    this.yearSelected.emit(selectedYear);\n    this.selectedChange.emit(selectedDate);\n  }\n\n  /**\n   * Takes the index of a calendar body cell wrapped in an event as argument. For the date that\n   * corresponds to the given cell, set `activeDate` to that date and fire `activeDateChange` with\n   * that date.\n   *\n   * This function is used to match each component's model of the active date with the calendar\n   * body cell that was focused. It updates its value of `activeDate` synchronously and updates the\n   * parent's value asynchronously via the `activeDateChange` event. The child component receives an\n   * updated value asynchronously via the `activeCell` Input.\n   */\n  _updateActiveDate(event: MatCalendarUserEvent<number>) {\n    const year = event.value;\n    const oldActiveDate = this._activeDate;\n\n    this.activeDate = this._getDateFromYear(year);\n    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n      this.activeDateChange.emit(this.activeDate);\n    }\n  }\n\n  /** Handles keydown events on the calendar body when calendar is in multi-year view. */\n  _handleCalendarBodyKeydown(event: KeyboardEvent): void {\n    const oldActiveDate = this._activeDate;\n    const isRtl = this._isRtl();\n\n    switch (event.keyCode) {\n      case LEFT_ARROW:\n        this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? 1 : -1);\n        break;\n      case RIGHT_ARROW:\n        this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? -1 : 1);\n        break;\n      case UP_ARROW:\n        this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -yearsPerRow);\n        break;\n      case DOWN_ARROW:\n        this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerRow);\n        break;\n      case HOME:\n        this.activeDate = this._dateAdapter.addCalendarYears(\n          this._activeDate,\n          -getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate),\n        );\n        break;\n      case END:\n        this.activeDate = this._dateAdapter.addCalendarYears(\n          this._activeDate,\n          yearsPerPage -\n            getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate) -\n            1,\n        );\n        break;\n      case PAGE_UP:\n        this.activeDate = this._dateAdapter.addCalendarYears(\n          this._activeDate,\n          event.altKey ? -yearsPerPage * 10 : -yearsPerPage,\n        );\n        break;\n      case PAGE_DOWN:\n        this.activeDate = this._dateAdapter.addCalendarYears(\n          this._activeDate,\n          event.altKey ? yearsPerPage * 10 : yearsPerPage,\n        );\n        break;\n      case ENTER:\n      case SPACE:\n        // Note that we only prevent the default action here while the selection happens in\n        // `keyup` below. We can't do the selection here, because it can cause the calendar to\n        // reopen if focus is restored immediately. We also can't call `preventDefault` on `keyup`\n        // because it's too late (see #23305).\n        this._selectionKeyPressed = true;\n        break;\n      default:\n        // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n        return;\n    }\n    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n      this.activeDateChange.emit(this.activeDate);\n    }\n\n    this._focusActiveCellAfterViewChecked();\n    // Prevent unexpected default actions such as form submission.\n    event.preventDefault();\n  }\n\n  /** Handles keyup events on the calendar body when calendar is in multi-year view. */\n  _handleCalendarBodyKeyup(event: KeyboardEvent): void {\n    if (event.keyCode === SPACE || event.keyCode === ENTER) {\n      if (this._selectionKeyPressed) {\n        this._yearSelected({value: this._dateAdapter.getYear(this._activeDate), event});\n      }\n\n      this._selectionKeyPressed = false;\n    }\n  }\n\n  _getActiveCell(): number {\n    return getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);\n  }\n\n  /** Focuses the active cell after the microtask queue is empty. */\n  _focusActiveCell() {\n    this._matCalendarBody._focusActiveCell();\n  }\n\n  /** Focuses the active cell after change detection has run and the microtask queue is empty. */\n  _focusActiveCellAfterViewChecked() {\n    this._matCalendarBody._scheduleFocusActiveCellAfterViewChecked();\n  }\n\n  /**\n   * Takes a year and returns a new date on the same day and month as the currently active date\n   *  The returned date will have the same year as the argument date.\n   */\n  private _getDateFromYear(year: number) {\n    const activeMonth = this._dateAdapter.getMonth(this.activeDate);\n    const daysInMonth = this._dateAdapter.getNumDaysInMonth(\n      this._dateAdapter.createDate(year, activeMonth, 1),\n    );\n    const normalizedDate = this._dateAdapter.createDate(\n      year,\n      activeMonth,\n      Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth),\n    );\n    return normalizedDate;\n  }\n\n  /** Creates an MatCalendarCell for the given year. */\n  private _createCellForYear(year: number) {\n    const date = this._dateAdapter.createDate(year, 0, 1);\n    const yearName = this._dateAdapter.getYearName(date);\n    const cellClasses = this.dateClass ? this.dateClass(date, 'multi-year') : undefined;\n\n    return new MatCalendarCell(year, yearName, yearName, this._shouldEnableYear(year), cellClasses);\n  }\n\n  /** Whether the given year is enabled. */\n  private _shouldEnableYear(year: number) {\n    // disable if the year is greater than maxDate lower than minDate\n    if (\n      year === undefined ||\n      year === null ||\n      (this.maxDate && year > this._dateAdapter.getYear(this.maxDate)) ||\n      (this.minDate && year < this._dateAdapter.getYear(this.minDate))\n    ) {\n      return false;\n    }\n\n    // enable if it reaches here and there's no filter defined\n    if (!this.dateFilter) {\n      return true;\n    }\n\n    const firstOfYear = this._dateAdapter.createDate(year, 0, 1);\n\n    // If any date in the year is enabled count the year as enabled.\n    for (\n      let date = firstOfYear;\n      this._dateAdapter.getYear(date) == year;\n      date = this._dateAdapter.addCalendarDays(date, 1)\n    ) {\n      if (this.dateFilter(date)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /** Determines whether the user has the RTL layout direction. */\n  private _isRtl() {\n    return this._dir && this._dir.value === 'rtl';\n  }\n\n  /** Sets the currently-highlighted year based on a model value. */\n  private _setSelectedYear(value: DateRange<D> | D | null) {\n    this._selectedYear = null;\n\n    if (value instanceof DateRange) {\n      const displayValue = value.start || value.end;\n\n      if (displayValue) {\n        this._selectedYear = this._dateAdapter.getYear(displayValue);\n      }\n    } else if (value) {\n      this._selectedYear = this._dateAdapter.getYear(value);\n    }\n  }\n}\n\nexport function isSameMultiYearView<D>(\n  dateAdapter: DateAdapter<D>,\n  date1: D,\n  date2: D,\n  minDate: D | null,\n  maxDate: D | null,\n): boolean {\n  const year1 = dateAdapter.getYear(date1);\n  const year2 = dateAdapter.getYear(date2);\n  const startingYear = getStartingYear(dateAdapter, minDate, maxDate);\n  return (\n    Math.floor((year1 - startingYear) / yearsPerPage) ===\n    Math.floor((year2 - startingYear) / yearsPerPage)\n  );\n}\n\n/**\n * When the multi-year view is first opened, the active year will be in view.\n * So we compute how many years are between the active year and the *slot* where our\n * \"startingYear\" will render when paged into view.\n */\nexport function getActiveOffset<D>(\n  dateAdapter: DateAdapter<D>,\n  activeDate: D,\n  minDate: D | null,\n  maxDate: D | null,\n): number {\n  const activeYear = dateAdapter.getYear(activeDate);\n  return euclideanModulo(activeYear - getStartingYear(dateAdapter, minDate, maxDate), yearsPerPage);\n}\n\n/**\n * We pick a \"starting\" year such that either the maximum year would be at the end\n * or the minimum year would be at the beginning of a page.\n */\nfunction getStartingYear<D>(\n  dateAdapter: DateAdapter<D>,\n  minDate: D | null,\n  maxDate: D | null,\n): number {\n  let startingYear = 0;\n  if (maxDate) {\n    const maxYear = dateAdapter.getYear(maxDate);\n    startingYear = maxYear - yearsPerPage + 1;\n  } else if (minDate) {\n    startingYear = dateAdapter.getYear(minDate);\n  }\n  return startingYear;\n}\n\n/** Gets remainder that is non-negative, even if first number is negative */\nfunction euclideanModulo(a: number, b: number): number {\n  return ((a % b) + b) % b;\n}\n", "<table class=\"mat-calendar-table\" role=\"grid\">\n  <thead aria-hidden=\"true\" class=\"mat-calendar-table-header\">\n    <tr><th class=\"mat-calendar-table-header-divider\" colspan=\"4\"></th></tr>\n  </thead>\n  <tbody mat-calendar-body\n         [rows]=\"_years\"\n         [todayValue]=\"_todayYear\"\n         [startValue]=\"_selectedYear!\"\n         [endValue]=\"_selectedYear!\"\n         [numCols]=\"4\"\n         [cellAspectRatio]=\"4 / 7\"\n         [activeCell]=\"_getActiveCell()\"\n         (selectedValueChange)=\"_yearSelected($event)\"\n         (activeDateChange)=\"_updateActiveDate($event)\"\n         (keyup)=\"_handleCalendarBodyKeyup($event)\"\n         (keydown)=\"_handleCalendarBodyKeydown($event)\">\n  </tbody>\n</table>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  DOWN_ARROW,\n  END,\n  ENTER,\n  HOME,\n  LEFT_ARROW,\n  PAGE_DOWN,\n  PAGE_UP,\n  RIGHT_ARROW,\n  UP_ARROW,\n  SPACE,\n} from '@angular/cdk/keycodes';\nimport {\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  EventEmitter,\n  Inject,\n  Input,\n  Optional,\n  Output,\n  ViewChild,\n  ViewEncapsulation,\n  OnDestroy,\n} from '@angular/core';\nimport {DateAdapter, MAT_DATE_FORMATS, MatDateFormats} from '@angular/material/core';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {\n  MatCalendarBody,\n  MatCalendarCell,\n  MatCalendarUserEvent,\n  MatCalendarCellClassFunction,\n} from './calendar-body';\nimport {createMissingDateImplError} from './datepicker-errors';\nimport {Subscription} from 'rxjs';\nimport {startWith} from 'rxjs/operators';\nimport {DateRange} from './date-selection-model';\n\n/**\n * An internal component used to display a single year in the datepicker.\n * @docs-private\n */\n@Component({\n  selector: 'mat-year-view',\n  templateUrl: 'year-view.html',\n  exportAs: 'matYearView',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatYearView<D> implements AfterContentInit, OnDestroy {\n  private _rerenderSubscription = Subscription.EMPTY;\n\n  /** Flag used to filter out space/enter keyup events that originated outside of the view. */\n  private _selectionKeyPressed: boolean;\n\n  /** The date to display in this year view (everything other than the year is ignored). */\n  @Input()\n  get activeDate(): D {\n    return this._activeDate;\n  }\n  set activeDate(value: D) {\n    let oldActiveDate = this._activeDate;\n    const validDate =\n      this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value)) ||\n      this._dateAdapter.today();\n    this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n    if (this._dateAdapter.getYear(oldActiveDate) !== this._dateAdapter.getYear(this._activeDate)) {\n      this._init();\n    }\n  }\n  private _activeDate: D;\n\n  /** The currently selected date. */\n  @Input()\n  get selected(): DateRange<D> | D | null {\n    return this._selected;\n  }\n  set selected(value: DateRange<D> | D | null) {\n    if (value instanceof DateRange) {\n      this._selected = value;\n    } else {\n      this._selected = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n\n    this._setSelectedMonth(value);\n  }\n  private _selected: DateRange<D> | D | null;\n\n  /** The minimum selectable date. */\n  @Input()\n  get minDate(): D | null {\n    return this._minDate;\n  }\n  set minDate(value: D | null) {\n    this._minDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n  }\n  private _minDate: D | null;\n\n  /** The maximum selectable date. */\n  @Input()\n  get maxDate(): D | null {\n    return this._maxDate;\n  }\n  set maxDate(value: D | null) {\n    this._maxDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n  }\n  private _maxDate: D | null;\n\n  /** A function used to filter which dates are selectable. */\n  @Input() dateFilter: (date: D) => boolean;\n\n  /** Function that can be used to add custom CSS classes to date cells. */\n  @Input() dateClass: MatCalendarCellClassFunction<D>;\n\n  /** Emits when a new month is selected. */\n  @Output() readonly selectedChange: EventEmitter<D> = new EventEmitter<D>();\n\n  /** Emits the selected month. This doesn't imply a change on the selected date */\n  @Output() readonly monthSelected: EventEmitter<D> = new EventEmitter<D>();\n\n  /** Emits when any date is activated. */\n  @Output() readonly activeDateChange: EventEmitter<D> = new EventEmitter<D>();\n\n  /** The body of calendar table */\n  @ViewChild(MatCalendarBody) _matCalendarBody: MatCalendarBody;\n\n  /** Grid of calendar cells representing the months of the year. */\n  _months: MatCalendarCell[][];\n\n  /** The label for this year (e.g. \"2017\"). */\n  _yearLabel: string;\n\n  /** The month in this year that today falls on. Null if today is in a different year. */\n  _todayMonth: number | null;\n\n  /**\n   * The month in this year that the selected Date falls on.\n   * Null if the selected Date is in a different year.\n   */\n  _selectedMonth: number | null;\n\n  constructor(\n    readonly _changeDetectorRef: ChangeDetectorRef,\n    @Optional() @Inject(MAT_DATE_FORMATS) private _dateFormats: MatDateFormats,\n    @Optional() public _dateAdapter: DateAdapter<D>,\n    @Optional() private _dir?: Directionality,\n  ) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n      if (!this._dateFormats) {\n        throw createMissingDateImplError('MAT_DATE_FORMATS');\n      }\n    }\n\n    this._activeDate = this._dateAdapter.today();\n  }\n\n  ngAfterContentInit() {\n    this._rerenderSubscription = this._dateAdapter.localeChanges\n      .pipe(startWith(null))\n      .subscribe(() => this._init());\n  }\n\n  ngOnDestroy() {\n    this._rerenderSubscription.unsubscribe();\n  }\n\n  /** Handles when a new month is selected. */\n  _monthSelected(event: MatCalendarUserEvent<number>) {\n    const month = event.value;\n\n    const selectedMonth = this._dateAdapter.createDate(\n      this._dateAdapter.getYear(this.activeDate),\n      month,\n      1,\n    );\n    this.monthSelected.emit(selectedMonth);\n\n    const selectedDate = this._getDateFromMonth(month);\n    this.selectedChange.emit(selectedDate);\n  }\n\n  /**\n   * Takes the index of a calendar body cell wrapped in an event as argument. For the date that\n   * corresponds to the given cell, set `activeDate` to that date and fire `activeDateChange` with\n   * that date.\n   *\n   * This function is used to match each component's model of the active date with the calendar\n   * body cell that was focused. It updates its value of `activeDate` synchronously and updates the\n   * parent's value asynchronously via the `activeDateChange` event. The child component receives an\n   * updated value asynchronously via the `activeCell` Input.\n   */\n  _updateActiveDate(event: MatCalendarUserEvent<number>) {\n    const month = event.value;\n    const oldActiveDate = this._activeDate;\n\n    this.activeDate = this._getDateFromMonth(month);\n\n    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n      this.activeDateChange.emit(this.activeDate);\n    }\n  }\n\n  /** Handles keydown events on the calendar body when calendar is in year view. */\n  _handleCalendarBodyKeydown(event: KeyboardEvent): void {\n    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\n    // disabled ones from being selected. This may not be ideal, we should look into whether\n    // navigation should skip over disabled dates, and if so, how to implement that efficiently.\n\n    const oldActiveDate = this._activeDate;\n    const isRtl = this._isRtl();\n\n    switch (event.keyCode) {\n      case LEFT_ARROW:\n        this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? 1 : -1);\n        break;\n      case RIGHT_ARROW:\n        this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? -1 : 1);\n        break;\n      case UP_ARROW:\n        this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -4);\n        break;\n      case DOWN_ARROW:\n        this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 4);\n        break;\n      case HOME:\n        this.activeDate = this._dateAdapter.addCalendarMonths(\n          this._activeDate,\n          -this._dateAdapter.getMonth(this._activeDate),\n        );\n        break;\n      case END:\n        this.activeDate = this._dateAdapter.addCalendarMonths(\n          this._activeDate,\n          11 - this._dateAdapter.getMonth(this._activeDate),\n        );\n        break;\n      case PAGE_UP:\n        this.activeDate = this._dateAdapter.addCalendarYears(\n          this._activeDate,\n          event.altKey ? -10 : -1,\n        );\n        break;\n      case PAGE_DOWN:\n        this.activeDate = this._dateAdapter.addCalendarYears(\n          this._activeDate,\n          event.altKey ? 10 : 1,\n        );\n        break;\n      case ENTER:\n      case SPACE:\n        // Note that we only prevent the default action here while the selection happens in\n        // `keyup` below. We can't do the selection here, because it can cause the calendar to\n        // reopen if focus is restored immediately. We also can't call `preventDefault` on `keyup`\n        // because it's too late (see #23305).\n        this._selectionKeyPressed = true;\n        break;\n      default:\n        // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n        return;\n    }\n\n    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n      this.activeDateChange.emit(this.activeDate);\n      this._focusActiveCellAfterViewChecked();\n    }\n\n    // Prevent unexpected default actions such as form submission.\n    event.preventDefault();\n  }\n\n  /** Handles keyup events on the calendar body when calendar is in year view. */\n  _handleCalendarBodyKeyup(event: KeyboardEvent): void {\n    if (event.keyCode === SPACE || event.keyCode === ENTER) {\n      if (this._selectionKeyPressed) {\n        this._monthSelected({value: this._dateAdapter.getMonth(this._activeDate), event});\n      }\n\n      this._selectionKeyPressed = false;\n    }\n  }\n\n  /** Initializes this year view. */\n  _init() {\n    this._setSelectedMonth(this.selected);\n    this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());\n    this._yearLabel = this._dateAdapter.getYearName(this.activeDate);\n\n    let monthNames = this._dateAdapter.getMonthNames('short');\n    // First row of months only contains 5 elements so we can fit the year label on the same row.\n    this._months = [\n      [0, 1, 2, 3],\n      [4, 5, 6, 7],\n      [8, 9, 10, 11],\n    ].map(row => row.map(month => this._createCellForMonth(month, monthNames[month])));\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /** Focuses the active cell after the microtask queue is empty. */\n  _focusActiveCell() {\n    this._matCalendarBody._focusActiveCell();\n  }\n\n  /** Schedules the matCalendarBody to focus the active cell after change detection has run */\n  _focusActiveCellAfterViewChecked() {\n    this._matCalendarBody._scheduleFocusActiveCellAfterViewChecked();\n  }\n\n  /**\n   * Gets the month in this year that the given Date falls on.\n   * Returns null if the given Date is in another year.\n   */\n  private _getMonthInCurrentYear(date: D | null) {\n    return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate)\n      ? this._dateAdapter.getMonth(date)\n      : null;\n  }\n\n  /**\n   * Takes a month and returns a new date in the same day and year as the currently active date.\n   *  The returned date will have the same month as the argument date.\n   */\n  private _getDateFromMonth(month: number) {\n    const normalizedDate = this._dateAdapter.createDate(\n      this._dateAdapter.getYear(this.activeDate),\n      month,\n      1,\n    );\n\n    const daysInMonth = this._dateAdapter.getNumDaysInMonth(normalizedDate);\n\n    return this._dateAdapter.createDate(\n      this._dateAdapter.getYear(this.activeDate),\n      month,\n      Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth),\n    );\n  }\n\n  /** Creates an MatCalendarCell for the given month. */\n  private _createCellForMonth(month: number, monthName: string) {\n    const date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);\n    const ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.monthYearA11yLabel);\n    const cellClasses = this.dateClass ? this.dateClass(date, 'year') : undefined;\n\n    return new MatCalendarCell(\n      month,\n      monthName.toLocaleUpperCase(),\n      ariaLabel,\n      this._shouldEnableMonth(month),\n      cellClasses,\n    );\n  }\n\n  /** Whether the given month is enabled. */\n  private _shouldEnableMonth(month: number) {\n    const activeYear = this._dateAdapter.getYear(this.activeDate);\n\n    if (\n      month === undefined ||\n      month === null ||\n      this._isYearAndMonthAfterMaxDate(activeYear, month) ||\n      this._isYearAndMonthBeforeMinDate(activeYear, month)\n    ) {\n      return false;\n    }\n\n    if (!this.dateFilter) {\n      return true;\n    }\n\n    const firstOfMonth = this._dateAdapter.createDate(activeYear, month, 1);\n\n    // If any date in the month is enabled count the month as enabled.\n    for (\n      let date = firstOfMonth;\n      this._dateAdapter.getMonth(date) == month;\n      date = this._dateAdapter.addCalendarDays(date, 1)\n    ) {\n      if (this.dateFilter(date)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Tests whether the combination month/year is after this.maxDate, considering\n   * just the month and year of this.maxDate\n   */\n  private _isYearAndMonthAfterMaxDate(year: number, month: number) {\n    if (this.maxDate) {\n      const maxYear = this._dateAdapter.getYear(this.maxDate);\n      const maxMonth = this._dateAdapter.getMonth(this.maxDate);\n\n      return year > maxYear || (year === maxYear && month > maxMonth);\n    }\n\n    return false;\n  }\n\n  /**\n   * Tests whether the combination month/year is before this.minDate, considering\n   * just the month and year of this.minDate\n   */\n  private _isYearAndMonthBeforeMinDate(year: number, month: number) {\n    if (this.minDate) {\n      const minYear = this._dateAdapter.getYear(this.minDate);\n      const minMonth = this._dateAdapter.getMonth(this.minDate);\n\n      return year < minYear || (year === minYear && month < minMonth);\n    }\n\n    return false;\n  }\n\n  /** Determines whether the user has the RTL layout direction. */\n  private _isRtl() {\n    return this._dir && this._dir.value === 'rtl';\n  }\n\n  /** Sets the currently-selected month based on a model value. */\n  private _setSelectedMonth(value: DateRange<D> | D | null) {\n    if (value instanceof DateRange) {\n      this._selectedMonth =\n        this._getMonthInCurrentYear(value.start) || this._getMonthInCurrentYear(value.end);\n    } else {\n      this._selectedMonth = this._getMonthInCurrentYear(value);\n    }\n  }\n}\n", "<table class=\"mat-calendar-table\" role=\"grid\">\n  <thead aria-hidden=\"true\" class=\"mat-calendar-table-header\">\n    <tr><th class=\"mat-calendar-table-header-divider\" colspan=\"4\"></th></tr>\n  </thead>\n  <tbody mat-calendar-body\n         [label]=\"_yearLabel\"\n         [rows]=\"_months\"\n         [todayValue]=\"_todayMonth!\"\n         [startValue]=\"_selectedMonth!\"\n         [endValue]=\"_selectedMonth!\"\n         [labelMinRequiredCells]=\"2\"\n         [numCols]=\"4\"\n         [cellAspectRatio]=\"4 / 7\"\n         [activeCell]=\"_dateAdapter.getMonth(activeDate)\"\n         (selectedValueChange)=\"_monthSelected($event)\"\n         (activeDateChange)=\"_updateActiveDate($event)\"\n         (keyup)=\"_handleCalendarBodyKeyup($event)\"\n         (keydown)=\"_handleCalendarBodyKeydown($event)\">\n  </tbody>\n</table>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentPortal, ComponentType, Portal} from '@angular/cdk/portal';\nimport {\n  AfterContentInit,\n  AfterViewChecked,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  EventEmitter,\n  forwardRef,\n  Inject,\n  Input,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Output,\n  SimpleChange,\n  SimpleChanges,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {DateAdapter, MAT_DATE_FORMATS, MatDateFormats} from '@angular/material/core';\nimport {Subject, Subscription} from 'rxjs';\nimport {MatCalendarUserEvent, MatCalendarCellClassFunction} from './calendar-body';\nimport {createMissingDateImplError} from './datepicker-errors';\nimport {MatDatepickerIntl} from './datepicker-intl';\nimport {MatMonthView} from './month-view';\nimport {\n  getActiveOffset,\n  isSameMultiYearView,\n  MatMultiYearView,\n  yearsPerPage,\n} from './multi-year-view';\nimport {MatYearView} from './year-view';\nimport {MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER, DateRange} from './date-selection-model';\n\nlet calendarHeaderId = 1;\n\n/**\n * Possible views for the calendar.\n * @docs-private\n */\nexport type MatCalendarView = 'month' | 'year' | 'multi-year';\n\n/** Default header for MatCalendar */\n@Component({\n  selector: 'mat-calendar-header',\n  templateUrl: 'calendar-header.html',\n  exportAs: 'matCalendarHeader',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatCalendarHeader<D> {\n  constructor(\n    private _intl: MatDatepickerIntl,\n    @Inject(forwardRef(() => MatCalendar)) public calendar: MatCalendar<D>,\n    @Optional() private _dateAdapter: DateAdapter<D>,\n    @Optional() @Inject(MAT_DATE_FORMATS) private _dateFormats: MatDateFormats,\n    changeDetectorRef: ChangeDetectorRef,\n  ) {\n    this.calendar.stateChanges.subscribe(() => changeDetectorRef.markForCheck());\n  }\n\n  /** The display text for the current calendar view. */\n  get periodButtonText(): string {\n    if (this.calendar.currentView == 'month') {\n      return this._dateAdapter\n        .format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel)\n        .toLocaleUpperCase();\n    }\n    if (this.calendar.currentView == 'year') {\n      return this._dateAdapter.getYearName(this.calendar.activeDate);\n    }\n\n    return this._intl.formatYearRange(...this._formatMinAndMaxYearLabels());\n  }\n\n  /** The aria description for the current calendar view. */\n  get periodButtonDescription(): string {\n    if (this.calendar.currentView == 'month') {\n      return this._dateAdapter\n        .format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel)\n        .toLocaleUpperCase();\n    }\n    if (this.calendar.currentView == 'year') {\n      return this._dateAdapter.getYearName(this.calendar.activeDate);\n    }\n\n    // Format a label for the window of years displayed in the multi-year calendar view. Use\n    // `formatYearRangeLabel` because it is TTS friendly.\n    return this._intl.formatYearRangeLabel(...this._formatMinAndMaxYearLabels());\n  }\n\n  /** The `aria-label` for changing the calendar view. */\n  get periodButtonLabel(): string {\n    return this.calendar.currentView == 'month'\n      ? this._intl.switchToMultiYearViewLabel\n      : this._intl.switchToMonthViewLabel;\n  }\n\n  /** The label for the previous button. */\n  get prevButtonLabel(): string {\n    return {\n      'month': this._intl.prevMonthLabel,\n      'year': this._intl.prevYearLabel,\n      'multi-year': this._intl.prevMultiYearLabel,\n    }[this.calendar.currentView];\n  }\n\n  /** The label for the next button. */\n  get nextButtonLabel(): string {\n    return {\n      'month': this._intl.nextMonthLabel,\n      'year': this._intl.nextYearLabel,\n      'multi-year': this._intl.nextMultiYearLabel,\n    }[this.calendar.currentView];\n  }\n\n  /** Handles user clicks on the period label. */\n  currentPeriodClicked(): void {\n    this.calendar.currentView = this.calendar.currentView == 'month' ? 'multi-year' : 'month';\n  }\n\n  /** Handles user clicks on the previous button. */\n  previousClicked(): void {\n    this.calendar.activeDate =\n      this.calendar.currentView == 'month'\n        ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1)\n        : this._dateAdapter.addCalendarYears(\n            this.calendar.activeDate,\n            this.calendar.currentView == 'year' ? -1 : -yearsPerPage,\n          );\n  }\n\n  /** Handles user clicks on the next button. */\n  nextClicked(): void {\n    this.calendar.activeDate =\n      this.calendar.currentView == 'month'\n        ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1)\n        : this._dateAdapter.addCalendarYears(\n            this.calendar.activeDate,\n            this.calendar.currentView == 'year' ? 1 : yearsPerPage,\n          );\n  }\n\n  /** Whether the previous period button is enabled. */\n  previousEnabled(): boolean {\n    if (!this.calendar.minDate) {\n      return true;\n    }\n    return (\n      !this.calendar.minDate || !this._isSameView(this.calendar.activeDate, this.calendar.minDate)\n    );\n  }\n\n  /** Whether the next period button is enabled. */\n  nextEnabled(): boolean {\n    return (\n      !this.calendar.maxDate || !this._isSameView(this.calendar.activeDate, this.calendar.maxDate)\n    );\n  }\n\n  /** Whether the two dates represent the same view in the current view mode (month or year). */\n  private _isSameView(date1: D, date2: D): boolean {\n    if (this.calendar.currentView == 'month') {\n      return (\n        this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) &&\n        this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2)\n      );\n    }\n    if (this.calendar.currentView == 'year') {\n      return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);\n    }\n    // Otherwise we are in 'multi-year' view.\n    return isSameMultiYearView(\n      this._dateAdapter,\n      date1,\n      date2,\n      this.calendar.minDate,\n      this.calendar.maxDate,\n    );\n  }\n\n  /**\n   * Format two individual labels for the minimum year and maximum year available in the multi-year\n   * calendar view. Returns an array of two strings where the first string is the formatted label\n   * for the minimum year, and the second string is the formatted label for the maximum year.\n   */\n  private _formatMinAndMaxYearLabels(): [minYearLabel: string, maxYearLabel: string] {\n    // The offset from the active year to the \"slot\" for the starting year is the\n    // *actual* first rendered year in the multi-year view, and the last year is\n    // just yearsPerPage - 1 away.\n    const activeYear = this._dateAdapter.getYear(this.calendar.activeDate);\n    const minYearOfPage =\n      activeYear -\n      getActiveOffset(\n        this._dateAdapter,\n        this.calendar.activeDate,\n        this.calendar.minDate,\n        this.calendar.maxDate,\n      );\n    const maxYearOfPage = minYearOfPage + yearsPerPage - 1;\n    const minYearLabel = this._dateAdapter.getYearName(\n      this._dateAdapter.createDate(minYearOfPage, 0, 1),\n    );\n    const maxYearLabel = this._dateAdapter.getYearName(\n      this._dateAdapter.createDate(maxYearOfPage, 0, 1),\n    );\n\n    return [minYearLabel, maxYearLabel];\n  }\n\n  private _id = `mat-calendar-header-${calendarHeaderId++}`;\n\n  _periodButtonLabelId = `${this._id}-period-label`;\n}\n\n/** A calendar that is used as part of the datepicker. */\n@Component({\n  selector: 'mat-calendar',\n  templateUrl: 'calendar.html',\n  styleUrls: ['calendar.css'],\n  host: {\n    'class': 'mat-calendar',\n  },\n  exportAs: 'matCalendar',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  providers: [MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER],\n})\nexport class MatCalendar<D> implements AfterContentInit, AfterViewChecked, OnDestroy, OnChanges {\n  /** An input indicating the type of the header component, if set. */\n  @Input() headerComponent: ComponentType<any>;\n\n  /** A portal containing the header component type for this calendar. */\n  _calendarHeaderPortal: Portal<any>;\n\n  private _intlChanges: Subscription;\n\n  /**\n   * Used for scheduling that focus should be moved to the active cell on the next tick.\n   * We need to schedule it, rather than do it immediately, because we have to wait\n   * for Angular to re-evaluate the view children.\n   */\n  private _moveFocusOnNextTick = false;\n\n  /** A date representing the period (month or year) to start the calendar in. */\n  @Input()\n  get startAt(): D | null {\n    return this._startAt;\n  }\n  set startAt(value: D | null) {\n    this._startAt = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n  }\n  private _startAt: D | null;\n\n  /** Whether the calendar should be started in month or year view. */\n  @Input() startView: MatCalendarView = 'month';\n\n  /** The currently selected date. */\n  @Input()\n  get selected(): DateRange<D> | D | null {\n    return this._selected;\n  }\n  set selected(value: DateRange<D> | D | null) {\n    if (value instanceof DateRange) {\n      this._selected = value;\n    } else {\n      this._selected = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n  }\n  private _selected: DateRange<D> | D | null;\n\n  /** The minimum selectable date. */\n  @Input()\n  get minDate(): D | null {\n    return this._minDate;\n  }\n  set minDate(value: D | null) {\n    this._minDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n  }\n  private _minDate: D | null;\n\n  /** The maximum selectable date. */\n  @Input()\n  get maxDate(): D | null {\n    return this._maxDate;\n  }\n  set maxDate(value: D | null) {\n    this._maxDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n  }\n  private _maxDate: D | null;\n\n  /** Function used to filter which dates are selectable. */\n  @Input() dateFilter: (date: D) => boolean;\n\n  /** Function that can be used to add custom CSS classes to dates. */\n  @Input() dateClass: MatCalendarCellClassFunction<D>;\n\n  /** Start of the comparison range. */\n  @Input() comparisonStart: D | null;\n\n  /** End of the comparison range. */\n  @Input() comparisonEnd: D | null;\n\n  /** ARIA Accessible name of the `<input matStartDate/>` */\n  @Input() startDateAccessibleName: string | null;\n\n  /** ARIA Accessible name of the `<input matEndDate/>` */\n  @Input() endDateAccessibleName: string | null;\n\n  /** Emits when the currently selected date changes. */\n  @Output() readonly selectedChange: EventEmitter<D | null> = new EventEmitter<D | null>();\n\n  /**\n   * Emits the year chosen in multiyear view.\n   * This doesn't imply a change on the selected date.\n   */\n  @Output() readonly yearSelected: EventEmitter<D> = new EventEmitter<D>();\n\n  /**\n   * Emits the month chosen in year view.\n   * This doesn't imply a change on the selected date.\n   */\n  @Output() readonly monthSelected: EventEmitter<D> = new EventEmitter<D>();\n\n  /**\n   * Emits when the current view changes.\n   */\n  @Output() readonly viewChanged: EventEmitter<MatCalendarView> = new EventEmitter<MatCalendarView>(\n    true,\n  );\n\n  /** Emits when any date is selected. */\n  @Output() readonly _userSelection: EventEmitter<MatCalendarUserEvent<D | null>> =\n    new EventEmitter<MatCalendarUserEvent<D | null>>();\n\n  /** Emits a new date range value when the user completes a drag drop operation. */\n  @Output() readonly _userDragDrop = new EventEmitter<MatCalendarUserEvent<DateRange<D>>>();\n\n  /** Reference to the current month view component. */\n  @ViewChild(MatMonthView) monthView: MatMonthView<D>;\n\n  /** Reference to the current year view component. */\n  @ViewChild(MatYearView) yearView: MatYearView<D>;\n\n  /** Reference to the current multi-year view component. */\n  @ViewChild(MatMultiYearView) multiYearView: MatMultiYearView<D>;\n\n  /**\n   * The current active date. This determines which time period is shown and which date is\n   * highlighted when using keyboard navigation.\n   */\n  get activeDate(): D {\n    return this._clampedActiveDate;\n  }\n  set activeDate(value: D) {\n    this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);\n    this.stateChanges.next();\n    this._changeDetectorRef.markForCheck();\n  }\n  private _clampedActiveDate: D;\n\n  /** Whether the calendar is in month view. */\n  get currentView(): MatCalendarView {\n    return this._currentView;\n  }\n  set currentView(value: MatCalendarView) {\n    const viewChangedResult = this._currentView !== value ? value : null;\n    this._currentView = value;\n    this._moveFocusOnNextTick = true;\n    this._changeDetectorRef.markForCheck();\n    if (viewChangedResult) {\n      this.viewChanged.emit(viewChangedResult);\n    }\n  }\n  private _currentView: MatCalendarView;\n\n  /** Origin of active drag, or null when dragging is not active. */\n  protected _activeDrag: MatCalendarUserEvent<D> | null = null;\n\n  /**\n   * Emits whenever there is a state change that the header may need to respond to.\n   */\n  readonly stateChanges = new Subject<void>();\n\n  constructor(\n    _intl: MatDatepickerIntl,\n    @Optional() private _dateAdapter: DateAdapter<D>,\n    @Optional() @Inject(MAT_DATE_FORMATS) private _dateFormats: MatDateFormats,\n    private _changeDetectorRef: ChangeDetectorRef,\n  ) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError('MAT_DATE_FORMATS');\n      }\n    }\n\n    this._intlChanges = _intl.changes.subscribe(() => {\n      _changeDetectorRef.markForCheck();\n      this.stateChanges.next();\n    });\n  }\n\n  ngAfterContentInit() {\n    this._calendarHeaderPortal = new ComponentPortal(this.headerComponent || MatCalendarHeader);\n    this.activeDate = this.startAt || this._dateAdapter.today();\n\n    // Assign to the private property since we don't want to move focus on init.\n    this._currentView = this.startView;\n  }\n\n  ngAfterViewChecked() {\n    if (this._moveFocusOnNextTick) {\n      this._moveFocusOnNextTick = false;\n      this.focusActiveCell();\n    }\n  }\n\n  ngOnDestroy() {\n    this._intlChanges.unsubscribe();\n    this.stateChanges.complete();\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    // Ignore date changes that are at a different time on the same day. This fixes issues where\n    // the calendar re-renders when there is no meaningful change to [minDate] or [maxDate]\n    // (#24435).\n    const minDateChange: SimpleChange | undefined =\n      changes['minDate'] &&\n      !this._dateAdapter.sameDate(changes['minDate'].previousValue, changes['minDate'].currentValue)\n        ? changes['minDate']\n        : undefined;\n    const maxDateChange: SimpleChange | undefined =\n      changes['maxDate'] &&\n      !this._dateAdapter.sameDate(changes['maxDate'].previousValue, changes['maxDate'].currentValue)\n        ? changes['maxDate']\n        : undefined;\n\n    const change = minDateChange || maxDateChange || changes['dateFilter'];\n\n    if (change && !change.firstChange) {\n      const view = this._getCurrentViewComponent();\n\n      if (view) {\n        // We need to `detectChanges` manually here, because the `minDate`, `maxDate` etc. are\n        // passed down to the view via data bindings which won't be up-to-date when we call `_init`.\n        this._changeDetectorRef.detectChanges();\n        view._init();\n      }\n    }\n\n    this.stateChanges.next();\n  }\n\n  /** Focuses the active date. */\n  focusActiveCell() {\n    this._getCurrentViewComponent()._focusActiveCell(false);\n  }\n\n  /** Updates today's date after an update of the active date */\n  updateTodaysDate() {\n    this._getCurrentViewComponent()._init();\n  }\n\n  /** Handles date selection in the month view. */\n  _dateSelected(event: MatCalendarUserEvent<D | null>): void {\n    const date = event.value;\n\n    if (\n      this.selected instanceof DateRange ||\n      (date && !this._dateAdapter.sameDate(date, this.selected))\n    ) {\n      this.selectedChange.emit(date);\n    }\n\n    this._userSelection.emit(event);\n  }\n\n  /** Handles year selection in the multiyear view. */\n  _yearSelectedInMultiYearView(normalizedYear: D) {\n    this.yearSelected.emit(normalizedYear);\n  }\n\n  /** Handles month selection in the year view. */\n  _monthSelectedInYearView(normalizedMonth: D) {\n    this.monthSelected.emit(normalizedMonth);\n  }\n\n  /** Handles year/month selection in the multi-year/year views. */\n  _goToDateInView(date: D, view: 'month' | 'year' | 'multi-year'): void {\n    this.activeDate = date;\n    this.currentView = view;\n  }\n\n  /** Called when the user starts dragging to change a date range. */\n  _dragStarted(event: MatCalendarUserEvent<D>) {\n    this._activeDrag = event;\n  }\n\n  /**\n   * Called when a drag completes. It may end in cancelation or in the selection\n   * of a new range.\n   */\n  _dragEnded(event: MatCalendarUserEvent<DateRange<D> | null>) {\n    if (!this._activeDrag) return;\n\n    if (event.value) {\n      this._userDragDrop.emit(event as MatCalendarUserEvent<DateRange<D>>);\n    }\n\n    this._activeDrag = null;\n  }\n\n  /** Returns the component instance that corresponds to the current calendar view. */\n  private _getCurrentViewComponent(): MatMonthView<D> | MatYearView<D> | MatMultiYearView<D> {\n    // The return type is explicitly written as a union to ensure that the Closure compiler does\n    // not optimize calls to _init(). Without the explicit return type, TypeScript narrows it to\n    // only the first component type. See https://github.com/angular/components/issues/22996.\n    return this.monthView || this.yearView || this.multiYearView;\n  }\n}\n", "<div class=\"mat-calendar-header\">\n  <div class=\"mat-calendar-controls\">\n    <button mat-button type=\"button\" class=\"mat-calendar-period-button\"\n            (click)=\"currentPeriodClicked()\" [attr.aria-label]=\"periodButtonLabel\"\n            [attr.aria-describedby]=\"_periodButtonLabelId\" aria-live=\"polite\">\n      <span aria-hidden=\"true\">{{periodButtonText}}</span>\n      <svg class=\"mat-calendar-arrow\" [class.mat-calendar-invert]=\"calendar.currentView !== 'month'\"\n           viewBox=\"0 0 10 5\" focusable=\"false\" aria-hidden=\"true\">\n           <polygon points=\"0,0 5,5 10,0\"/>\n      </svg>\n    </button>\n\n    <div class=\"mat-calendar-spacer\"></div>\n\n    <ng-content></ng-content>\n\n    <button mat-icon-button type=\"button\" class=\"mat-calendar-previous-button\"\n            [disabled]=\"!previousEnabled()\" (click)=\"previousClicked()\"\n            [attr.aria-label]=\"prevButtonLabel\">\n    </button>\n\n    <button mat-icon-button type=\"button\" class=\"mat-calendar-next-button\"\n            [disabled]=\"!nextEnabled()\" (click)=\"nextClicked()\"\n            [attr.aria-label]=\"nextButtonLabel\">\n    </button>\n  </div>\n</div>\n<label [id]=\"_periodButtonLabelId\" class=\"mat-calendar-hidden-label\">{{periodButtonDescription}}</label>\n", "<ng-template [cdkPortalOutlet]=\"_calendarHeaderPortal\"></ng-template>\n\n<div class=\"mat-calendar-content\" cdkMonitorSubtreeFocus tabindex=\"-1\">\n  @switch (currentView) {\n    @case ('month') {\n        <mat-month-view\n            [(activeDate)]=\"activeDate\"\n            [selected]=\"selected\"\n            [dateFilter]=\"dateFilter\"\n            [maxDate]=\"maxDate\"\n            [minDate]=\"minDate\"\n            [dateClass]=\"dateClass\"\n            [comparisonStart]=\"comparisonStart\"\n            [comparisonEnd]=\"comparisonEnd\"\n            [startDateAccessibleName]=\"startDateAccessibleName\"\n            [endDateAccessibleName]=\"endDateAccessibleName\"\n            (_userSelection)=\"_dateSelected($event)\"\n            (dragStarted)=\"_dragStarted($event)\"\n            (dragEnded)=\"_dragEnded($event)\"\n            [activeDrag]=\"_activeDrag\"></mat-month-view>\n    }\n\n    @case ('year') {\n        <mat-year-view\n            [(activeDate)]=\"activeDate\"\n            [selected]=\"selected\"\n            [dateFilter]=\"dateFilter\"\n            [maxDate]=\"maxDate\"\n            [minDate]=\"minDate\"\n            [dateClass]=\"dateClass\"\n            (monthSelected)=\"_monthSelectedInYearView($event)\"\n            (selectedChange)=\"_goToDateInView($event, 'month')\"></mat-year-view>\n    }\n\n    @case ('multi-year') {\n        <mat-multi-year-view\n            [(activeDate)]=\"activeDate\"\n            [selected]=\"selected\"\n            [dateFilter]=\"dateFilter\"\n            [maxDate]=\"maxDate\"\n            [minDate]=\"minDate\"\n            [dateClass]=\"dateClass\"\n            (yearSelected)=\"_yearSelectedInMultiYearView($event)\"\n            (selectedChange)=\"_goToDateInView($event, 'year')\"></mat-multi-year-view>\n    }\n  }\n</div>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  animate,\n  state,\n  style,\n  transition,\n  trigger,\n  keyframes,\n  AnimationTriggerMetadata,\n} from '@angular/animations';\n\n/**\n * Animations used by the Material datepicker.\n * @docs-private\n */\nexport const matDatepickerAnimations: {\n  readonly transformPanel: AnimationTriggerMetadata;\n  readonly fadeInCalendar: AnimationTriggerMetadata;\n} = {\n  /** Transforms the height of the datepicker's calendar. */\n  transformPanel: trigger('transformPanel', [\n    transition(\n      'void => enter-dropdown',\n      animate(\n        '120ms cubic-bezier(0, 0, 0.2, 1)',\n        keyframes([\n          style({opacity: 0, transform: 'scale(1, 0.8)'}),\n          style({opacity: 1, transform: 'scale(1, 1)'}),\n        ]),\n      ),\n    ),\n    transition(\n      'void => enter-dialog',\n      animate(\n        '150ms cubic-bezier(0, 0, 0.2, 1)',\n        keyframes([\n          style({opacity: 0, transform: 'scale(0.7)'}),\n          style({transform: 'none', opacity: 1}),\n        ]),\n      ),\n    ),\n    transition('* => void', animate('100ms linear', style({opacity: 0}))),\n  ]),\n\n  /** Fades in the content of the calendar. */\n  fadeInCalendar: trigger('fadeInCalendar', [\n    state('void', style({opacity: 0})),\n    state('enter', style({opacity: 1})),\n\n    // TODO(crisbeto): this animation should be removed since it isn't quite on spec, but we\n    // need to keep it until #12440 gets in, otherwise the exit animation will look glitchy.\n    transition('void => *', animate('120ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')),\n  ]),\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {BooleanInput, coerceBooleanProperty, coerceStringArray} from '@angular/cdk/coercion';\nimport {\n  DOWN_ARROW,\n  ESCAPE,\n  hasModifierKey,\n  LEFT_ARROW,\n  ModifierKey,\n  PAGE_DOWN,\n  PAGE_UP,\n  RIGHT_ARROW,\n  UP_ARROW,\n} from '@angular/cdk/keycodes';\nimport {\n  Overlay,\n  OverlayConfig,\n  OverlayRef,\n  ScrollStrategy,\n  FlexibleConnectedPositionStrategy,\n} from '@angular/cdk/overlay';\nimport {ComponentPortal, ComponentType, TemplatePortal} from '@angular/cdk/portal';\nimport {\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  Component,\n  ComponentRef,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  InjectionToken,\n  Input,\n  NgZone,\n  OnDestroy,\n  Optional,\n  Output,\n  ViewChild,\n  ViewContainerRef,\n  ViewEncapsulation,\n  ChangeDetectorRef,\n  Directive,\n  OnChanges,\n  SimpleChanges,\n  OnInit,\n  inject,\n} from '@angular/core';\nimport {CanColor, DateAdapter, mixinColor, ThemePalette} from '@angular/material/core';\nimport {AnimationEvent} from '@angular/animations';\nimport {merge, Subject, Observable, Subscription} from 'rxjs';\nimport {filter, take} from 'rxjs/operators';\nimport {_getFocusedElementPierceShadowDom} from '@angular/cdk/platform';\nimport {MatCalendar, MatCalendarView} from './calendar';\nimport {matDatepickerAnimations} from './datepicker-animations';\nimport {createMissingDateImplError} from './datepicker-errors';\nimport {MatCalendarUserEvent, MatCalendarCellClassFunction} from './calendar-body';\nimport {DateFilterFn} from './datepicker-input-base';\nimport {\n  ExtractDateTypeFromSelection,\n  MatDateSelectionModel,\n  DateRange,\n} from './date-selection-model';\nimport {\n  MAT_DATE_RANGE_SELECTION_STRATEGY,\n  MatDateRangeSelectionStrategy,\n} from './date-range-selection-strategy';\nimport {MatDatepickerIntl} from './datepicker-intl';\nimport {DOCUMENT} from '@angular/common';\n\n/** Used to generate a unique ID for each datepicker instance. */\nlet datepickerUid = 0;\n\n/** Injection token that determines the scroll handling while the calendar is open. */\nexport const MAT_DATEPICKER_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'mat-datepicker-scroll-strategy',\n);\n\n/** @docs-private */\nexport function MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy {\n  return () => overlay.scrollStrategies.reposition();\n}\n\n/** Possible positions for the datepicker dropdown along the X axis. */\nexport type DatepickerDropdownPositionX = 'start' | 'end';\n\n/** Possible positions for the datepicker dropdown along the Y axis. */\nexport type DatepickerDropdownPositionY = 'above' | 'below';\n\n/** @docs-private */\nexport const MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n  provide: MAT_DATEPICKER_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY,\n};\n\n// Boilerplate for applying mixins to MatDatepickerContent.\n/** @docs-private */\nconst _MatDatepickerContentBase = mixinColor(\n  class {\n    constructor(public _elementRef: ElementRef) {}\n  },\n);\n\n/**\n * Component used as the content for the datepicker overlay. We use this instead of using\n * MatCalendar directly as the content so we can control the initial focus. This also gives us a\n * place to put additional features of the overlay that are not part of the calendar itself in the\n * future. (e.g. confirmation buttons).\n * @docs-private\n */\n@Component({\n  selector: 'mat-datepicker-content',\n  templateUrl: 'datepicker-content.html',\n  styleUrls: ['datepicker-content.css'],\n  host: {\n    'class': 'mat-datepicker-content',\n    '[@transformPanel]': '_animationState',\n    '(@transformPanel.start)': '_handleAnimationEvent($event)',\n    '(@transformPanel.done)': '_handleAnimationEvent($event)',\n    '[class.mat-datepicker-content-touch]': 'datepicker.touchUi',\n  },\n  animations: [matDatepickerAnimations.transformPanel, matDatepickerAnimations.fadeInCalendar],\n  exportAs: 'matDatepickerContent',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  inputs: ['color'],\n})\nexport class MatDatepickerContent<S, D = ExtractDateTypeFromSelection<S>>\n  extends _MatDatepickerContentBase\n  implements OnInit, AfterViewInit, OnDestroy, CanColor\n{\n  private _subscriptions = new Subscription();\n  private _model: MatDateSelectionModel<S, D>;\n  /** Reference to the internal calendar component. */\n  @ViewChild(MatCalendar) _calendar: MatCalendar<D>;\n\n  /** Reference to the datepicker that created the overlay. */\n  datepicker: MatDatepickerBase<any, S, D>;\n\n  /** Start of the comparison range. */\n  comparisonStart: D | null;\n\n  /** End of the comparison range. */\n  comparisonEnd: D | null;\n\n  /** ARIA Accessible name of the `<input matStartDate/>` */\n  startDateAccessibleName: string | null;\n\n  /** ARIA Accessible name of the `<input matEndDate/>` */\n  endDateAccessibleName: string | null;\n\n  /** Whether the datepicker is above or below the input. */\n  _isAbove: boolean;\n\n  /** Current state of the animation. */\n  _animationState: 'enter-dropdown' | 'enter-dialog' | 'void';\n\n  /** Emits when an animation has finished. */\n  readonly _animationDone = new Subject<void>();\n\n  /** Whether there is an in-progress animation. */\n  _isAnimating = false;\n\n  /** Text for the close button. */\n  _closeButtonText: string;\n\n  /** Whether the close button currently has focus. */\n  _closeButtonFocused: boolean;\n\n  /** Portal with projected action buttons. */\n  _actionsPortal: TemplatePortal | null = null;\n\n  /** Id of the label for the `role=\"dialog\"` element. */\n  _dialogLabelId: string | null;\n\n  constructor(\n    elementRef: ElementRef,\n    private _changeDetectorRef: ChangeDetectorRef,\n    private _globalModel: MatDateSelectionModel<S, D>,\n    private _dateAdapter: DateAdapter<D>,\n    @Optional()\n    @Inject(MAT_DATE_RANGE_SELECTION_STRATEGY)\n    private _rangeSelectionStrategy: MatDateRangeSelectionStrategy<D>,\n    intl: MatDatepickerIntl,\n  ) {\n    super(elementRef);\n    this._closeButtonText = intl.closeCalendarLabel;\n  }\n\n  ngOnInit() {\n    this._animationState = this.datepicker.touchUi ? 'enter-dialog' : 'enter-dropdown';\n  }\n\n  ngAfterViewInit() {\n    this._subscriptions.add(\n      this.datepicker.stateChanges.subscribe(() => {\n        this._changeDetectorRef.markForCheck();\n      }),\n    );\n    this._calendar.focusActiveCell();\n  }\n\n  ngOnDestroy() {\n    this._subscriptions.unsubscribe();\n    this._animationDone.complete();\n  }\n\n  _handleUserSelection(event: MatCalendarUserEvent<D | null>) {\n    const selection = this._model.selection;\n    const value = event.value;\n    const isRange = selection instanceof DateRange;\n\n    // If we're selecting a range and we have a selection strategy, always pass the value through\n    // there. Otherwise don't assign null values to the model, unless we're selecting a range.\n    // A null value when picking a range means that the user cancelled the selection (e.g. by\n    // pressing escape), whereas when selecting a single value it means that the value didn't\n    // change. This isn't very intuitive, but it's here for backwards-compatibility.\n    if (isRange && this._rangeSelectionStrategy) {\n      const newSelection = this._rangeSelectionStrategy.selectionFinished(\n        value,\n        selection as unknown as DateRange<D>,\n        event.event,\n      );\n      this._model.updateSelection(newSelection as unknown as S, this);\n    } else if (\n      value &&\n      (isRange || !this._dateAdapter.sameDate(value, selection as unknown as D))\n    ) {\n      this._model.add(value);\n    }\n\n    // Delegate closing the overlay to the actions.\n    if ((!this._model || this._model.isComplete()) && !this._actionsPortal) {\n      this.datepicker.close();\n    }\n  }\n\n  _handleUserDragDrop(event: MatCalendarUserEvent<DateRange<D>>) {\n    this._model.updateSelection(event.value as unknown as S, this);\n  }\n\n  _startExitAnimation() {\n    this._animationState = 'void';\n    this._changeDetectorRef.markForCheck();\n  }\n\n  _handleAnimationEvent(event: AnimationEvent) {\n    this._isAnimating = event.phaseName === 'start';\n\n    if (!this._isAnimating) {\n      this._animationDone.next();\n    }\n  }\n\n  _getSelected() {\n    return this._model.selection as unknown as D | DateRange<D> | null;\n  }\n\n  /** Applies the current pending selection to the global model. */\n  _applyPendingSelection() {\n    if (this._model !== this._globalModel) {\n      this._globalModel.updateSelection(this._model.selection, this);\n    }\n  }\n\n  /**\n   * Assigns a new portal containing the datepicker actions.\n   * @param portal Portal with the actions to be assigned.\n   * @param forceRerender Whether a re-render of the portal should be triggered. This isn't\n   * necessary if the portal is assigned during initialization, but it may be required if it's\n   * added at a later point.\n   */\n  _assignActions(portal: TemplatePortal<any> | null, forceRerender: boolean) {\n    // If we have actions, clone the model so that we have the ability to cancel the selection,\n    // otherwise update the global model directly. Note that we want to assign this as soon as\n    // possible, but `_actionsPortal` isn't available in the constructor so we do it in `ngOnInit`.\n    this._model = portal ? this._globalModel.clone() : this._globalModel;\n    this._actionsPortal = portal;\n\n    if (forceRerender) {\n      this._changeDetectorRef.detectChanges();\n    }\n  }\n}\n\n/** Form control that can be associated with a datepicker. */\nexport interface MatDatepickerControl<D> {\n  getStartValue(): D | null;\n  getThemePalette(): ThemePalette;\n  min: D | null;\n  max: D | null;\n  disabled: boolean;\n  dateFilter: DateFilterFn<D>;\n  getConnectedOverlayOrigin(): ElementRef;\n  getOverlayLabelId(): string | null;\n  stateChanges: Observable<void>;\n}\n\n/** A datepicker that can be attached to a {@link MatDatepickerControl}. */\nexport interface MatDatepickerPanel<\n  C extends MatDatepickerControl<D>,\n  S,\n  D = ExtractDateTypeFromSelection<S>,\n> {\n  /** Stream that emits whenever the date picker is closed. */\n  closedStream: EventEmitter<void>;\n  /** Color palette to use on the datepicker's calendar. */\n  color: ThemePalette;\n  /** The input element the datepicker is associated with. */\n  datepickerInput: C;\n  /** Whether the datepicker pop-up should be disabled. */\n  disabled: boolean;\n  /** The id for the datepicker's calendar. */\n  id: string;\n  /** Whether the datepicker is open. */\n  opened: boolean;\n  /** Stream that emits whenever the date picker is opened. */\n  openedStream: EventEmitter<void>;\n  /** Emits when the datepicker's state changes. */\n  stateChanges: Subject<void>;\n  /** Opens the datepicker. */\n  open(): void;\n  /** Register an input with the datepicker. */\n  registerInput(input: C): MatDateSelectionModel<S, D>;\n}\n\n/** Base class for a datepicker. */\n@Directive()\nexport abstract class MatDatepickerBase<\n  C extends MatDatepickerControl<D>,\n  S,\n  D = ExtractDateTypeFromSelection<S>,\n> implements MatDatepickerPanel<C, S, D>, OnDestroy, OnChanges\n{\n  private _scrollStrategy: () => ScrollStrategy;\n  private _inputStateChanges = Subscription.EMPTY;\n  private _document = inject(DOCUMENT);\n\n  /** An input indicating the type of the custom header component for the calendar, if set. */\n  @Input() calendarHeaderComponent: ComponentType<any>;\n\n  /** The date to open the calendar to initially. */\n  @Input()\n  get startAt(): D | null {\n    // If an explicit startAt is set we start there, otherwise we start at whatever the currently\n    // selected value is.\n    return this._startAt || (this.datepickerInput ? this.datepickerInput.getStartValue() : null);\n  }\n  set startAt(value: D | null) {\n    this._startAt = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n  }\n  private _startAt: D | null;\n\n  /** The view that the calendar should start in. */\n  @Input() startView: 'month' | 'year' | 'multi-year' = 'month';\n\n  /** Color palette to use on the datepicker's calendar. */\n  @Input()\n  get color(): ThemePalette {\n    return (\n      this._color || (this.datepickerInput ? this.datepickerInput.getThemePalette() : undefined)\n    );\n  }\n  set color(value: ThemePalette) {\n    this._color = value;\n  }\n  _color: ThemePalette;\n\n  /**\n   * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather\n   * than a dropdown and elements have more padding to allow for bigger touch targets.\n   */\n  @Input()\n  get touchUi(): boolean {\n    return this._touchUi;\n  }\n  set touchUi(value: BooleanInput) {\n    this._touchUi = coerceBooleanProperty(value);\n  }\n  private _touchUi = false;\n\n  /** Whether the datepicker pop-up should be disabled. */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled === undefined && this.datepickerInput\n      ? this.datepickerInput.disabled\n      : !!this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    const newValue = coerceBooleanProperty(value);\n\n    if (newValue !== this._disabled) {\n      this._disabled = newValue;\n      this.stateChanges.next(undefined);\n    }\n  }\n  private _disabled: boolean;\n\n  /** Preferred position of the datepicker in the X axis. */\n  @Input()\n  xPosition: DatepickerDropdownPositionX = 'start';\n\n  /** Preferred position of the datepicker in the Y axis. */\n  @Input()\n  yPosition: DatepickerDropdownPositionY = 'below';\n\n  /**\n   * Whether to restore focus to the previously-focused element when the calendar is closed.\n   * Note that automatic focus restoration is an accessibility feature and it is recommended that\n   * you provide your own equivalent, if you decide to turn it off.\n   */\n  @Input()\n  get restoreFocus(): boolean {\n    return this._restoreFocus;\n  }\n  set restoreFocus(value: BooleanInput) {\n    this._restoreFocus = coerceBooleanProperty(value);\n  }\n  private _restoreFocus = true;\n\n  /**\n   * Emits selected year in multiyear view.\n   * This doesn't imply a change on the selected date.\n   */\n  @Output() readonly yearSelected: EventEmitter<D> = new EventEmitter<D>();\n\n  /**\n   * Emits selected month in year view.\n   * This doesn't imply a change on the selected date.\n   */\n  @Output() readonly monthSelected: EventEmitter<D> = new EventEmitter<D>();\n\n  /**\n   * Emits when the current view changes.\n   */\n  @Output() readonly viewChanged: EventEmitter<MatCalendarView> = new EventEmitter<MatCalendarView>(\n    true,\n  );\n\n  /** Function that can be used to add custom CSS classes to dates. */\n  @Input() dateClass: MatCalendarCellClassFunction<D>;\n\n  /** Emits when the datepicker has been opened. */\n  @Output('opened') readonly openedStream = new EventEmitter<void>();\n\n  /** Emits when the datepicker has been closed. */\n  @Output('closed') readonly closedStream = new EventEmitter<void>();\n\n  /**\n   * Classes to be passed to the date picker panel.\n   * Supports string and string array values, similar to `ngClass`.\n   */\n  @Input()\n  get panelClass(): string | string[] {\n    return this._panelClass;\n  }\n  set panelClass(value: string | string[]) {\n    this._panelClass = coerceStringArray(value);\n  }\n  private _panelClass: string[];\n\n  /** Whether the calendar is open. */\n  @Input()\n  get opened(): boolean {\n    return this._opened;\n  }\n  set opened(value: BooleanInput) {\n    coerceBooleanProperty(value) ? this.open() : this.close();\n  }\n  private _opened = false;\n\n  /** The id for the datepicker calendar. */\n  id: string = `mat-datepicker-${datepickerUid++}`;\n\n  /** The minimum selectable date. */\n  _getMinDate(): D | null {\n    return this.datepickerInput && this.datepickerInput.min;\n  }\n\n  /** The maximum selectable date. */\n  _getMaxDate(): D | null {\n    return this.datepickerInput && this.datepickerInput.max;\n  }\n\n  _getDateFilter(): DateFilterFn<D> {\n    return this.datepickerInput && this.datepickerInput.dateFilter;\n  }\n\n  /** A reference to the overlay into which we've rendered the calendar. */\n  private _overlayRef: OverlayRef | null;\n\n  /** Reference to the component instance rendered in the overlay. */\n  private _componentRef: ComponentRef<MatDatepickerContent<S, D>> | null;\n\n  /** The element that was focused before the datepicker was opened. */\n  private _focusedElementBeforeOpen: HTMLElement | null = null;\n\n  /** Unique class that will be added to the backdrop so that the test harnesses can look it up. */\n  private _backdropHarnessClass = `${this.id}-backdrop`;\n\n  /** Currently-registered actions portal. */\n  private _actionsPortal: TemplatePortal | null;\n\n  /** The input element this datepicker is associated with. */\n  datepickerInput: C;\n\n  /** Emits when the datepicker's state changes. */\n  readonly stateChanges = new Subject<void>();\n\n  constructor(\n    private _overlay: Overlay,\n    private _ngZone: NgZone,\n    private _viewContainerRef: ViewContainerRef,\n    @Inject(MAT_DATEPICKER_SCROLL_STRATEGY) scrollStrategy: any,\n    @Optional() private _dateAdapter: DateAdapter<D>,\n    @Optional() private _dir: Directionality,\n    private _model: MatDateSelectionModel<S, D>,\n  ) {\n    if (!this._dateAdapter && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw createMissingDateImplError('DateAdapter');\n    }\n\n    this._scrollStrategy = scrollStrategy;\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    const positionChange = changes['xPosition'] || changes['yPosition'];\n\n    if (positionChange && !positionChange.firstChange && this._overlayRef) {\n      const positionStrategy = this._overlayRef.getConfig().positionStrategy;\n\n      if (positionStrategy instanceof FlexibleConnectedPositionStrategy) {\n        this._setConnectedPositions(positionStrategy);\n\n        if (this.opened) {\n          this._overlayRef.updatePosition();\n        }\n      }\n    }\n\n    this.stateChanges.next(undefined);\n  }\n\n  ngOnDestroy() {\n    this._destroyOverlay();\n    this.close();\n    this._inputStateChanges.unsubscribe();\n    this.stateChanges.complete();\n  }\n\n  /** Selects the given date */\n  select(date: D): void {\n    this._model.add(date);\n  }\n\n  /** Emits the selected year in multiyear view */\n  _selectYear(normalizedYear: D): void {\n    this.yearSelected.emit(normalizedYear);\n  }\n\n  /** Emits selected month in year view */\n  _selectMonth(normalizedMonth: D): void {\n    this.monthSelected.emit(normalizedMonth);\n  }\n\n  /** Emits changed view */\n  _viewChanged(view: MatCalendarView): void {\n    this.viewChanged.emit(view);\n  }\n\n  /**\n   * Register an input with this datepicker.\n   * @param input The datepicker input to register with this datepicker.\n   * @returns Selection model that the input should hook itself up to.\n   */\n  registerInput(input: C): MatDateSelectionModel<S, D> {\n    if (this.datepickerInput && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('A MatDatepicker can only be associated with a single input.');\n    }\n    this._inputStateChanges.unsubscribe();\n    this.datepickerInput = input;\n    this._inputStateChanges = input.stateChanges.subscribe(() => this.stateChanges.next(undefined));\n    return this._model;\n  }\n\n  /**\n   * Registers a portal containing action buttons with the datepicker.\n   * @param portal Portal to be registered.\n   */\n  registerActions(portal: TemplatePortal): void {\n    if (this._actionsPortal && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('A MatDatepicker can only be associated with a single actions row.');\n    }\n    this._actionsPortal = portal;\n    this._componentRef?.instance._assignActions(portal, true);\n  }\n\n  /**\n   * Removes a portal containing action buttons from the datepicker.\n   * @param portal Portal to be removed.\n   */\n  removeActions(portal: TemplatePortal): void {\n    if (portal === this._actionsPortal) {\n      this._actionsPortal = null;\n      this._componentRef?.instance._assignActions(null, true);\n    }\n  }\n\n  /** Open the calendar. */\n  open(): void {\n    // Skip reopening if there's an in-progress animation to avoid overlapping\n    // sequences which can cause \"changed after checked\" errors. See #25837.\n    if (this._opened || this.disabled || this._componentRef?.instance._isAnimating) {\n      return;\n    }\n\n    if (!this.datepickerInput && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('Attempted to open an MatDatepicker with no associated input.');\n    }\n\n    this._focusedElementBeforeOpen = _getFocusedElementPierceShadowDom();\n    this._openOverlay();\n    this._opened = true;\n    this.openedStream.emit();\n  }\n\n  /** Close the calendar. */\n  close(): void {\n    // Skip reopening if there's an in-progress animation to avoid overlapping\n    // sequences which can cause \"changed after checked\" errors. See #25837.\n    if (!this._opened || this._componentRef?.instance._isAnimating) {\n      return;\n    }\n\n    const canRestoreFocus =\n      this._restoreFocus &&\n      this._focusedElementBeforeOpen &&\n      typeof this._focusedElementBeforeOpen.focus === 'function';\n\n    const completeClose = () => {\n      // The `_opened` could've been reset already if\n      // we got two events in quick succession.\n      if (this._opened) {\n        this._opened = false;\n        this.closedStream.emit();\n      }\n    };\n\n    if (this._componentRef) {\n      const {instance, location} = this._componentRef;\n      instance._startExitAnimation();\n      instance._animationDone.pipe(take(1)).subscribe(() => {\n        const activeElement = this._document.activeElement;\n\n        // Since we restore focus after the exit animation, we have to check that\n        // the user didn't move focus themselves inside the `close` handler.\n        if (\n          canRestoreFocus &&\n          (!activeElement ||\n            activeElement === this._document.activeElement ||\n            location.nativeElement.contains(activeElement))\n        ) {\n          this._focusedElementBeforeOpen!.focus();\n        }\n\n        this._focusedElementBeforeOpen = null;\n        this._destroyOverlay();\n      });\n    }\n\n    if (canRestoreFocus) {\n      // Because IE moves focus asynchronously, we can't count on it being restored before we've\n      // marked the datepicker as closed. If the event fires out of sequence and the element that\n      // we're refocusing opens the datepicker on focus, the user could be stuck with not being\n      // able to close the calendar at all. We work around it by making the logic, that marks\n      // the datepicker as closed, async as well.\n      setTimeout(completeClose);\n    } else {\n      completeClose();\n    }\n  }\n\n  /** Applies the current pending selection on the overlay to the model. */\n  _applyPendingSelection() {\n    this._componentRef?.instance?._applyPendingSelection();\n  }\n\n  /** Forwards relevant values from the datepicker to the datepicker content inside the overlay. */\n  protected _forwardContentValues(instance: MatDatepickerContent<S, D>) {\n    instance.datepicker = this;\n    instance.color = this.color;\n    instance._dialogLabelId = this.datepickerInput.getOverlayLabelId();\n    instance._assignActions(this._actionsPortal, false);\n  }\n\n  /** Opens the overlay with the calendar. */\n  private _openOverlay(): void {\n    this._destroyOverlay();\n\n    const isDialog = this.touchUi;\n    const portal = new ComponentPortal<MatDatepickerContent<S, D>>(\n      MatDatepickerContent,\n      this._viewContainerRef,\n    );\n    const overlayRef = (this._overlayRef = this._overlay.create(\n      new OverlayConfig({\n        positionStrategy: isDialog ? this._getDialogStrategy() : this._getDropdownStrategy(),\n        hasBackdrop: true,\n        backdropClass: [\n          isDialog ? 'cdk-overlay-dark-backdrop' : 'mat-overlay-transparent-backdrop',\n          this._backdropHarnessClass,\n        ],\n        direction: this._dir,\n        scrollStrategy: isDialog ? this._overlay.scrollStrategies.block() : this._scrollStrategy(),\n        panelClass: `mat-datepicker-${isDialog ? 'dialog' : 'popup'}`,\n      }),\n    ));\n\n    this._getCloseStream(overlayRef).subscribe(event => {\n      if (event) {\n        event.preventDefault();\n      }\n      this.close();\n    });\n\n    // The `preventDefault` call happens inside the calendar as well, however focus moves into\n    // it inside a timeout which can give browsers a chance to fire off a keyboard event in-between\n    // that can scroll the page (see #24969). Always block default actions of arrow keys for the\n    // entire overlay so the page doesn't get scrolled by accident.\n    overlayRef.keydownEvents().subscribe(event => {\n      const keyCode = event.keyCode;\n\n      if (\n        keyCode === UP_ARROW ||\n        keyCode === DOWN_ARROW ||\n        keyCode === LEFT_ARROW ||\n        keyCode === RIGHT_ARROW ||\n        keyCode === PAGE_UP ||\n        keyCode === PAGE_DOWN\n      ) {\n        event.preventDefault();\n      }\n    });\n\n    this._componentRef = overlayRef.attach(portal);\n    this._forwardContentValues(this._componentRef.instance);\n\n    // Update the position once the calendar has rendered. Only relevant in dropdown mode.\n    if (!isDialog) {\n      this._ngZone.onStable.pipe(take(1)).subscribe(() => overlayRef.updatePosition());\n    }\n  }\n\n  /** Destroys the current overlay. */\n  private _destroyOverlay() {\n    if (this._overlayRef) {\n      this._overlayRef.dispose();\n      this._overlayRef = this._componentRef = null;\n    }\n  }\n\n  /** Gets a position strategy that will open the calendar as a dropdown. */\n  private _getDialogStrategy() {\n    return this._overlay.position().global().centerHorizontally().centerVertically();\n  }\n\n  /** Gets a position strategy that will open the calendar as a dropdown. */\n  private _getDropdownStrategy() {\n    const strategy = this._overlay\n      .position()\n      .flexibleConnectedTo(this.datepickerInput.getConnectedOverlayOrigin())\n      .withTransformOriginOn('.mat-datepicker-content')\n      .withFlexibleDimensions(false)\n      .withViewportMargin(8)\n      .withLockedPosition();\n\n    return this._setConnectedPositions(strategy);\n  }\n\n  /** Sets the positions of the datepicker in dropdown mode based on the current configuration. */\n  private _setConnectedPositions(strategy: FlexibleConnectedPositionStrategy) {\n    const primaryX = this.xPosition === 'end' ? 'end' : 'start';\n    const secondaryX = primaryX === 'start' ? 'end' : 'start';\n    const primaryY = this.yPosition === 'above' ? 'bottom' : 'top';\n    const secondaryY = primaryY === 'top' ? 'bottom' : 'top';\n\n    return strategy.withPositions([\n      {\n        originX: primaryX,\n        originY: secondaryY,\n        overlayX: primaryX,\n        overlayY: primaryY,\n      },\n      {\n        originX: primaryX,\n        originY: primaryY,\n        overlayX: primaryX,\n        overlayY: secondaryY,\n      },\n      {\n        originX: secondaryX,\n        originY: secondaryY,\n        overlayX: secondaryX,\n        overlayY: primaryY,\n      },\n      {\n        originX: secondaryX,\n        originY: primaryY,\n        overlayX: secondaryX,\n        overlayY: secondaryY,\n      },\n    ]);\n  }\n\n  /** Gets an observable that will emit when the overlay is supposed to be closed. */\n  private _getCloseStream(overlayRef: OverlayRef) {\n    const ctrlShiftMetaModifiers: ModifierKey[] = ['ctrlKey', 'shiftKey', 'metaKey'];\n    return merge(\n      overlayRef.backdropClick(),\n      overlayRef.detachments(),\n      overlayRef.keydownEvents().pipe(\n        filter(event => {\n          // Closing on alt + up is only valid when there's an input associated with the datepicker.\n          return (\n            (event.keyCode === ESCAPE && !hasModifierKey(event)) ||\n            (this.datepickerInput &&\n              hasModifierKey(event, 'altKey') &&\n              event.keyCode === UP_ARROW &&\n              ctrlShiftMetaModifiers.every(\n                (modifier: ModifierKey) => !hasModifierKey(event, modifier),\n              ))\n          );\n        }),\n      ),\n    );\n  }\n}\n", "<div\n  cdkTrapFocus\n  role=\"dialog\"\n  [attr.aria-modal]=\"true\"\n  [attr.aria-labelledby]=\"_dialogLabelId ?? undefined\"\n  class=\"mat-datepicker-content-container\"\n  [class.mat-datepicker-content-container-with-custom-header]=\"datepicker.calendarHeaderComponent\"\n  [class.mat-datepicker-content-container-with-actions]=\"_actionsPortal\">\n  <mat-calendar\n    [id]=\"datepicker.id\"\n    [ngClass]=\"datepicker.panelClass\"\n    [startAt]=\"datepicker.startAt\"\n    [startView]=\"datepicker.startView\"\n    [minDate]=\"datepicker._getMinDate()\"\n    [maxDate]=\"datepicker._getMaxDate()\"\n    [dateFilter]=\"datepicker._getDateFilter()\"\n    [headerComponent]=\"datepicker.calendarHeaderComponent\"\n    [selected]=\"_getSelected()\"\n    [dateClass]=\"datepicker.dateClass\"\n    [comparisonStart]=\"comparisonStart\"\n    [comparisonEnd]=\"comparisonEnd\"\n    [@fadeInCalendar]=\"'enter'\"\n    [startDateAccessibleName]=\"startDateAccessibleName\"\n    [endDateAccessibleName]=\"endDateAccessibleName\"\n    (yearSelected)=\"datepicker._selectYear($event)\"\n    (monthSelected)=\"datepicker._selectMonth($event)\"\n    (viewChanged)=\"datepicker._viewChanged($event)\"\n    (_userSelection)=\"_handleUserSelection($event)\"\n    (_userDragDrop)=\"_handleUserDragDrop($event)\"></mat-calendar>\n\n  <ng-template [cdkPortalOutlet]=\"_actionsPortal\"></ng-template>\n\n  <!-- Invisible close button for screen reader users. -->\n  <button\n    type=\"button\"\n    mat-raised-button\n    [color]=\"color || 'primary'\"\n    class=\"mat-datepicker-close-button\"\n    [class.cdk-visually-hidden]=\"!_closeButtonFocused\"\n    (focus)=\"_closeButtonFocused = true\"\n    (blur)=\"_closeButtonFocused = false\"\n    (click)=\"datepicker.close()\">{{ _closeButtonText }}</button>\n</div>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy, Component, ViewEncapsulation} from '@angular/core';\nimport {MatDatepickerBase, MatDatepickerControl} from './datepicker-base';\nimport {MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER} from './date-selection-model';\n\n// TODO(mmalerba): We use a component instead of a directive here so the user can use implicit\n// template reference variables (e.g. #d vs #d=\"matDatepicker\"). We can change this to a directive\n// if angular adds support for `exportAs: '$implicit'` on directives.\n/** Component responsible for managing the datepicker popup/dialog. */\n@Component({\n  selector: 'mat-datepicker',\n  template: '',\n  exportAs: 'matDatepicker',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  providers: [\n    MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER,\n    {provide: MatDatepickerBase, useExisting: MatDatepicker},\n  ],\n})\nexport class MatDatepicker<D> extends MatDatepickerBase<MatDatepickerControl<D>, D | null, D> {}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {DOWN_ARROW, hasModifierKey, ModifierKey} from '@angular/cdk/keycodes';\nimport {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  Input,\n  OnDestroy,\n  Optional,\n  Output,\n  AfterViewInit,\n  OnChanges,\n  SimpleChanges,\n} from '@angular/core';\nimport {\n  AbstractControl,\n  ControlValueAccessor,\n  ValidationErrors,\n  Validator,\n  ValidatorFn,\n} from '@angular/forms';\nimport {DateAdapter, MAT_DATE_FORMATS, MatDateFormats, ThemePalette} from '@angular/material/core';\nimport {Subscription, Subject} from 'rxjs';\nimport {createMissingDateImplError} from './datepicker-errors';\nimport {\n  ExtractDateTypeFromSelection,\n  MatDateSelectionModel,\n  DateSelectionModelChange,\n} from './date-selection-model';\n\n/**\n * An event used for datepicker input and change events. We don't always have access to a native\n * input or change event because the event may have been triggered by the user clicking on the\n * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.\n */\nexport class MatDatepickerInputEvent<D, S = unknown> {\n  /** The new value for the target datepicker input. */\n  value: D | null;\n\n  constructor(\n    /** Reference to the datepicker input component that emitted the event. */\n    public target: MatDatepickerInputBase<S, D>,\n    /** Reference to the native input element associated with the datepicker input. */\n    public targetElement: HTMLElement,\n  ) {\n    this.value = this.target.value;\n  }\n}\n\n/** Function that can be used to filter out dates from a calendar. */\nexport type DateFilterFn<D> = (date: D | null) => boolean;\n\n/**\n * Partial representation of `MatFormField` that is used for backwards-compatibility\n * between the legacy and non-legacy variants.\n */\nexport interface _MatFormFieldPartial {\n  getConnectedOverlayOrigin(): ElementRef;\n  getLabelId(): string | null;\n  color: ThemePalette;\n  _elementRef: ElementRef;\n  _shouldLabelFloat(): boolean;\n  _hasFloatingLabel(): boolean;\n  _labelId: string;\n}\n\n/** Base class for datepicker inputs. */\n@Directive()\nexport abstract class MatDatepickerInputBase<S, D = ExtractDateTypeFromSelection<S>>\n  implements ControlValueAccessor, AfterViewInit, OnChanges, OnDestroy, Validator\n{\n  /** Whether the component has been initialized. */\n  private _isInitialized: boolean;\n\n  /** The value of the input. */\n  @Input()\n  get value(): D | null {\n    return this._model ? this._getValueFromModel(this._model.selection) : this._pendingValue;\n  }\n  set value(value: any) {\n    this._assignValueProgrammatically(value);\n  }\n  protected _model: MatDateSelectionModel<S, D> | undefined;\n\n  /** Whether the datepicker-input is disabled. */\n  @Input()\n  get disabled(): boolean {\n    return !!this._disabled || this._parentDisabled();\n  }\n  set disabled(value: BooleanInput) {\n    const newValue = coerceBooleanProperty(value);\n    const element = this._elementRef.nativeElement;\n\n    if (this._disabled !== newValue) {\n      this._disabled = newValue;\n      this.stateChanges.next(undefined);\n    }\n\n    // We need to null check the `blur` method, because it's undefined during SSR.\n    // In Ivy static bindings are invoked earlier, before the element is attached to the DOM.\n    // This can cause an error to be thrown in some browsers (IE/Edge) which assert that the\n    // element has been inserted.\n    if (newValue && this._isInitialized && element.blur) {\n      // Normally, native input elements automatically blur if they turn disabled. This behavior\n      // is problematic, because it would mean that it triggers another change detection cycle,\n      // which then causes a changed after checked error if the input element was focused before.\n      element.blur();\n    }\n  }\n  private _disabled: boolean;\n\n  /** Emits when a `change` event is fired on this `<input>`. */\n  @Output() readonly dateChange: EventEmitter<MatDatepickerInputEvent<D, S>> = new EventEmitter<\n    MatDatepickerInputEvent<D, S>\n  >();\n\n  /** Emits when an `input` event is fired on this `<input>`. */\n  @Output() readonly dateInput: EventEmitter<MatDatepickerInputEvent<D, S>> = new EventEmitter<\n    MatDatepickerInputEvent<D, S>\n  >();\n\n  /** Emits when the internal state has changed */\n  readonly stateChanges = new Subject<void>();\n\n  _onTouched = () => {};\n  _validatorOnChange = () => {};\n\n  private _cvaOnChange: (value: any) => void = () => {};\n  private _valueChangesSubscription = Subscription.EMPTY;\n  private _localeSubscription = Subscription.EMPTY;\n\n  /**\n   * Since the value is kept on the model which is assigned in an Input,\n   * we might get a value before we have a model. This property keeps track\n   * of the value until we have somewhere to assign it.\n   */\n  private _pendingValue: D | null;\n\n  /** The form control validator for whether the input parses. */\n  private _parseValidator: ValidatorFn = (): ValidationErrors | null => {\n    return this._lastValueValid\n      ? null\n      : {'matDatepickerParse': {'text': this._elementRef.nativeElement.value}};\n  };\n\n  /** The form control validator for the date filter. */\n  private _filterValidator: ValidatorFn = (control: AbstractControl): ValidationErrors | null => {\n    const controlValue = this._dateAdapter.getValidDateOrNull(\n      this._dateAdapter.deserialize(control.value),\n    );\n    return !controlValue || this._matchesFilter(controlValue)\n      ? null\n      : {'matDatepickerFilter': true};\n  };\n\n  /** The form control validator for the min date. */\n  private _minValidator: ValidatorFn = (control: AbstractControl): ValidationErrors | null => {\n    const controlValue = this._dateAdapter.getValidDateOrNull(\n      this._dateAdapter.deserialize(control.value),\n    );\n    const min = this._getMinDate();\n    return !min || !controlValue || this._dateAdapter.compareDate(min, controlValue) <= 0\n      ? null\n      : {'matDatepickerMin': {'min': min, 'actual': controlValue}};\n  };\n\n  /** The form control validator for the max date. */\n  private _maxValidator: ValidatorFn = (control: AbstractControl): ValidationErrors | null => {\n    const controlValue = this._dateAdapter.getValidDateOrNull(\n      this._dateAdapter.deserialize(control.value),\n    );\n    const max = this._getMaxDate();\n    return !max || !controlValue || this._dateAdapter.compareDate(max, controlValue) >= 0\n      ? null\n      : {'matDatepickerMax': {'max': max, 'actual': controlValue}};\n  };\n\n  /** Gets the base validator functions. */\n  protected _getValidators(): ValidatorFn[] {\n    return [this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator];\n  }\n\n  /** Gets the minimum date for the input. Used for validation. */\n  abstract _getMinDate(): D | null;\n\n  /** Gets the maximum date for the input. Used for validation. */\n  abstract _getMaxDate(): D | null;\n\n  /** Gets the date filter function. Used for validation. */\n  protected abstract _getDateFilter(): DateFilterFn<D> | undefined;\n\n  /** Registers a date selection model with the input. */\n  _registerModel(model: MatDateSelectionModel<S, D>): void {\n    this._model = model;\n    this._valueChangesSubscription.unsubscribe();\n\n    if (this._pendingValue) {\n      this._assignValue(this._pendingValue);\n    }\n\n    this._valueChangesSubscription = this._model.selectionChanged.subscribe(event => {\n      if (this._shouldHandleChangeEvent(event)) {\n        const value = this._getValueFromModel(event.selection);\n        this._lastValueValid = this._isValidValue(value);\n        this._cvaOnChange(value);\n        this._onTouched();\n        this._formatValue(value);\n        this.dateInput.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n        this.dateChange.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n      }\n    });\n  }\n\n  /** Opens the popup associated with the input. */\n  protected abstract _openPopup(): void;\n\n  /** Assigns a value to the input's model. */\n  protected abstract _assignValueToModel(model: D | null): void;\n\n  /** Converts a value from the model into a native value for the input. */\n  protected abstract _getValueFromModel(modelValue: S): D | null;\n\n  /** Combined form control validator for this input. */\n  protected abstract _validator: ValidatorFn | null;\n\n  /** Predicate that determines whether the input should handle a particular change event. */\n  protected abstract _shouldHandleChangeEvent(event: DateSelectionModelChange<S>): boolean;\n\n  /** Whether the last value set on the input was valid. */\n  protected _lastValueValid = false;\n\n  constructor(\n    protected _elementRef: ElementRef<HTMLInputElement>,\n    @Optional() public _dateAdapter: DateAdapter<D>,\n    @Optional() @Inject(MAT_DATE_FORMATS) private _dateFormats: MatDateFormats,\n  ) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n      if (!this._dateFormats) {\n        throw createMissingDateImplError('MAT_DATE_FORMATS');\n      }\n    }\n\n    // Update the displayed date when the locale changes.\n    this._localeSubscription = _dateAdapter.localeChanges.subscribe(() => {\n      this._assignValueProgrammatically(this.value);\n    });\n  }\n\n  ngAfterViewInit() {\n    this._isInitialized = true;\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (dateInputsHaveChanged(changes, this._dateAdapter)) {\n      this.stateChanges.next(undefined);\n    }\n  }\n\n  ngOnDestroy() {\n    this._valueChangesSubscription.unsubscribe();\n    this._localeSubscription.unsubscribe();\n    this.stateChanges.complete();\n  }\n\n  /** @docs-private */\n  registerOnValidatorChange(fn: () => void): void {\n    this._validatorOnChange = fn;\n  }\n\n  /** @docs-private */\n  validate(c: AbstractControl): ValidationErrors | null {\n    return this._validator ? this._validator(c) : null;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  writeValue(value: D): void {\n    this._assignValueProgrammatically(value);\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnChange(fn: (value: any) => void): void {\n    this._cvaOnChange = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnTouched(fn: () => void): void {\n    this._onTouched = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  _onKeydown(event: KeyboardEvent) {\n    const ctrlShiftMetaModifiers: ModifierKey[] = ['ctrlKey', 'shiftKey', 'metaKey'];\n    const isAltDownArrow =\n      hasModifierKey(event, 'altKey') &&\n      event.keyCode === DOWN_ARROW &&\n      ctrlShiftMetaModifiers.every((modifier: ModifierKey) => !hasModifierKey(event, modifier));\n\n    if (isAltDownArrow && !this._elementRef.nativeElement.readOnly) {\n      this._openPopup();\n      event.preventDefault();\n    }\n  }\n\n  _onInput(value: string) {\n    const lastValueWasValid = this._lastValueValid;\n    let date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);\n    this._lastValueValid = this._isValidValue(date);\n    date = this._dateAdapter.getValidDateOrNull(date);\n    const hasChanged = !this._dateAdapter.sameDate(date, this.value);\n\n    // We need to fire the CVA change event for all\n    // nulls, otherwise the validators won't run.\n    if (!date || hasChanged) {\n      this._cvaOnChange(date);\n    } else {\n      // Call the CVA change handler for invalid values\n      // since this is what marks the control as dirty.\n      if (value && !this.value) {\n        this._cvaOnChange(date);\n      }\n\n      if (lastValueWasValid !== this._lastValueValid) {\n        this._validatorOnChange();\n      }\n    }\n\n    if (hasChanged) {\n      this._assignValue(date);\n      this.dateInput.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n    }\n  }\n\n  _onChange() {\n    this.dateChange.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n  }\n\n  /** Handles blur events on the input. */\n  _onBlur() {\n    // Reformat the input only if we have a valid value.\n    if (this.value) {\n      this._formatValue(this.value);\n    }\n\n    this._onTouched();\n  }\n\n  /** Formats a value and sets it on the input element. */\n  protected _formatValue(value: D | null) {\n    this._elementRef.nativeElement.value =\n      value != null ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';\n  }\n\n  /** Assigns a value to the model. */\n  private _assignValue(value: D | null) {\n    // We may get some incoming values before the model was\n    // assigned. Save the value so that we can assign it later.\n    if (this._model) {\n      this._assignValueToModel(value);\n      this._pendingValue = null;\n    } else {\n      this._pendingValue = value;\n    }\n  }\n\n  /** Whether a value is considered valid. */\n  private _isValidValue(value: D | null): boolean {\n    return !value || this._dateAdapter.isValid(value);\n  }\n\n  /**\n   * Checks whether a parent control is disabled. This is in place so that it can be overridden\n   * by inputs extending this one which can be placed inside of a group that can be disabled.\n   */\n  protected _parentDisabled() {\n    return false;\n  }\n\n  /** Programmatically assigns a value to the input. */\n  protected _assignValueProgrammatically(value: D | null) {\n    value = this._dateAdapter.deserialize(value);\n    this._lastValueValid = this._isValidValue(value);\n    value = this._dateAdapter.getValidDateOrNull(value);\n    this._assignValue(value);\n    this._formatValue(value);\n  }\n\n  /** Gets whether a value matches the current date filter. */\n  _matchesFilter(value: D | null): boolean {\n    const filter = this._getDateFilter();\n    return !filter || filter(value);\n  }\n}\n\n/**\n * Checks whether the `SimpleChanges` object from an `ngOnChanges`\n * callback has any changes, accounting for date objects.\n */\nexport function dateInputsHaveChanged(\n  changes: SimpleChanges,\n  adapter: DateAdapter<unknown>,\n): boolean {\n  const keys = Object.keys(changes);\n\n  for (let key of keys) {\n    const {previousValue, currentValue} = changes[key];\n\n    if (adapter.isDateInstance(previousValue) && adapter.isDateInstance(currentValue)) {\n      if (!adapter.sameDate(previousValue, currentValue)) {\n        return true;\n      }\n    } else {\n      return true;\n    }\n  }\n\n  return false;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, forwardRef, Inject, Input, OnDestroy, Optional} from '@angular/core';\nimport {NG_VALIDATORS, NG_VALUE_ACCESSOR, ValidatorFn, Validators} from '@angular/forms';\nimport {DateAdapter, MAT_DATE_FORMATS, MatDateFormats, ThemePalette} from '@angular/material/core';\nimport {MAT_FORM_FIELD} from '@angular/material/form-field';\nimport {MAT_INPUT_VALUE_ACCESSOR} from '@angular/material/input';\nimport {Subscription} from 'rxjs';\nimport {MatDatepickerInputBase, DateFilterFn, _MatFormFieldPartial} from './datepicker-input-base';\nimport {MatDatepickerControl, MatDatepickerPanel} from './datepicker-base';\nimport {DateSelectionModelChange} from './date-selection-model';\n\n/** @docs-private */\nexport const MAT_DATEPICKER_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatDatepickerInput),\n  multi: true,\n};\n\n/** @docs-private */\nexport const MAT_DATEPICKER_VALIDATORS: any = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MatDatepickerInput),\n  multi: true,\n};\n\n/** Directive used to connect an input to a MatDatepicker. */\n@Directive({\n  selector: 'input[matDatepicker]',\n  providers: [\n    MAT_DATEPICKER_VALUE_ACCESSOR,\n    MAT_DATEPICKER_VALIDATORS,\n    {provide: MAT_INPUT_VALUE_ACCESSOR, useExisting: MatDatepickerInput},\n  ],\n  host: {\n    'class': 'mat-datepicker-input',\n    '[attr.aria-haspopup]': '_datepicker ? \"dialog\" : null',\n    '[attr.aria-owns]': '(_datepicker?.opened && _datepicker.id) || null',\n    '[attr.min]': 'min ? _dateAdapter.toIso8601(min) : null',\n    '[attr.max]': 'max ? _dateAdapter.toIso8601(max) : null',\n    // Used by the test harness to tie this input to its calendar. We can't depend on\n    // `aria-owns` for this, because it's only defined while the calendar is open.\n    '[attr.data-mat-calendar]': '_datepicker ? _datepicker.id : null',\n    '[disabled]': 'disabled',\n    '(input)': '_onInput($event.target.value)',\n    '(change)': '_onChange()',\n    '(blur)': '_onBlur()',\n    '(keydown)': '_onKeydown($event)',\n  },\n  exportAs: 'matDatepickerInput',\n})\nexport class MatDatepickerInput<D>\n  extends MatDatepickerInputBase<D | null, D>\n  implements MatDatepickerControl<D | null>, OnDestroy\n{\n  private _closedSubscription = Subscription.EMPTY;\n\n  /** The datepicker that this input is associated with. */\n  @Input()\n  set matDatepicker(datepicker: MatDatepickerPanel<MatDatepickerControl<D>, D | null, D>) {\n    if (datepicker) {\n      this._datepicker = datepicker;\n      this._closedSubscription = datepicker.closedStream.subscribe(() => this._onTouched());\n      this._registerModel(datepicker.registerInput(this));\n    }\n  }\n  _datepicker: MatDatepickerPanel<MatDatepickerControl<D>, D | null, D>;\n\n  /** The minimum valid date. */\n  @Input()\n  get min(): D | null {\n    return this._min;\n  }\n  set min(value: D | null) {\n    const validValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n\n    if (!this._dateAdapter.sameDate(validValue, this._min)) {\n      this._min = validValue;\n      this._validatorOnChange();\n    }\n  }\n  private _min: D | null;\n\n  /** The maximum valid date. */\n  @Input()\n  get max(): D | null {\n    return this._max;\n  }\n  set max(value: D | null) {\n    const validValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n\n    if (!this._dateAdapter.sameDate(validValue, this._max)) {\n      this._max = validValue;\n      this._validatorOnChange();\n    }\n  }\n  private _max: D | null;\n\n  /** Function that can be used to filter out dates within the datepicker. */\n  @Input('matDatepickerFilter')\n  get dateFilter() {\n    return this._dateFilter;\n  }\n  set dateFilter(value: DateFilterFn<D | null>) {\n    const wasMatchingValue = this._matchesFilter(this.value);\n    this._dateFilter = value;\n\n    if (this._matchesFilter(this.value) !== wasMatchingValue) {\n      this._validatorOnChange();\n    }\n  }\n  private _dateFilter: DateFilterFn<D | null>;\n\n  /** The combined form control validator for this input. */\n  protected _validator: ValidatorFn | null;\n\n  constructor(\n    elementRef: ElementRef<HTMLInputElement>,\n    @Optional() dateAdapter: DateAdapter<D>,\n    @Optional() @Inject(MAT_DATE_FORMATS) dateFormats: MatDateFormats,\n    @Optional() @Inject(MAT_FORM_FIELD) private _formField?: _MatFormFieldPartial,\n  ) {\n    super(elementRef, dateAdapter, dateFormats);\n    this._validator = Validators.compose(super._getValidators());\n  }\n\n  /**\n   * Gets the element that the datepicker popup should be connected to.\n   * @return The element to connect the popup to.\n   */\n  getConnectedOverlayOrigin(): ElementRef {\n    return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;\n  }\n\n  /** Gets the ID of an element that should be used a description for the calendar overlay. */\n  getOverlayLabelId(): string | null {\n    if (this._formField) {\n      return this._formField.getLabelId();\n    }\n\n    return this._elementRef.nativeElement.getAttribute('aria-labelledby');\n  }\n\n  /** Returns the palette used by the input's form field, if any. */\n  getThemePalette(): ThemePalette {\n    return this._formField ? this._formField.color : undefined;\n  }\n\n  /** Gets the value at which the calendar should start. */\n  getStartValue(): D | null {\n    return this.value;\n  }\n\n  override ngOnDestroy() {\n    super.ngOnDestroy();\n    this._closedSubscription.unsubscribe();\n  }\n\n  /** Opens the associated datepicker. */\n  protected _openPopup(): void {\n    if (this._datepicker) {\n      this._datepicker.open();\n    }\n  }\n\n  protected _getValueFromModel(modelValue: D | null): D | null {\n    return modelValue;\n  }\n\n  protected _assignValueToModel(value: D | null): void {\n    if (this._model) {\n      this._model.updateSelection(value, this);\n    }\n  }\n\n  /** Gets the input's minimum date. */\n  _getMinDate() {\n    return this._min;\n  }\n\n  /** Gets the input's maximum date. */\n  _getMaxDate() {\n    return this._max;\n  }\n\n  /** Gets the input's date filtering function. */\n  protected _getDateFilter() {\n    return this._dateFilter;\n  }\n\n  protected _shouldHandleChangeEvent(event: DateSelectionModelChange<D>) {\n    return event.source !== this;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {\n  AfterContentInit,\n  Attribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChild,\n  Directive,\n  Input,\n  OnChanges,\n  OnDestroy,\n  SimpleChanges,\n  ViewEncapsulation,\n  ViewChild,\n} from '@angular/core';\nimport {MatButton} from '@angular/material/button';\nimport {merge, Observable, of as observableOf, Subscription} from 'rxjs';\nimport {MatDatepickerIntl} from './datepicker-intl';\nimport {MatDatepickerControl, MatDatepickerPanel} from './datepicker-base';\n\n/** Can be used to override the icon of a `matDatepickerToggle`. */\n@Directive({\n  selector: '[matDatepickerToggleIcon]',\n})\nexport class MatDatepickerToggleIcon {}\n\n@Component({\n  selector: 'mat-datepicker-toggle',\n  templateUrl: 'datepicker-toggle.html',\n  styleUrls: ['datepicker-toggle.css'],\n  host: {\n    'class': 'mat-datepicker-toggle',\n    '[attr.tabindex]': 'null',\n    '[class.mat-datepicker-toggle-active]': 'datepicker && datepicker.opened',\n    '[class.mat-accent]': 'datepicker && datepicker.color === \"accent\"',\n    '[class.mat-warn]': 'datepicker && datepicker.color === \"warn\"',\n    // Used by the test harness to tie this toggle to its datepicker.\n    '[attr.data-mat-calendar]': 'datepicker ? datepicker.id : null',\n    // Bind the `click` on the host, rather than the inner `button`, so that we can call\n    // `stopPropagation` on it without affecting the user's `click` handlers. We need to stop\n    // it so that the input doesn't get focused automatically by the form field (See #21836).\n    '(click)': '_open($event)',\n  },\n  exportAs: 'matDatepickerToggle',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatDatepickerToggle<D> implements AfterContentInit, OnChanges, OnDestroy {\n  private _stateChanges = Subscription.EMPTY;\n\n  /** Datepicker instance that the button will toggle. */\n  @Input('for') datepicker: MatDatepickerPanel<MatDatepickerControl<any>, D>;\n\n  /** Tabindex for the toggle. */\n  @Input() tabIndex: number | null;\n\n  /** Screen-reader label for the button. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** Whether the toggle button is disabled. */\n  @Input()\n  get disabled(): boolean {\n    if (this._disabled === undefined && this.datepicker) {\n      return this.datepicker.disabled;\n    }\n\n    return !!this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n  }\n  private _disabled: boolean;\n\n  /** Whether ripples on the toggle should be disabled. */\n  @Input() disableRipple: boolean;\n\n  /** Custom icon set by the consumer. */\n  @ContentChild(MatDatepickerToggleIcon) _customIcon: MatDatepickerToggleIcon;\n\n  /** Underlying button element. */\n  @ViewChild('button') _button: MatButton;\n\n  constructor(\n    public _intl: MatDatepickerIntl,\n    private _changeDetectorRef: ChangeDetectorRef,\n    @Attribute('tabindex') defaultTabIndex: string,\n  ) {\n    const parsedTabIndex = Number(defaultTabIndex);\n    this.tabIndex = parsedTabIndex || parsedTabIndex === 0 ? parsedTabIndex : null;\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes['datepicker']) {\n      this._watchStateChanges();\n    }\n  }\n\n  ngOnDestroy() {\n    this._stateChanges.unsubscribe();\n  }\n\n  ngAfterContentInit() {\n    this._watchStateChanges();\n  }\n\n  _open(event: Event): void {\n    if (this.datepicker && !this.disabled) {\n      this.datepicker.open();\n      event.stopPropagation();\n    }\n  }\n\n  private _watchStateChanges() {\n    const datepickerStateChanged = this.datepicker ? this.datepicker.stateChanges : observableOf();\n    const inputStateChanged =\n      this.datepicker && this.datepicker.datepickerInput\n        ? this.datepicker.datepickerInput.stateChanges\n        : observableOf();\n    const datepickerToggled = this.datepicker\n      ? merge(this.datepicker.openedStream, this.datepicker.closedStream)\n      : observableOf();\n\n    this._stateChanges.unsubscribe();\n    this._stateChanges = merge(\n      this._intl.changes,\n      datepickerStateChanged as Observable<void>,\n      inputStateChanged,\n      datepickerToggled,\n    ).subscribe(() => this._changeDetectorRef.markForCheck());\n  }\n}\n", "<button\n  #button\n  mat-icon-button\n  type=\"button\"\n  [attr.aria-haspopup]=\"datepicker ? 'dialog' : null\"\n  [attr.aria-label]=\"ariaLabel || _intl.openCalendarLabel\"\n  [attr.tabindex]=\"disabled ? -1 : tabIndex\"\n  [disabled]=\"disabled\"\n  [disableRipple]=\"disableRipple\">\n\n  @if (!_customIcon) {\n    <svg\n      class=\"mat-datepicker-toggle-default-icon\"\n      viewBox=\"0 0 24 24\"\n      width=\"24px\"\n      height=\"24px\"\n      fill=\"currentColor\"\n      focusable=\"false\"\n      aria-hidden=\"true\">\n      <path d=\"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\"/>\n    </svg>\n  }\n\n  <ng-content select=\"[matDatepickerToggleIcon]\"></ng-content>\n</button>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// This file contains the `_computeAriaAccessibleName` function, which computes what the *expected*\n// ARIA accessible name would be for a given element. Implements a subset of ARIA specification\n// [Accessible Name and Description Computation 1.2](https://www.w3.org/TR/accname-1.2/).\n//\n// Specification accname-1.2 can be summarized by returning the result of the first method\n// available.\n//\n//  1. `aria-labelledby` attribute\n//     ```\n//       <!-- example using aria-labelledby-->\n//       <label id='label-id'>Start Date</label>\n//       <input aria-labelledby='label-id'/>\n//     ```\n//  2. `aria-label` attribute (e.g. `<input aria-label=\"Departure\"/>`)\n//  3. Label with `for`/`id`\n//     ```\n//       <!-- example using for/id -->\n//       <label for=\"current-node\">Label</label>\n//       <input id=\"current-node\"/>\n//     ```\n//  4. `placeholder` attribute (e.g. `<input placeholder=\"06/03/1990\"/>`)\n//  5. `title` attribute (e.g. `<input title=\"Check-In\"/>`)\n//  6. text content\n//     ```\n//       <!-- example using text content -->\n//       <label for=\"current-node\"><span>Departure</span> Date</label>\n//       <input id=\"current-node\"/>\n//     ```\n\n/**\n * Computes the *expected* ARIA accessible name for argument element based on [accname-1.2\n * specification](https://www.w3.org/TR/accname-1.2/). Implements a subset of accname-1.2,\n * and should only be used for the Datepicker's specific use case.\n *\n * Intended use:\n * This is not a general use implementation. Only implements the parts of accname-1.2 that are\n * required for the Datepicker's specific use case. This function is not intended for any other\n * use.\n *\n * Limitations:\n *  - Only covers the needs of `matStartDate` and `matEndDate`. Does not support other use cases.\n *  - See NOTES's in implementation for specific details on what parts of the accname-1.2\n *  specification are not implemented.\n *\n *  @param element {HTMLInputElement} native &lt;input/&gt; element of `matStartDate` or\n *  `matEndDate` component. Corresponds to the 'Root Element' from accname-1.2\n *\n *  @return expected ARIA accessible name of argument &lt;input/&gt;\n */\nexport function _computeAriaAccessibleName(\n  element: HTMLInputElement | HTMLTextAreaElement,\n): string {\n  return _computeAriaAccessibleNameInternal(element, true);\n}\n\n/**\n * Determine if argument node is an Element based on `nodeType` property. This function is safe to\n * use with server-side rendering.\n */\nfunction ssrSafeIsElement(node: Node): node is Element {\n  return node.nodeType === Node.ELEMENT_NODE;\n}\n\n/**\n * Determine if argument node is an HTMLInputElement based on `nodeName` property. This funciton is\n * safe to use with server-side rendering.\n */\nfunction ssrSafeIsHTMLInputElement(node: Node): node is HTMLInputElement {\n  return node.nodeName === 'INPUT';\n}\n\n/**\n * Determine if argument node is an HTMLTextAreaElement based on `nodeName` property. This\n * funciton is safe to use with server-side rendering.\n */\nfunction ssrSafeIsHTMLTextAreaElement(node: Node): node is HTMLTextAreaElement {\n  return node.nodeName === 'TEXTAREA';\n}\n\n/**\n * Calculate the expected ARIA accessible name for given DOM Node. Given DOM Node may be either the\n * \"Root node\" passed to `_computeAriaAccessibleName` or \"Current node\" as result of recursion.\n *\n * @return the accessible name of argument DOM Node\n *\n * @param currentNode node to determine accessible name of\n * @param isDirectlyReferenced true if `currentNode` is the root node to calculate ARIA accessible\n * name of. False if it is a result of recursion.\n */\nfunction _computeAriaAccessibleNameInternal(\n  currentNode: Node,\n  isDirectlyReferenced: boolean,\n): string {\n  // NOTE: this differs from accname-1.2 specification.\n  //  - Does not implement Step 1. of accname-1.2: '''If `currentNode`'s role prohibits naming,\n  //    return the empty string (\"\")'''.\n  //  - Does not implement Step 2.A. of accname-1.2: '''if current node is hidden and not directly\n  //    referenced by aria-labelledby... return the empty string.'''\n\n  // acc-name-1.2 Step 2.B.: aria-labelledby\n  if (ssrSafeIsElement(currentNode) && isDirectlyReferenced) {\n    const labelledbyIds: string[] =\n      currentNode.getAttribute?.('aria-labelledby')?.split(/\\s+/g) || [];\n    const validIdRefs: HTMLElement[] = labelledbyIds.reduce((validIds, id) => {\n      const elem = document.getElementById(id);\n      if (elem) {\n        validIds.push(elem);\n      }\n      return validIds;\n    }, [] as HTMLElement[]);\n\n    if (validIdRefs.length) {\n      return validIdRefs\n        .map(idRef => {\n          return _computeAriaAccessibleNameInternal(idRef, false);\n        })\n        .join(' ');\n    }\n  }\n\n  // acc-name-1.2 Step 2.C.: aria-label\n  if (ssrSafeIsElement(currentNode)) {\n    const ariaLabel = currentNode.getAttribute('aria-label')?.trim();\n\n    if (ariaLabel) {\n      return ariaLabel;\n    }\n  }\n\n  // acc-name-1.2 Step 2.D. attribute or element that defines a text alternative\n  //\n  // NOTE: this differs from accname-1.2 specification.\n  // Only implements Step 2.D. for `<label>`,`<input/>`, and `<textarea/>` element. Does not\n  // implement other elements that have an attribute or element that defines a text alternative.\n  if (ssrSafeIsHTMLInputElement(currentNode) || ssrSafeIsHTMLTextAreaElement(currentNode)) {\n    // use label with a `for` attribute referencing the current node\n    if (currentNode.labels?.length) {\n      return Array.from(currentNode.labels)\n        .map(x => _computeAriaAccessibleNameInternal(x, false))\n        .join(' ');\n    }\n\n    // use placeholder if available\n    const placeholder = currentNode.getAttribute('placeholder')?.trim();\n    if (placeholder) {\n      return placeholder;\n    }\n\n    // use title if available\n    const title = currentNode.getAttribute('title')?.trim();\n    if (title) {\n      return title;\n    }\n  }\n\n  // NOTE: this differs from accname-1.2 specification.\n  //  - does not implement acc-name-1.2 Step 2.E.: '''if the current node is a control embedded\n  //     within the label... then include the embedded control as part of the text alternative in\n  //     the following manner...'''. Step 2E applies to embedded controls such as textbox, listbox,\n  //     range, etc.\n  //  - does not implement acc-name-1.2 step 2.F.: check that '''role allows name from content''',\n  //    which applies to `currentNode` and its children.\n  //  - does not implement acc-name-1.2 Step 2.F.ii.: '''Check for CSS generated textual content'''\n  //    (e.g. :before and :after).\n  //  - does not implement acc-name-1.2 Step 2.I.: '''if the current node has a Tooltip attribute,\n  //    return its value'''\n\n  // Return text content with whitespace collapsed into a single space character. Accomplish\n  // acc-name-1.2 steps 2F, 2G, and 2H.\n  return (currentNode.textContent || '').replace(/\\s+/g, ' ').trim();\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  Directive,\n  ElementRef,\n  Optional,\n  inject,\n  InjectionToken,\n  Inject,\n  OnInit,\n  Injector,\n  DoCheck,\n} from '@angular/core';\nimport {\n  NG_VALUE_ACCESSOR,\n  NG_VALIDATORS,\n  NgForm,\n  FormGroupDirective,\n  NgControl,\n  ValidatorFn,\n  Validators,\n  AbstractControl,\n  ValidationErrors,\n} from '@angular/forms';\nimport {\n  CanUpdateErrorState,\n  mixinErrorState,\n  MAT_DATE_FORMATS,\n  DateAdapter,\n  MatDateFormats,\n  ErrorStateMatcher,\n} from '@angular/material/core';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {BACKSPACE, LEFT_ARROW, RIGHT_ARROW} from '@angular/cdk/keycodes';\nimport {MatDatepickerInputBase, DateFilterFn} from './datepicker-input-base';\nimport {DateRange, DateSelectionModelChange} from './date-selection-model';\nimport {_computeAriaAccessibleName} from './aria-accessible-name';\n\n/** Parent component that should be wrapped around `MatStartDate` and `MatEndDate`. */\nexport interface MatDateRangeInputParent<D> {\n  id: string;\n  min: D | null;\n  max: D | null;\n  dateFilter: DateFilterFn<D>;\n  rangePicker: {\n    opened: boolean;\n    id: string;\n  };\n  _startInput: MatDateRangeInputPartBase<D>;\n  _endInput: MatDateRangeInputPartBase<D>;\n  _groupDisabled: boolean;\n  _handleChildValueChange(): void;\n  _openDatepicker(): void;\n}\n\n/**\n * Used to provide the date range input wrapper component\n * to the parts without circular dependencies.\n */\nexport const MAT_DATE_RANGE_INPUT_PARENT = new InjectionToken<MatDateRangeInputParent<unknown>>(\n  'MAT_DATE_RANGE_INPUT_PARENT',\n);\n\n/**\n * Base class for the individual inputs that can be projected inside a `mat-date-range-input`.\n */\n@Directive()\nabstract class MatDateRangeInputPartBase<D>\n  extends MatDatepickerInputBase<DateRange<D>>\n  implements OnInit, DoCheck\n{\n  /**\n   * Form control bound to this input part.\n   * @docs-private\n   */\n  ngControl: NgControl;\n\n  /** @docs-private */\n  abstract updateErrorState(): void;\n\n  protected abstract override _validator: ValidatorFn | null;\n  protected abstract override _assignValueToModel(value: D | null): void;\n  protected abstract override _getValueFromModel(modelValue: DateRange<D>): D | null;\n\n  protected readonly _dir = inject(Directionality, {optional: true});\n\n  constructor(\n    @Inject(MAT_DATE_RANGE_INPUT_PARENT) public _rangeInput: MatDateRangeInputParent<D>,\n    public override _elementRef: ElementRef<HTMLInputElement>,\n    public _defaultErrorStateMatcher: ErrorStateMatcher,\n    private _injector: Injector,\n    @Optional() public _parentForm: NgForm,\n    @Optional() public _parentFormGroup: FormGroupDirective,\n    @Optional() dateAdapter: DateAdapter<D>,\n    @Optional() @Inject(MAT_DATE_FORMATS) dateFormats: MatDateFormats,\n  ) {\n    super(_elementRef, dateAdapter, dateFormats);\n  }\n\n  ngOnInit() {\n    // We need the date input to provide itself as a `ControlValueAccessor` and a `Validator`, while\n    // injecting its `NgControl` so that the error state is handled correctly. This introduces a\n    // circular dependency, because both `ControlValueAccessor` and `Validator` depend on the input\n    // itself. Usually we can work around it for the CVA, but there's no API to do it for the\n    // validator. We work around it here by injecting the `NgControl` in `ngOnInit`, after\n    // everything has been resolved.\n    // tslint:disable-next-line:no-bitwise\n    const ngControl = this._injector.get(NgControl, null, {optional: true, self: true});\n\n    if (ngControl) {\n      this.ngControl = ngControl;\n    }\n  }\n\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n    }\n  }\n\n  /** Gets whether the input is empty. */\n  isEmpty(): boolean {\n    return this._elementRef.nativeElement.value.length === 0;\n  }\n\n  /** Gets the placeholder of the input. */\n  _getPlaceholder() {\n    return this._elementRef.nativeElement.placeholder;\n  }\n\n  /** Focuses the input. */\n  focus(): void {\n    this._elementRef.nativeElement.focus();\n  }\n\n  /** Gets the value that should be used when mirroring the input's size. */\n  getMirrorValue(): string {\n    const element = this._elementRef.nativeElement;\n    const value = element.value;\n    return value.length > 0 ? value : element.placeholder;\n  }\n\n  /** Handles `input` events on the input element. */\n  override _onInput(value: string) {\n    super._onInput(value);\n    this._rangeInput._handleChildValueChange();\n  }\n\n  /** Opens the datepicker associated with the input. */\n  protected _openPopup(): void {\n    this._rangeInput._openDatepicker();\n  }\n\n  /** Gets the minimum date from the range input. */\n  _getMinDate() {\n    return this._rangeInput.min;\n  }\n\n  /** Gets the maximum date from the range input. */\n  _getMaxDate() {\n    return this._rangeInput.max;\n  }\n\n  /** Gets the date filter function from the range input. */\n  protected _getDateFilter() {\n    return this._rangeInput.dateFilter;\n  }\n\n  protected override _parentDisabled() {\n    return this._rangeInput._groupDisabled;\n  }\n\n  protected _shouldHandleChangeEvent({source}: DateSelectionModelChange<DateRange<D>>): boolean {\n    return source !== this._rangeInput._startInput && source !== this._rangeInput._endInput;\n  }\n\n  protected override _assignValueProgrammatically(value: D | null) {\n    super._assignValueProgrammatically(value);\n    const opposite = (\n      this === this._rangeInput._startInput\n        ? this._rangeInput._endInput\n        : this._rangeInput._startInput\n    ) as MatDateRangeInputPartBase<D> | undefined;\n    opposite?._validatorOnChange();\n  }\n\n  /** return the ARIA accessible name of the input element */\n  _getAccessibleName(): string {\n    return _computeAriaAccessibleName(this._elementRef.nativeElement);\n  }\n}\n\nconst _MatDateRangeInputBase = mixinErrorState(MatDateRangeInputPartBase);\n\n/** Input for entering the start date in a `mat-date-range-input`. */\n@Directive({\n  selector: 'input[matStartDate]',\n  host: {\n    'class': 'mat-start-date mat-date-range-input-inner',\n    '[disabled]': 'disabled',\n    '(input)': '_onInput($event.target.value)',\n    '(change)': '_onChange()',\n    '(keydown)': '_onKeydown($event)',\n    '[attr.aria-haspopup]': '_rangeInput.rangePicker ? \"dialog\" : null',\n    '[attr.aria-owns]': '(_rangeInput.rangePicker?.opened && _rangeInput.rangePicker.id) || null',\n    '[attr.min]': '_getMinDate() ? _dateAdapter.toIso8601(_getMinDate()) : null',\n    '[attr.max]': '_getMaxDate() ? _dateAdapter.toIso8601(_getMaxDate()) : null',\n    '(blur)': '_onBlur()',\n    'type': 'text',\n  },\n  providers: [\n    {provide: NG_VALUE_ACCESSOR, useExisting: MatStartDate, multi: true},\n    {provide: NG_VALIDATORS, useExisting: MatStartDate, multi: true},\n  ],\n  // These need to be specified explicitly, because some tooling doesn't\n  // seem to pick them up from the base class. See #20932.\n  outputs: ['dateChange', 'dateInput'],\n  inputs: ['errorStateMatcher'],\n})\nexport class MatStartDate<D> extends _MatDateRangeInputBase<D> implements CanUpdateErrorState {\n  /** Validator that checks that the start date isn't after the end date. */\n  private _startValidator: ValidatorFn = (control: AbstractControl): ValidationErrors | null => {\n    const start = this._dateAdapter.getValidDateOrNull(\n      this._dateAdapter.deserialize(control.value),\n    );\n    const end = this._model ? this._model.selection.end : null;\n    return !start || !end || this._dateAdapter.compareDate(start, end) <= 0\n      ? null\n      : {'matStartDateInvalid': {'end': end, 'actual': start}};\n  };\n\n  constructor(\n    @Inject(MAT_DATE_RANGE_INPUT_PARENT) rangeInput: MatDateRangeInputParent<D>,\n    elementRef: ElementRef<HTMLInputElement>,\n    defaultErrorStateMatcher: ErrorStateMatcher,\n    injector: Injector,\n    @Optional() parentForm: NgForm,\n    @Optional() parentFormGroup: FormGroupDirective,\n    @Optional() dateAdapter: DateAdapter<D>,\n    @Optional() @Inject(MAT_DATE_FORMATS) dateFormats: MatDateFormats,\n  ) {\n    super(\n      rangeInput,\n      elementRef,\n      defaultErrorStateMatcher,\n      injector,\n      parentForm,\n      parentFormGroup,\n      dateAdapter,\n      dateFormats,\n    );\n  }\n\n  protected _validator = Validators.compose([...super._getValidators(), this._startValidator]);\n\n  protected _getValueFromModel(modelValue: DateRange<D>) {\n    return modelValue.start;\n  }\n\n  protected override _shouldHandleChangeEvent(\n    change: DateSelectionModelChange<DateRange<D>>,\n  ): boolean {\n    if (!super._shouldHandleChangeEvent(change)) {\n      return false;\n    } else {\n      return !change.oldValue?.start\n        ? !!change.selection.start\n        : !change.selection.start ||\n            !!this._dateAdapter.compareDate(change.oldValue.start, change.selection.start);\n    }\n  }\n\n  protected _assignValueToModel(value: D | null) {\n    if (this._model) {\n      const range = new DateRange(value, this._model.selection.end);\n      this._model.updateSelection(range, this);\n    }\n  }\n\n  protected override _formatValue(value: D | null) {\n    super._formatValue(value);\n\n    // Any time the input value is reformatted we need to tell the parent.\n    this._rangeInput._handleChildValueChange();\n  }\n\n  override _onKeydown(event: KeyboardEvent) {\n    const endInput = this._rangeInput._endInput;\n    const element = this._elementRef.nativeElement;\n    const isLtr = this._dir?.value !== 'rtl';\n\n    // If the user hits RIGHT (LTR) when at the end of the input (and no\n    // selection), move the cursor to the start of the end input.\n    if (\n      ((event.keyCode === RIGHT_ARROW && isLtr) || (event.keyCode === LEFT_ARROW && !isLtr)) &&\n      element.selectionStart === element.value.length &&\n      element.selectionEnd === element.value.length\n    ) {\n      event.preventDefault();\n      endInput._elementRef.nativeElement.setSelectionRange(0, 0);\n      endInput.focus();\n    } else {\n      super._onKeydown(event);\n    }\n  }\n}\n\n/** Input for entering the end date in a `mat-date-range-input`. */\n@Directive({\n  selector: 'input[matEndDate]',\n  host: {\n    'class': 'mat-end-date mat-date-range-input-inner',\n    '[disabled]': 'disabled',\n    '(input)': '_onInput($event.target.value)',\n    '(change)': '_onChange()',\n    '(keydown)': '_onKeydown($event)',\n    '[attr.aria-haspopup]': '_rangeInput.rangePicker ? \"dialog\" : null',\n    '[attr.aria-owns]': '(_rangeInput.rangePicker?.opened && _rangeInput.rangePicker.id) || null',\n    '[attr.min]': '_getMinDate() ? _dateAdapter.toIso8601(_getMinDate()) : null',\n    '[attr.max]': '_getMaxDate() ? _dateAdapter.toIso8601(_getMaxDate()) : null',\n    '(blur)': '_onBlur()',\n    'type': 'text',\n  },\n  providers: [\n    {provide: NG_VALUE_ACCESSOR, useExisting: MatEndDate, multi: true},\n    {provide: NG_VALIDATORS, useExisting: MatEndDate, multi: true},\n  ],\n  // These need to be specified explicitly, because some tooling doesn't\n  // seem to pick them up from the base class. See #20932.\n  outputs: ['dateChange', 'dateInput'],\n  inputs: ['errorStateMatcher'],\n})\nexport class MatEndDate<D> extends _MatDateRangeInputBase<D> implements CanUpdateErrorState {\n  /** Validator that checks that the end date isn't before the start date. */\n  private _endValidator: ValidatorFn = (control: AbstractControl): ValidationErrors | null => {\n    const end = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n    const start = this._model ? this._model.selection.start : null;\n    return !end || !start || this._dateAdapter.compareDate(end, start) >= 0\n      ? null\n      : {'matEndDateInvalid': {'start': start, 'actual': end}};\n  };\n\n  constructor(\n    @Inject(MAT_DATE_RANGE_INPUT_PARENT) rangeInput: MatDateRangeInputParent<D>,\n    elementRef: ElementRef<HTMLInputElement>,\n    defaultErrorStateMatcher: ErrorStateMatcher,\n    injector: Injector,\n    @Optional() parentForm: NgForm,\n    @Optional() parentFormGroup: FormGroupDirective,\n    @Optional() dateAdapter: DateAdapter<D>,\n    @Optional() @Inject(MAT_DATE_FORMATS) dateFormats: MatDateFormats,\n  ) {\n    super(\n      rangeInput,\n      elementRef,\n      defaultErrorStateMatcher,\n      injector,\n      parentForm,\n      parentFormGroup,\n      dateAdapter,\n      dateFormats,\n    );\n  }\n\n  protected _validator = Validators.compose([...super._getValidators(), this._endValidator]);\n\n  protected _getValueFromModel(modelValue: DateRange<D>) {\n    return modelValue.end;\n  }\n\n  protected override _shouldHandleChangeEvent(\n    change: DateSelectionModelChange<DateRange<D>>,\n  ): boolean {\n    if (!super._shouldHandleChangeEvent(change)) {\n      return false;\n    } else {\n      return !change.oldValue?.end\n        ? !!change.selection.end\n        : !change.selection.end ||\n            !!this._dateAdapter.compareDate(change.oldValue.end, change.selection.end);\n    }\n  }\n\n  protected _assignValueToModel(value: D | null) {\n    if (this._model) {\n      const range = new DateRange(this._model.selection.start, value);\n      this._model.updateSelection(range, this);\n    }\n  }\n\n  override _onKeydown(event: KeyboardEvent) {\n    const startInput = this._rangeInput._startInput;\n    const element = this._elementRef.nativeElement;\n    const isLtr = this._dir?.value !== 'rtl';\n\n    // If the user is pressing backspace on an empty end input, move focus back to the start.\n    if (event.keyCode === BACKSPACE && !element.value) {\n      startInput.focus();\n    }\n    // If the user hits LEFT (LTR) when at the start of the input (and no\n    // selection), move the cursor to the end of the start input.\n    else if (\n      ((event.keyCode === LEFT_ARROW && isLtr) || (event.keyCode === RIGHT_ARROW && !isLtr)) &&\n      element.selectionStart === 0 &&\n      element.selectionEnd === 0\n    ) {\n      event.preventDefault();\n      const endPosition = startInput._elementRef.nativeElement.value.length;\n      startInput._elementRef.nativeElement.setSelectionRange(endPosition, endPosition);\n      startInput.focus();\n    } else {\n      super._onKeydown(event);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  Component,\n  ChangeDetectionStrategy,\n  ViewEncapsulation,\n  Input,\n  Optional,\n  OnDestroy,\n  ContentChild,\n  AfterContentInit,\n  ChangeDetectorRef,\n  Self,\n  ElementRef,\n  Inject,\n  OnChanges,\n  SimpleChanges,\n} from '@angular/core';\nimport {MatFormFieldControl, MAT_FORM_FIELD} from '@angular/material/form-field';\nimport {ThemePalette, DateAdapter} from '@angular/material/core';\nimport {NgControl, ControlContainer, Validators} from '@angular/forms';\nimport {Subject, merge, Subscription} from 'rxjs';\nimport {FocusOrigin} from '@angular/cdk/a11y';\nimport {coerceBooleanProperty, BooleanInput} from '@angular/cdk/coercion';\nimport {\n  MatStartDate,\n  MatEndDate,\n  MatDateRangeInputParent,\n  MAT_DATE_RANGE_INPUT_PARENT,\n} from './date-range-input-parts';\nimport {MatDatepickerControl, MatDatepickerPanel} from './datepicker-base';\nimport {createMissingDateImplError} from './datepicker-errors';\nimport {DateFilterFn, dateInputsHaveChanged, _MatFormFieldPartial} from './datepicker-input-base';\nimport {MatDateRangePickerInput} from './date-range-picker';\nimport {DateRange, MatDateSelectionModel} from './date-selection-model';\n\nlet nextUniqueId = 0;\n\n@Component({\n  selector: 'mat-date-range-input',\n  templateUrl: 'date-range-input.html',\n  styleUrls: ['date-range-input.css'],\n  exportAs: 'matDateRangeInput',\n  host: {\n    'class': 'mat-date-range-input',\n    '[class.mat-date-range-input-hide-placeholders]': '_shouldHidePlaceholders()',\n    '[class.mat-date-range-input-required]': 'required',\n    '[attr.id]': 'id',\n    'role': 'group',\n    '[attr.aria-labelledby]': '_getAriaLabelledby()',\n    '[attr.aria-describedby]': '_ariaDescribedBy',\n    // Used by the test harness to tie this input to its calendar. We can't depend on\n    // `aria-owns` for this, because it's only defined while the calendar is open.\n    '[attr.data-mat-calendar]': 'rangePicker ? rangePicker.id : null',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  providers: [\n    {provide: MatFormFieldControl, useExisting: MatDateRangeInput},\n    {provide: MAT_DATE_RANGE_INPUT_PARENT, useExisting: MatDateRangeInput},\n  ],\n})\nexport class MatDateRangeInput<D>\n  implements\n    MatFormFieldControl<DateRange<D>>,\n    MatDatepickerControl<D>,\n    MatDateRangeInputParent<D>,\n    MatDateRangePickerInput<D>,\n    AfterContentInit,\n    OnChanges,\n    OnDestroy\n{\n  private _closedSubscription = Subscription.EMPTY;\n\n  /** Current value of the range input. */\n  get value() {\n    return this._model ? this._model.selection : null;\n  }\n\n  /** Unique ID for the group. */\n  id = `mat-date-range-input-${nextUniqueId++}`;\n\n  /** Whether the control is focused. */\n  focused = false;\n\n  /** Whether the control's label should float. */\n  get shouldLabelFloat(): boolean {\n    return this.focused || !this.empty;\n  }\n\n  /** Name of the form control. */\n  controlType = 'mat-date-range-input';\n\n  /**\n   * Implemented as a part of `MatFormFieldControl`.\n   * Set the placeholder attribute on `matStartDate` and `matEndDate`.\n   * @docs-private\n   */\n  get placeholder() {\n    const start = this._startInput?._getPlaceholder() || '';\n    const end = this._endInput?._getPlaceholder() || '';\n    return start || end ? `${start} ${this.separator} ${end}` : '';\n  }\n\n  /** The range picker that this input is associated with. */\n  @Input()\n  get rangePicker() {\n    return this._rangePicker;\n  }\n  set rangePicker(rangePicker: MatDatepickerPanel<MatDatepickerControl<D>, DateRange<D>, D>) {\n    if (rangePicker) {\n      this._model = rangePicker.registerInput(this);\n      this._rangePicker = rangePicker;\n      this._closedSubscription.unsubscribe();\n      this._closedSubscription = rangePicker.closedStream.subscribe(() => {\n        this._startInput?._onTouched();\n        this._endInput?._onTouched();\n      });\n      this._registerModel(this._model!);\n    }\n  }\n  private _rangePicker: MatDatepickerPanel<MatDatepickerControl<D>, DateRange<D>, D>;\n\n  /** Whether the input is required. */\n  @Input()\n  get required(): boolean {\n    return (\n      this._required ??\n      (this._isTargetRequired(this) ||\n        this._isTargetRequired(this._startInput) ||\n        this._isTargetRequired(this._endInput)) ??\n      false\n    );\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n  private _required: boolean | undefined;\n\n  /** Function that can be used to filter out dates within the date range picker. */\n  @Input()\n  get dateFilter() {\n    return this._dateFilter;\n  }\n  set dateFilter(value: DateFilterFn<D>) {\n    const start = this._startInput;\n    const end = this._endInput;\n    const wasMatchingStart = start && start._matchesFilter(start.value);\n    const wasMatchingEnd = end && end._matchesFilter(start.value);\n    this._dateFilter = value;\n\n    if (start && start._matchesFilter(start.value) !== wasMatchingStart) {\n      start._validatorOnChange();\n    }\n\n    if (end && end._matchesFilter(end.value) !== wasMatchingEnd) {\n      end._validatorOnChange();\n    }\n  }\n  private _dateFilter: DateFilterFn<D>;\n\n  /** The minimum valid date. */\n  @Input()\n  get min(): D | null {\n    return this._min;\n  }\n  set min(value: D | null) {\n    const validValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n\n    if (!this._dateAdapter.sameDate(validValue, this._min)) {\n      this._min = validValue;\n      this._revalidate();\n    }\n  }\n  private _min: D | null;\n\n  /** The maximum valid date. */\n  @Input()\n  get max(): D | null {\n    return this._max;\n  }\n  set max(value: D | null) {\n    const validValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n\n    if (!this._dateAdapter.sameDate(validValue, this._max)) {\n      this._max = validValue;\n      this._revalidate();\n    }\n  }\n  private _max: D | null;\n\n  /** Whether the input is disabled. */\n  @Input()\n  get disabled(): boolean {\n    return this._startInput && this._endInput\n      ? this._startInput.disabled && this._endInput.disabled\n      : this._groupDisabled;\n  }\n  set disabled(value: BooleanInput) {\n    const newValue = coerceBooleanProperty(value);\n\n    if (newValue !== this._groupDisabled) {\n      this._groupDisabled = newValue;\n      this.stateChanges.next(undefined);\n    }\n  }\n  _groupDisabled = false;\n\n  /** Whether the input is in an error state. */\n  get errorState(): boolean {\n    if (this._startInput && this._endInput) {\n      return this._startInput.errorState || this._endInput.errorState;\n    }\n\n    return false;\n  }\n\n  /** Whether the datepicker input is empty. */\n  get empty(): boolean {\n    const startEmpty = this._startInput ? this._startInput.isEmpty() : false;\n    const endEmpty = this._endInput ? this._endInput.isEmpty() : false;\n    return startEmpty && endEmpty;\n  }\n\n  /** Value for the `aria-describedby` attribute of the inputs. */\n  _ariaDescribedBy: string | null = null;\n\n  /** Date selection model currently registered with the input. */\n  private _model: MatDateSelectionModel<DateRange<D>> | undefined;\n\n  /** Separator text to be shown between the inputs. */\n  @Input() separator = '';\n\n  /** Start of the comparison range that should be shown in the calendar. */\n  @Input() comparisonStart: D | null = null;\n\n  /** End of the comparison range that should be shown in the calendar. */\n  @Input() comparisonEnd: D | null = null;\n\n  @ContentChild(MatStartDate) _startInput: MatStartDate<D>;\n  @ContentChild(MatEndDate) _endInput: MatEndDate<D>;\n\n  /**\n   * Implemented as a part of `MatFormFieldControl`.\n   * TODO(crisbeto): change type to `AbstractControlDirective` after #18206 lands.\n   * @docs-private\n   */\n  ngControl: NgControl | null;\n\n  /** Emits when the input's state has changed. */\n  readonly stateChanges = new Subject<void>();\n\n  constructor(\n    private _changeDetectorRef: ChangeDetectorRef,\n    private _elementRef: ElementRef<HTMLElement>,\n    @Optional() @Self() control: ControlContainer,\n    @Optional() private _dateAdapter: DateAdapter<D>,\n    @Optional() @Inject(MAT_FORM_FIELD) private _formField?: _MatFormFieldPartial,\n  ) {\n    if (!_dateAdapter && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw createMissingDateImplError('DateAdapter');\n    }\n\n    // The datepicker module can be used both with MDC and non-MDC form fields. We have\n    // to conditionally add the MDC input class so that the range picker looks correctly.\n    if (_formField?._elementRef.nativeElement.classList.contains('mat-mdc-form-field')) {\n      _elementRef.nativeElement.classList.add(\n        'mat-mdc-input-element',\n        'mat-mdc-form-field-input-control',\n        'mdc-text-field__input',\n      );\n    }\n\n    // TODO(crisbeto): remove `as any` after #18206 lands.\n    this.ngControl = control as any;\n  }\n\n  /**\n   * Implemented as a part of `MatFormFieldControl`.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]): void {\n    this._ariaDescribedBy = ids.length ? ids.join(' ') : null;\n  }\n\n  /**\n   * Implemented as a part of `MatFormFieldControl`.\n   * @docs-private\n   */\n  onContainerClick(): void {\n    if (!this.focused && !this.disabled) {\n      if (!this._model || !this._model.selection.start) {\n        this._startInput.focus();\n      } else {\n        this._endInput.focus();\n      }\n    }\n  }\n\n  ngAfterContentInit() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._startInput) {\n        throw Error('mat-date-range-input must contain a matStartDate input');\n      }\n\n      if (!this._endInput) {\n        throw Error('mat-date-range-input must contain a matEndDate input');\n      }\n    }\n\n    if (this._model) {\n      this._registerModel(this._model);\n    }\n\n    // We don't need to unsubscribe from this, because we\n    // know that the input streams will be completed on destroy.\n    merge(this._startInput.stateChanges, this._endInput.stateChanges).subscribe(() => {\n      this.stateChanges.next(undefined);\n    });\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (dateInputsHaveChanged(changes, this._dateAdapter)) {\n      this.stateChanges.next(undefined);\n    }\n  }\n\n  ngOnDestroy() {\n    this._closedSubscription.unsubscribe();\n    this.stateChanges.complete();\n  }\n\n  /** Gets the date at which the calendar should start. */\n  getStartValue(): D | null {\n    return this.value ? this.value.start : null;\n  }\n\n  /** Gets the input's theme palette. */\n  getThemePalette(): ThemePalette {\n    return this._formField ? this._formField.color : undefined;\n  }\n\n  /** Gets the element to which the calendar overlay should be attached. */\n  getConnectedOverlayOrigin(): ElementRef {\n    return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;\n  }\n\n  /** Gets the ID of an element that should be used a description for the calendar overlay. */\n  getOverlayLabelId(): string | null {\n    return this._formField ? this._formField.getLabelId() : null;\n  }\n\n  /** Gets the value that is used to mirror the state input. */\n  _getInputMirrorValue(part: 'start' | 'end') {\n    const input = part === 'start' ? this._startInput : this._endInput;\n    return input ? input.getMirrorValue() : '';\n  }\n\n  /** Whether the input placeholders should be hidden. */\n  _shouldHidePlaceholders() {\n    return this._startInput ? !this._startInput.isEmpty() : false;\n  }\n\n  /** Handles the value in one of the child inputs changing. */\n  _handleChildValueChange() {\n    this.stateChanges.next(undefined);\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /** Opens the date range picker associated with the input. */\n  _openDatepicker() {\n    if (this._rangePicker) {\n      this._rangePicker.open();\n    }\n  }\n\n  /** Whether the separate text should be hidden. */\n  _shouldHideSeparator() {\n    return (\n      (!this._formField ||\n        (this._formField.getLabelId() && !this._formField._shouldLabelFloat())) &&\n      this.empty\n    );\n  }\n\n  /** Gets the value for the `aria-labelledby` attribute of the inputs. */\n  _getAriaLabelledby() {\n    const formField = this._formField;\n    return formField && formField._hasFloatingLabel() ? formField._labelId : null;\n  }\n\n  _getStartDateAccessibleName(): string {\n    return this._startInput._getAccessibleName();\n  }\n\n  _getEndDateAccessibleName(): string {\n    return this._endInput._getAccessibleName();\n  }\n\n  /** Updates the focused state of the range input. */\n  _updateFocus(origin: FocusOrigin) {\n    this.focused = origin !== null;\n    this.stateChanges.next();\n  }\n\n  /** Re-runs the validators on the start/end inputs. */\n  private _revalidate() {\n    if (this._startInput) {\n      this._startInput._validatorOnChange();\n    }\n\n    if (this._endInput) {\n      this._endInput._validatorOnChange();\n    }\n  }\n\n  /** Registers the current date selection model with the start/end inputs. */\n  private _registerModel(model: MatDateSelectionModel<DateRange<D>>) {\n    if (this._startInput) {\n      this._startInput._registerModel(model);\n    }\n\n    if (this._endInput) {\n      this._endInput._registerModel(model);\n    }\n  }\n\n  /** Checks whether a specific range input directive is required. */\n  private _isTargetRequired(target: {ngControl: NgControl | null} | null): boolean | undefined {\n    return target?.ngControl?.control?.hasValidator(Validators.required);\n  }\n}\n", "<div\n  class=\"mat-date-range-input-container\"\n  cdkMonitorSubtreeFocus\n  (cdkFocusChange)=\"_updateFocus($event)\">\n  <div class=\"mat-date-range-input-wrapper\">\n    <ng-content select=\"input[matStartDate]\"></ng-content>\n    <span\n      class=\"mat-date-range-input-mirror\"\n      aria-hidden=\"true\">{{_getInputMirrorValue('start')}}</span>\n  </div>\n\n  <span\n    class=\"mat-date-range-input-separator\"\n    [class.mat-date-range-input-separator-hidden]=\"_shouldHideSeparator()\">{{separator}}</span>\n\n  <div class=\"mat-date-range-input-wrapper mat-date-range-input-end-wrapper\">\n    <ng-content select=\"input[matEndDate]\"></ng-content>\n    <span\n      class=\"mat-date-range-input-mirror\"\n      aria-hidden=\"true\">{{_getInputMirrorValue('end')}}</span>\n  </div>\n</div>\n\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy, Component, ViewEncapsulation} from '@angular/core';\nimport {MatDatepickerBase, MatDatepickerContent, MatDatepickerControl} from './datepicker-base';\nimport {MAT_RANGE_DATE_SELECTION_MODEL_PROVIDER, DateRange} from './date-selection-model';\nimport {MAT_CALENDAR_RANGE_STRATEGY_PROVIDER} from './date-range-selection-strategy';\n\n/**\n * Input that can be associated with a date range picker.\n * @docs-private\n */\nexport interface MatDateRangePickerInput<D> extends MatDatepickerControl<D> {\n  _getEndDateAccessibleName(): string | null;\n  _getStartDateAccessibleName(): string | null;\n  comparisonStart: D | null;\n  comparisonEnd: D | null;\n}\n\n// TODO(mmalerba): We use a component instead of a directive here so the user can use implicit\n// template reference variables (e.g. #d vs #d=\"matDateRangePicker\"). We can change this to a\n// directive if angular adds support for `exportAs: '$implicit'` on directives.\n/** Component responsible for managing the date range picker popup/dialog. */\n@Component({\n  selector: 'mat-date-range-picker',\n  template: '',\n  exportAs: 'matDateRangePicker',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  providers: [\n    MAT_RANGE_DATE_SELECTION_MODEL_PROVIDER,\n    MAT_CALENDAR_RANGE_STRATEGY_PROVIDER,\n    {provide: MatDatepickerBase, useExisting: MatDateRangePicker},\n  ],\n})\nexport class MatDateRangePicker<D> extends MatDatepickerBase<\n  MatDateRangePickerInput<D>,\n  DateRange<D>,\n  D\n> {\n  protected override _forwardContentValues(instance: MatDatepickerContent<DateRange<D>, D>) {\n    super._forwardContentValues(instance);\n\n    const input = this.datepickerInput;\n\n    if (input) {\n      instance.comparisonStart = input.comparisonStart;\n      instance.comparisonEnd = input.comparisonEnd;\n      instance.startDateAccessibleName = input._getStartDateAccessibleName();\n      instance.endDateAccessibleName = input._getEndDateAccessibleName();\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  Component,\n  Directive,\n  OnDestroy,\n  TemplateRef,\n  ViewChild,\n  ViewContainerRef,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {TemplatePortal} from '@angular/cdk/portal';\nimport {MatDatepickerBase, MatDatepickerControl} from './datepicker-base';\n\n/** Button that will close the datepicker and assign the current selection to the data model. */\n@Directive({\n  selector: '[matDatepickerApply], [matDateRangePickerApply]',\n  host: {'(click)': '_applySelection()'},\n})\nexport class MatDatepickerApply {\n  constructor(private _datepicker: MatDatepickerBase<MatDatepickerControl<any>, unknown>) {}\n\n  _applySelection() {\n    this._datepicker._applyPendingSelection();\n    this._datepicker.close();\n  }\n}\n\n/** Button that will close the datepicker and discard the current selection. */\n@Directive({\n  selector: '[matDatepickerCancel], [matDateRangePickerCancel]',\n  host: {'(click)': '_datepicker.close()'},\n})\nexport class MatDatepickerCancel {\n  constructor(public _datepicker: MatDatepickerBase<MatDatepickerControl<any>, unknown>) {}\n}\n\n/**\n * Container that can be used to project a row of action buttons\n * to the bottom of a datepicker or date range picker.\n */\n@Component({\n  selector: 'mat-datepicker-actions, mat-date-range-picker-actions',\n  styleUrls: ['datepicker-actions.css'],\n  template: `\n    <ng-template>\n      <div class=\"mat-datepicker-actions\">\n        <ng-content></ng-content>\n      </div>\n    </ng-template>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n})\nexport class MatDatepickerActions implements AfterViewInit, OnDestroy {\n  @ViewChild(TemplateRef) _template: TemplateRef<unknown>;\n  private _portal: TemplatePortal;\n\n  constructor(\n    private _datepicker: MatDatepickerBase<MatDatepickerControl<any>, unknown>,\n    private _viewContainerRef: ViewContainerRef,\n  ) {}\n\n  ngAfterViewInit() {\n    this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n    this._datepicker.registerActions(this._portal);\n  }\n\n  ngOnDestroy() {\n    this._datepicker.removeActions(this._portal);\n\n    // Needs to be null checked since we initialize it in `ngAfterViewInit`.\n    if (this._portal && this._portal.isAttached) {\n      this._portal?.detach();\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {A11yModule} from '@angular/cdk/a11y';\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {PortalModule} from '@angular/cdk/portal';\nimport {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {MatButtonModule} from '@angular/material/button';\nimport {CdkScrollableModule} from '@angular/cdk/scrolling';\nimport {MatCommonModule} from '@angular/material/core';\nimport {MatCalendar, MatCalendarHeader} from './calendar';\nimport {MatCalendarBody} from './calendar-body';\nimport {MatDatepicker} from './datepicker';\nimport {\n  MatDatepickerContent,\n  MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER,\n} from './datepicker-base';\nimport {MatDatepickerInput} from './datepicker-input';\nimport {MatDatepickerIntl} from './datepicker-intl';\nimport {MatDatepickerToggle, MatDatepickerToggleIcon} from './datepicker-toggle';\nimport {MatMonthView} from './month-view';\nimport {MatMultiYearView} from './multi-year-view';\nimport {MatYearView} from './year-view';\nimport {MatDateRangeInput} from './date-range-input';\nimport {MatStartDate, MatEndDate} from './date-range-input-parts';\nimport {MatDateRangePicker} from './date-range-picker';\nimport {MatDatepickerActions, MatDatepickerApply, MatDatepickerCancel} from './datepicker-actions';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    MatButtonModule,\n    OverlayModule,\n    A11yModule,\n    PortalModule,\n    MatCommonModule,\n  ],\n  exports: [\n    CdkScrollableModule,\n    MatCalendar,\n    MatCalendarBody,\n    MatDatepicker,\n    MatDatepickerContent,\n    MatDatepickerInput,\n    MatDatepickerToggle,\n    MatDatepickerToggleIcon,\n    MatMonthView,\n    MatYearView,\n    MatMultiYearView,\n    MatCalendarHeader,\n    MatDateRangeInput,\n    MatStartDate,\n    MatEndDate,\n    MatDateRangePicker,\n    MatDatepickerActions,\n    MatDatepickerCancel,\n    MatDatepickerApply,\n  ],\n  declarations: [\n    MatCalendar,\n    MatCalendarBody,\n    MatDatepicker,\n    MatDatepickerContent,\n    MatDatepickerInput,\n    MatDatepickerToggle,\n    MatDatepickerToggleIcon,\n    MatMonthView,\n    MatYearView,\n    MatMultiYearView,\n    MatCalendarHeader,\n    MatDateRangeInput,\n    MatStartDate,\n    MatEndDate,\n    MatDateRangePicker,\n    MatDatepickerActions,\n    MatDatepickerCancel,\n    MatDatepickerApply,\n  ],\n  providers: [MatDatepickerIntl, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER],\n})\nexport class MatDatepickerModule {}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],
  "mappings": "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",
  "names": ["DataSource", "isDataSource", "value", "connect", "ConnectableObservable", "ArrayDataSource", "constructor", "_data", "isObservable", "of", "disconnect", "_RecycleViewRepeaterStrategy", "constructor", "viewCacheSize", "_viewCache", "applyChanges", "changes", "viewContainerRef", "itemContextFactory", "itemValueResolver", "itemViewChanged", "forEachOperation", "record", "adjustedPreviousIndex", "currentIndex", "view", "operation", "previousIndex", "viewArgsFactory", "_insertView", "_detachAndCacheView", "_moveView", "context", "detach", "destroy", "value", "cachedView", "_insertViewFromCache", "$implicit", "undefined", "viewArgs", "createEmbeddedView", "templateRef", "index", "detachedView", "_maybeCacheView", "get", "move", "length", "push", "indexOf", "remove", "pop", "insert", "UniqueSelectionDispatcher", "constructor", "_listeners", "notify", "id", "name", "listener", "listen", "push", "filter", "registered", "ngOnDestroy", "prov", "factory", "fac", "providedIn", "Injectable", "_VIEW_REPEATER_STRATEGY", "InjectionToken", "_c0", "_c1", "VIRTUAL_SCROLL_STRATEGY", "InjectionToken", "FixedSizeVirtualScrollStrategy", "constructor", "itemSize", "minBufferPx", "maxBufferPx", "_scrolledIndexChange", "Subject", "scrolledIndexChange", "pipe", "distinctUntilChanged", "_viewport", "_itemSize", "_minBufferPx", "_maxBufferPx", "attach", "viewport", "_updateTotalContentSize", "_updateRenderedRange", "detach", "complete", "updateItemAndBufferSize", "ngDevMode", "Error", "onContentScrolled", "onDataLengthChanged", "onContentRendered", "onRenderedOffsetChanged", "scrollToIndex", "index", "behavior", "scrollToOffset", "setTotalContentSize", "getDataLength", "renderedRange", "getRenderedRange", "newRange", "start", "end", "viewportSize", "getViewportSize", "dataLength", "scrollOffset", "measureScrollOffset", "firstVisibleIndex", "maxVisibleItems", "Math", "ceil", "newVisibleIndex", "max", "min", "floor", "startBuffer", "expandStart", "endBuffer", "expandEnd", "setRenderedRange", "setRenderedContentOffset", "next", "_fixedSizeVirtualScrollStrategyFactory", "fixedSizeDir", "_scrollStrategy", "CdkFixedSizeVirtualScroll", "value", "coerceNumberProperty", "ngOnChanges", "dir", "selectors", "inputs", "standalone", "features", "provide", "useFactory", "deps", "forwardRef", "Directive", "args", "selector", "providers", "Input", "DEFAULT_SCROLL_TIME", "ScrollDispatcher", "_ngZone", "_platform", "document", "_scrolled", "_globalSubscription", "_scrolledCount", "scrollContainers", "Map", "_document", "register", "scrollable", "has", "set", "elementScrolled", "subscribe", "deregister", "scrollableReference", "get", "unsubscribe", "delete", "scrolled", "auditTimeInMs", "isBrowser", "of", "Observable", "observer", "_addGlobalListener", "subscription", "auditTime", "_removeGlobalListener", "ngOnDestroy", "forEach", "_", "container", "ancestorScrolled", "elementOrElementRef", "ancestors", "getAncestorScrollContainers", "filter", "target", "indexOf", "scrollingContainers", "_subscription", "_scrollableContainsElement", "push", "_getWindow", "defaultView", "window", "element", "coerceElement", "scrollableElement", "getElementRef", "nativeElement", "parentElement", "runOutsideAngular", "fromEvent", "fac", "ScrollDispatcher_Factory", "t", "NgZone", "Platform", "DOCUMENT", "prov", "factory", "providedIn", "Injectable", "Optional", "Inject", "CdkScrollable", "elementRef", "scrollDispatcher", "ngZone", "dir", "_destroyed", "_elementScrolled", "takeUntil", "ngOnInit", "scrollTo", "options", "el", "isRtl", "left", "right", "bottom", "top", "scrollHeight", "clientHeight", "getRtlScrollAxisType", "scrollWidth", "clientWidth", "_applyScrollToOptions", "supportsScrollBehavior", "scrollTop", "scrollLeft", "from", "LEFT", "RIGHT", "ElementRef", "Directionality", "DEFAULT_RESIZE_TIME", "ViewportRuler", "_change", "_changeListener", "event", "addEventListener", "change", "_viewportSize", "removeEventListener", "_updateViewportSize", "output", "width", "height", "getViewportRect", "scrollPosition", "getViewportScrollPosition", "documentElement", "documentRect", "getBoundingClientRect", "body", "scrollY", "scrollX", "throttleTime", "innerWidth", "innerHeight", "ViewportRuler_Factory", "VIRTUAL_SCROLLABLE", "CdkVirtualScrollable", "measureViewportSize", "orientation", "viewportEl", "rangesEqual", "r1", "r2", "SCROLL_SCHEDULER", "requestAnimationFrame", "animationFrameScheduler", "asapScheduler", "CdkVirtualScrollViewport", "_orientation", "_calculateSpacerSize", "_changeDetectorRef", "viewportRuler", "inject", "_detachedSubject", "_renderedRangeSubject", "appendOnly", "Promise", "resolve", "then", "run", "renderedRangeStream", "_totalContentSize", "_totalContentWidth", "_totalContentHeight", "_renderedRange", "_dataLength", "_renderedContentOffset", "_renderedContentOffsetNeedsRewrite", "_isChangeDetectionPending", "_runAfterChangeDetection", "_viewportChanges", "Subscription", "EMPTY", "checkViewportSize", "classList", "add", "_measureViewportSize", "startWith", "_markChangeDetectionNeeded", "forOf", "_forOf", "dataStream", "data", "newLength", "length", "_doChangeDetection", "measureBoundingClientRectWithScrollOffset", "size", "range", "getOffsetToRenderedContentStart", "offset", "to", "isHorizontal", "axis", "axisDirection", "transform", "Number", "_renderedContentTransform", "measureRenderedContentSize", "_from", "measureViewportOffset", "fromRect", "scrollerClientRect", "viewportClientRect", "contentEl", "_contentWrapper", "offsetWidth", "offsetHeight", "measureRangeSize", "runAfter", "style", "markForCheck", "runAfterChangeDetection", "fn", "ChangeDetectorRef", "viewQuery", "CdkVirtualScrollViewport_Query", "rf", "ctx", "booleanAttribute", "outputs", "virtualScrollable", "styles", "encapsulation", "changeDetection", "Component", "host", "ViewEncapsulation", "None", "ChangeDetectionStrategy", "OnPush", "template", "Output", "ViewChild", "static", "getOffset", "direction", "node", "rect", "CdkVirtualForOf", "cdkVirtualForOf", "_cdkVirtualForOf", "isDataSource", "_dataSourceChanges", "ArrayDataSource", "isObservable", "Array", "cdkVirtualForTrackBy", "_cdkVirtualForTrackBy", "_needsUpdate", "item", "undefined", "cdkVirtualForTemplate", "_template", "cdkVirtualForTemplateCacheSize", "_viewRepeater", "viewCacheSize", "_viewContainerRef", "_differs", "viewChange", "pairwise", "switchMap", "prev", "cur", "_changeDataSource", "shareReplay", "_differ", "_data", "_onRenderedDataChange", "observers", "renderedStartIndex", "rangeLen", "firstNode", "lastNode", "i", "view", "rootNodes", "ngDoCheck", "changes", "diff", "_renderedItems", "_updateContext", "_applyChanges", "slice", "find", "create", "oldDs", "newDs", "disconnect", "connect", "count", "context", "_updateComputedContextProperties", "detectChanges", "applyChanges", "record", "_adjustedPreviousIndex", "currentIndex", "_getEmbeddedViewArgs", "forEachIdentityChange", "$implicit", "first", "last", "even", "odd", "templateRef", "CdkVirtualForOf_Factory", "ViewContainerRef", "TemplateRef", "IterableDiffers", "_VIEW_REPEATER_STRATEGY", "useClass", "_RecycleViewRepeaterStrategy", "SkipSelf", "CdkVirtualScrollableElement", "hostAttrs", "useExisting", "CdkVirtualScrollableWindow", "CdkScrollableModule", "imports", "exports", "NgModule", "ScrollingModule", "mod", "BidiModule", "inj", "throwNullPortalError", "Error", "throwPortalAlreadyAttachedError", "throwPortalOutletAlreadyDisposedError", "throwUnknownPortalTypeError", "throwNullPortalOutletError", "throwNoPortalAttachedError", "Portal", "attach", "host", "ngDevMode", "hasAttached", "_attachedHost", "detach", "isAttached", "setAttachedHost", "ComponentPortal", "constructor", "component", "viewContainerRef", "injector", "componentFactoryResolver", "projectableNodes", "TemplatePortal", "templateRef", "context", "origin", "elementRef", "undefined", "DomPortal", "element", "ElementRef", "nativeElement", "BasePortalOutlet", "_isDisposed", "attachDomPortal", "_attachedPortal", "portal", "attachComponentPortal", "attachTemplatePortal", "_invokeDisposeFn", "dispose", "setDisposeFn", "fn", "_disposeFn", "DomPortalOutlet", "BasePortalOutlet", "constructor", "outletElement", "_componentFactoryResolver", "_appRef", "_defaultInjector", "_document", "attachDomPortal", "portal", "ngDevMode", "Error", "element", "parentNode", "anchorNode", "createComment", "insertBefore", "appendChild", "_attachedPortal", "setDisposeFn", "replaceChild", "attachComponentPortal", "resolver", "componentFactoryResolver", "componentFactory", "resolveComponentFactory", "component", "componentRef", "viewContainerRef", "createComponent", "length", "injector", "projectableNodes", "undefined", "destroy", "create", "Injector", "NULL", "attachView", "hostView", "viewCount", "detachView", "_getComponentRootNode", "attachTemplatePortal", "viewContainer", "viewRef", "createEmbeddedView", "templateRef", "context", "rootNodes", "forEach", "rootNode", "detectChanges", "index", "indexOf", "remove", "dispose", "CdkPortal", "TemplatePortal", "constructor", "templateRef", "viewContainerRef", "TemplateRef", "ViewContainerRef", "selectors", "exportAs", "features", "Directive", "args", "selector", "TemplatePortalDirective", "t", "dir", "provide", "useExisting", "providers", "CdkPortalOutlet", "BasePortalOutlet", "_componentFactoryResolver", "_viewContainerRef", "_document", "_isInitialized", "attached", "EventEmitter", "attachDomPortal", "portal", "ngDevMode", "Error", "element", "parentNode", "anchorNode", "createComment", "setAttachedHost", "insertBefore", "_getRootNode", "appendChild", "_attachedPortal", "setDisposeFn", "replaceChild", "hasAttached", "detach", "attach", "attachedRef", "_attachedRef", "ngOnInit", "ngOnDestroy", "dispose", "attachComponentPortal", "resolver", "componentFactoryResolver", "componentFactory", "resolveComponentFactory", "component", "ref", "createComponent", "length", "injector", "projectableNodes", "undefined", "hostView", "rootNodes", "destroy", "emit", "attachTemplatePortal", "viewRef", "createEmbeddedView", "context", "clear", "nativeElement", "nodeType", "ELEMENT_NODE", "fac", "CdkPortalOutlet_Factory", "ComponentFactoryResolver", "DOCUMENT", "inputs", "outputs", "Inject", "Output", "PortalHostDirective", "PortalModule", "mod", "declarations", "exports", "NgModule", "scrollBehaviorSupported", "supportsScrollBehavior", "BlockScrollStrategy", "constructor", "_viewportRuler", "document", "_previousHTMLStyles", "top", "left", "_isEnabled", "_document", "attach", "enable", "_canBeEnabled", "root", "documentElement", "_previousScrollPosition", "getViewportScrollPosition", "style", "coerceCssPixelValue", "classList", "add", "disable", "html", "body", "htmlStyle", "bodyStyle", "previousHtmlScrollBehavior", "scrollBehavior", "previousBodyScrollBehavior", "remove", "window", "scroll", "contains", "viewport", "getViewportSize", "scrollHeight", "height", "scrollWidth", "width", "getMatScrollStrategyAlreadyAttachedError", "Error", "CloseScrollStrategy", "_scrollDispatcher", "_ngZone", "_config", "_scrollSubscription", "_detach", "_overlayRef", "hasAttached", "run", "detach", "overlayRef", "ngDevMode", "stream", "scrolled", "pipe", "filter", "scrollable", "overlayElement", "getElementRef", "nativeElement", "threshold", "_initialScrollPosition", "subscribe", "scrollPosition", "Math", "abs", "updatePosition", "unsubscribe", "NoopScrollStrategy", "isElementScrolledOutsideView", "element", "scrollContainers", "some", "containerBounds", "outsideAbove", "bottom", "outsideBelow", "outsideLeft", "right", "outsideRight", "isElementClippedByScrolling", "scrollContainerRect", "clippedAbove", "clippedBelow", "clippedLeft", "clippedRight", "RepositionScrollStrategy", "throttle", "scrollThrottle", "autoClose", "overlayRect", "getBoundingClientRect", "parentRects", "ScrollStrategyOptions", "noop", "close", "config", "block", "reposition", "fac", "ScrollStrategyOptions_Factory", "t", "inject", "ScrollDispatcher", "ViewportRuler", "NgZone", "DOCUMENT", "prov", "defineInjectable", "token", "factory", "providedIn", "setClassMetadata", "Injectable", "Inject", "OverlayConfig", "scrollStrategy", "panelClass", "hasBackdrop", "backdropClass", "disposeOnNavigation", "configKeys", "Object", "keys", "key", "undefined", "ConnectedOverlayPositionChange", "constructor", "connectionPair", "scrollableViewProperties", "validateVerticalPosition", "property", "value", "Error", "validateHorizontalPosition", "BaseOverlayDispatcher", "document", "_attachedOverlays", "_document", "ngOnDestroy", "detach", "add", "overlayRef", "remove", "push", "index", "indexOf", "splice", "length", "fac", "BaseOverlayDispatcher_Factory", "t", "inject", "DOCUMENT", "prov", "defineInjectable", "token", "factory", "providedIn", "setClassMetadata", "Injectable", "Inject", "OverlayKeyboardDispatcher", "_ngZone", "_keydownListener", "event", "overlays", "i", "_keydownEvents", "observers", "keydownEvents", "run", "next", "_isAttached", "runOutsideAngular", "body", "addEventListener", "removeEventListener", "OverlayKeyboardDispatcher_Factory", "NgZone", "Optional", "OverlayOutsideClickDispatcher", "_platform", "_cursorStyleIsSet", "_pointerDownListener", "_pointerDownEventTarget", "_getEventTarget", "_clickListener", "target", "origin", "type", "slice", "_outsidePointerEvents", "hasAttached", "overlayElement", "contains", "outsidePointerEvents", "_addEventListeners", "IOS", "_cursorOriginalValue", "style", "cursor", "OverlayOutsideClickDispatcher_Factory", "Platform", "OverlayContainer", "_containerElement", "getContainerElement", "_createContainer", "containerClass", "isBrowser", "_isTestEnvironment", "oppositePlatformContainers", "querySelectorAll", "container", "createElement", "classList", "setAttribute", "appendChild", "OverlayContainer_Factory", "OverlayRef", "_portalOutlet", "_host", "_pane", "_config", "_keyboardDispatcher", "_location", "_outsideClickDispatcher", "_animationsDisabled", "_backdropElement", "_backdropClick", "Subject", "_attachments", "_detachments", "_locationChanges", "Subscription", "EMPTY", "_backdropClickHandler", "_backdropTransitionendHandler", "_disposeBackdrop", "scrollStrategy", "_scrollStrategy", "attach", "_positionStrategy", "positionStrategy", "backdropElement", "hostElement", "portal", "parentElement", "_previousHostParent", "attachResult", "_updateStackingOrder", "_updateElementSize", "_updateElementDirection", "enable", "onStable", "pipe", "take", "subscribe", "updatePosition", "_togglePointerEvents", "hasBackdrop", "_attachBackdrop", "panelClass", "_toggleClasses", "disposeOnNavigation", "dispose", "onDestroy", "Promise", "resolve", "then", "detachBackdrop", "disable", "detachmentResult", "_detachContentWhenStable", "unsubscribe", "isAttached", "_disposeScrollStrategy", "complete", "backdropClick", "attachments", "detachments", "getConfig", "apply", "updatePositionStrategy", "strategy", "updateSize", "sizeConfig", "setDirection", "dir", "direction", "addPanelClass", "classes", "removePanelClass", "getDirection", "updateScrollStrategy", "width", "coerceCssPixelValue", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "enablePointer", "pointerEvents", "showingClass", "backdropClass", "insertBefore", "requestAnimationFrame", "nextSibling", "parentNode", "backdropToDetach", "_backdropTimeout", "setTimeout", "element", "cssClasses", "isAdd", "coerceArray", "filter", "c", "subscription", "takeUntil", "merge", "children", "backdrop", "clearTimeout", "undefined", "boundingBoxClass", "cssUnitPattern", "FlexibleConnectedPositionStrategy", "positions", "_preferredPositions", "connectedTo", "_viewportRuler", "_overlayContainer", "_lastBoundingBoxSize", "_isPushed", "_canPush", "_growAfterOpen", "_hasFlexibleDimensions", "_positionLocked", "_viewportMargin", "_scrollables", "_positionChanges", "_resizeSubscription", "_offsetX", "_offsetY", "_appliedPanelClasses", "positionChanges", "setOrigin", "_overlayRef", "ngDevMode", "_validatePositions", "_boundingBox", "_isDisposed", "_isInitialRender", "_lastPosition", "change", "reapplyLastPosition", "_clearPanelClasses", "_resetOverlayElementStyles", "_resetBoundingBoxStyles", "_viewportRect", "_getNarrowedViewportRect", "_originRect", "_getOriginRect", "_overlayRect", "getBoundingClientRect", "_containerRect", "originRect", "overlayRect", "viewportRect", "containerRect", "flexibleFits", "fallback", "pos", "originPoint", "_getOriginPoint", "overlayPoint", "_getOverlayPoint", "overlayFit", "_getOverlayFit", "isCompletelyWithinViewport", "_applyPosition", "_canFitWithFlexibleDimensions", "position", "boundingBoxRect", "_calculateBoundingBoxRect", "visibleArea", "bestFit", "bestScore", "fit", "score", "weight", "_previousPushAmount", "extendStyles", "top", "left", "right", "bottom", "alignItems", "justifyContent", "lastPosition", "withScrollableContainers", "scrollables", "withPositions", "withViewportMargin", "margin", "withFlexibleDimensions", "flexibleDimensions", "withGrowAfterOpen", "growAfterOpen", "withPush", "canPush", "withLockedPosition", "isLocked", "_origin", "withDefaultOffsetX", "offset", "withDefaultOffsetY", "withTransformOriginOn", "selector", "_transformOriginSelector", "x", "originX", "startX", "_isRtl", "endX", "y", "originY", "overlayStartX", "overlayX", "overlayStartY", "overlayY", "point", "rawOverlayRect", "viewport", "overlay", "getRoundedBoundingClientRect", "offsetX", "_getOffset", "offsetY", "leftOverflow", "rightOverflow", "topOverflow", "bottomOverflow", "visibleWidth", "_subtractOverflows", "visibleHeight", "fitsInViewportVertically", "fitsInViewportHorizontally", "availableHeight", "availableWidth", "getPixelValue", "verticalFit", "horizontalFit", "_pushOverlayOnScreen", "start", "scrollPosition", "overflowRight", "Math", "max", "overflowBottom", "overflowTop", "overflowLeft", "pushX", "pushY", "_setTransformOrigin", "_setOverlayElementStyles", "_setBoundingBoxStyles", "_addPanelClasses", "_getScrollVisibility", "changeEvent", "elements", "xOrigin", "yOrigin", "transformOrigin", "isRtl", "smallestDistanceToViewportEdge", "min", "previousHeight", "isBoundedByRightViewportEdge", "isBoundedByLeftViewportEdge", "previousWidth", "styles", "_hasExactPosition", "transform", "hasExactPosition", "hasFlexibleDimensions", "config", "getViewportScrollPosition", "_getExactOverlayY", "_getExactOverlayX", "transformString", "trim", "documentHeight", "documentElement", "clientHeight", "horizontalStyleProperty", "documentWidth", "clientWidth", "originBounds", "overlayBounds", "scrollContainerBounds", "map", "scrollable", "getElementRef", "nativeElement", "isOriginClipped", "isElementClippedByScrolling", "isOriginOutsideView", "isElementScrolledOutsideView", "isOverlayClipped", "isOverlayOutsideView", "overflows", "reduce", "currentValue", "currentOverflow", "axis", "forEach", "pair", "cssClass", "ElementRef", "Element", "destination", "source", "key", "hasOwnProperty", "input", "units", "split", "parseFloat", "clientRect", "floor", "wrapperClass", "GlobalPositionStrategy", "constructor", "_cssPosition", "_topOffset", "_bottomOffset", "_alignItems", "_xPosition", "_xOffset", "_width", "_height", "_isDisposed", "attach", "overlayRef", "config", "getConfig", "_overlayRef", "width", "updateSize", "height", "hostElement", "classList", "add", "top", "value", "left", "bottom", "right", "start", "end", "centerHorizontally", "offset", "centerVertically", "apply", "hasAttached", "styles", "overlayElement", "style", "parentStyles", "maxWidth", "maxHeight", "shouldBeFlushHorizontally", "shouldBeFlushVertically", "xPosition", "xOffset", "isRtl", "direction", "marginLeft", "marginRight", "justifyContent", "position", "marginTop", "marginBottom", "alignItems", "dispose", "parent", "remove", "OverlayPositionBuilder", "_viewportRuler", "_document", "_platform", "_overlayContainer", "global", "flexibleConnectedTo", "origin", "FlexibleConnectedPositionStrategy", "fac", "OverlayPositionBuilder_Factory", "t", "inject", "ViewportRuler", "DOCUMENT", "Platform", "OverlayContainer", "prov", "defineInjectable", "token", "factory", "providedIn", "setClassMetadata", "Injectable", "Inject", "nextUniqueId", "Overlay", "scrollStrategies", "_componentFactoryResolver", "_positionBuilder", "_keyboardDispatcher", "_injector", "_ngZone", "_directionality", "_location", "_outsideClickDispatcher", "_animationsModuleType", "create", "host", "_createHostElement", "pane", "_createPaneElement", "portalOutlet", "_createPortalOutlet", "overlayConfig", "OverlayConfig", "OverlayRef", "createElement", "id", "appendChild", "getContainerElement", "_appRef", "get", "ApplicationRef", "DomPortalOutlet", "ScrollStrategyOptions", "ComponentFactoryResolver", "OverlayKeyboardDispatcher", "Injector", "NgZone", "Directionality", "Location", "OverlayOutsideClickDispatcher", "ANIMATION_MODULE_TYPE", "Optional", "defaultPositionList", "originX", "originY", "overlayX", "overlayY", "CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY", "InjectionToken", "CdkOverlayOrigin", "elementRef", "directiveInject", "ElementRef", "defineDirective", "type", "selectors", "exportAs", "standalone", "Directive", "args", "selector", "CdkConnectedOverlay", "offsetX", "_offsetX", "_position", "_updatePositionStrategy", "offsetY", "_offsetY", "disposeOnNavigation", "_disposeOnNavigation", "_overlay", "templateRef", "viewContainerRef", "scrollStrategyFactory", "_dir", "_backdropSubscription", "Subscription", "EMPTY", "_attachSubscription", "_detachSubscription", "_positionSubscription", "viewportMargin", "open", "disableClose", "hasBackdrop", "lockPosition", "flexibleDimensions", "growAfterOpen", "push", "backdropClick", "EventEmitter", "positionChange", "detach", "overlayKeydown", "overlayOutsideClick", "_templatePortal", "TemplatePortal", "_scrollStrategyFactory", "scrollStrategy", "dir", "ngOnDestroy", "unsubscribe", "ngOnChanges", "changes", "minWidth", "minHeight", "_attachOverlay", "_detachOverlay", "_createOverlay", "positions", "length", "_buildConfig", "attachments", "subscribe", "emit", "detachments", "keydownEvents", "event", "next", "keyCode", "ESCAPE", "hasModifierKey", "preventDefault", "outsidePointerEvents", "positionStrategy", "_createPositionStrategy", "backdropClass", "panelClass", "map", "currentPosition", "undefined", "setOrigin", "_getFlexibleConnectedPositionStrategyOrigin", "withPositions", "withFlexibleDimensions", "withPush", "withGrowAfterOpen", "withViewportMargin", "withLockedPosition", "withTransformOriginOn", "transformOriginSelector", "strategy", "observers", "positionChanges", "pipe", "takeWhile", "CdkConnectedOverlay_Factory", "TemplateRef", "ViewContainerRef", "inputs", "booleanAttribute", "outputs", "features", "InputTransformsFeature", "NgOnChangesFeature", "Input", "alias", "transform", "Output", "CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY", "overlay", "reposition", "CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER", "provide", "deps", "useFactory", "OverlayModule", "mod", "defineNgModule", "imports", "BidiModule", "PortalModule", "ScrollingModule", "exports", "inj", "defineInjector", "providers", "NgModule", "FullscreenOverlayContainer", "platform", "_fullScreenEventName", "_fullScreenListener", "removeEventListener", "_createContainer", "_adjustParentForFullscreenChange", "_addFullscreenChangeListener", "_containerElement", "fullscreenElement", "getFullscreenElement", "body", "fn", "eventName", "_getEventName", "addEventListener", "fullscreenEnabled", "webkitFullscreenEnabled", "mozFullScreenEnabled", "msFullscreenEnabled", "webkitFullscreenElement", "mozFullScreenElement", "msFullscreenElement", "FullscreenOverlayContainer_Factory", "_c0", "_c1", "_c2", "_c3", "_c4", "_c5", "_c6", "_c7", "_c8", "_c9", "_c10", "MAT_BUTTON_HOST", "HOST_SELECTOR_MDC_CLASS_PAIR", "attribute", "mdcClasses", "MatButtonBase", "ripple", "_rippleLoader", "getRipple", "_elementRef", "nativeElement", "v", "attachRipple", "disableRipple", "_disableRipple", "value", "_updateRippleDisabled", "disabled", "_disabled", "constructor", "_platform", "_ngZone", "_animationMode", "_focusMonitor", "inject", "FocusMonitor", "MatRippleLoader", "_isFab", "configureRipple", "className", "element", "classList", "hasAttribute", "add", "ngAfterViewInit", "monitor", "ngOnDestroy", "stopMonitoring", "focus", "_origin", "options", "focusVia", "setDisabled", "inputs", "color", "booleanAttribute", "features", "Directive", "Input", "transform", "MAT_ANCHOR_HOST", "MatAnchorBase", "elementRef", "platform", "ngZone", "animationMode", "_haltDisabledEvents", "event", "preventDefault", "stopImmediatePropagation", "ngOnInit", "runOutsideAngular", "addEventListener", "removeEventListener", "dir", "tabIndex", "undefined", "numberAttribute", "args", "MatButton", "fac", "MatButton_Factory", "t", "ElementRef", "Platform", "NgZone", "ANIMATION_MODULE_TYPE", "cmp", "selectors", "hostVars", "hostBindings", "MatButton_HostBindings", "rf", "ctx", "styles", "encapsulation", "changeDetection", "Component", "selector", "host", "exportAs", "ViewEncapsulation", "None", "ChangeDetectionStrategy", "OnPush", "template", "Optional", "Inject", "MatAnchor", "MatAnchor_Factory", "MatAnchor_HostBindings", "MAT_FAB_DEFAULT_OPTIONS", "InjectionToken", "providedIn", "factory", "MAT_FAB_DEFAULT_OPTIONS_FACTORY", "defaults", "MatFabButton", "_options", "MatFabButton_HostBindings", "extended", "MatMiniFabButton", "MatMiniFabButton_HostBindings", "MatFabAnchor", "MatFabAnchor_HostBindings", "MatMiniFabAnchor", "MatMiniFabAnchor_HostBindings", "MatIconButton", "centered", "MatIconButton_Factory", "MatIconButton_HostBindings", "MatIconAnchor", "MatIconAnchor_Factory", "MatIconAnchor_HostBindings", "MatButtonModule", "mod", "declarations", "imports", "MatCommonModule", "MatRippleModule", "exports", "inj", "NgModule", "BaseControlValueAccessor", "constructor", "_renderer", "_elementRef", "onChange", "_", "onTouched", "setProperty", "key", "value", "nativeElement", "registerOnTouched", "fn", "registerOnChange", "setDisabledState", "isDisabled", "Renderer2", "ElementRef", "Directive", "BuiltInControlValueAccessor", "t", "features", "NG_VALUE_ACCESSOR", "InjectionToken", "CHECKBOX_VALUE_ACCESSOR", "provide", "useExisting", "forwardRef", "CheckboxControlValueAccessor", "multi", "writeValue", "selectors", "hostBindings", "CheckboxControlValueAccessor_HostBindings", "rf", "ctx", "CheckboxControlValueAccessor_blur_HostBindingHandler", "args", "selector", "host", "providers", "DEFAULT_VALUE_ACCESSOR", "DefaultValueAccessor", "_isAndroid", "userAgent", "getDOM", "getUserAgent", "test", "toLowerCase", "COMPOSITION_BUFFER_MODE", "renderer", "elementRef", "_compositionMode", "_composing", "normalizedValue", "_handleInput", "_compositionStart", "_compositionEnd", "fac", "DefaultValueAccessor_Factory", "DefaultValueAccessor_HostBindings", "DefaultValueAccessor_blur_HostBindingHandler", "DefaultValueAccessor_compositionstart_HostBindingHandler", "DefaultValueAccessor_compositionend_HostBindingHandler", "$event", "Optional", "Inject", "isEmptyInputValue", "Array", "isArray", "length", "hasValidLength", "NG_VALIDATORS", "NG_ASYNC_VALIDATORS", "EMAIL_REGEXP", "Validators", "min", "minValidator", "max", "maxValidator", "required", "control", "requiredValidator", "requiredTrue", "requiredTrueValidator", "email", "emailValidator", "minLength", "minLengthValidator", "maxLength", "maxLengthValidator", "pattern", "patternValidator", "nullValidator", "compose", "validators", "composeAsync", "parseFloat", "isNaN", "regex", "regexStr", "charAt", "RegExp", "toString", "isPresent", "o", "toObservable", "obs", "isPromise", "from", "ngDevMode", "isSubscribable", "errorMessage", "RuntimeError", "mergeErrors", "arrayOfErrors", "res", "forEach", "errors", "Object", "keys", "executeValidators", "map", "validator", "isValidatorFn", "validate", "normalizeValidators", "c", "presentValidators", "filter", "composeValidators", "observables", "forkJoin", "pipe", "composeAsyncValidators", "mergeValidators", "controlValidators", "dirValidator", "getControlValidators", "_rawValidators", "getControlAsyncValidators", "_rawAsyncValidators", "makeValidatorsArray", "hasValidator", "includes", "addValidators", "currentValidators", "current", "validatorsToAdd", "v", "push", "removeValidators", "AbstractControlDirective", "_onDestroyCallbacks", "valid", "invalid", "pending", "disabled", "enabled", "pristine", "dirty", "touched", "status", "untouched", "statusChanges", "valueChanges", "path", "_setValidators", "_composedValidatorFn", "_setAsyncValidators", "_composedAsyncValidatorFn", "asyncValidator", "_registerOnDestroy", "_invokeOnDestroyCallbacks", "reset", "undefined", "hasError", "errorCode", "getError", "ControlContainer", "formDirective", "NgControl", "_parent", "name", "valueAccessor", "AbstractControlStatus", "cd", "_cd", "isTouched", "isUntouched", "isPristine", "isDirty", "isValid", "isInvalid", "isPending", "isSubmitted", "submitted", "ngControlStatusHost", "ngGroupStatusHost", "NgControlStatus", "hostVars", "NgControlStatus_HostBindings", "Self", "NgControlStatusGroup", "NgControlStatusGroup_HostBindings", "formControlNameExample", "formGroupNameExample", "formArrayNameExample", "ngModelGroupExample", "ngModelWithFormGroupExample", "controlParentException", "ngModelGroupException", "missingFormException", "groupParentException", "arrayParentException", "disabledAttrWarning", "asyncValidatorsDroppedWithOptsWarning", "ngModelWarning", "directiveName", "describeKey", "isFormGroup", "noControlsError", "missingControlError", "missingControlValueError", "VALID", "INVALID", "PENDING", "DISABLED", "pickValidators", "validatorOrOpts", "isOptionsObj", "coerceToValidator", "pickAsyncValidators", "console", "warn", "asyncValidators", "coerceToAsyncValidator", "assertControlPresent", "parent", "isGroup", "controls", "collection", "assertAllValuesPresent", "_forEachChild", "AbstractControl", "_pendingDirty", "_hasOwnPendingAsyncValidator", "_pendingTouched", "_onCollectionChange", "_onDisabledChange", "_assignValidators", "_assignAsyncValidators", "validatorFn", "asyncValidatorFn", "updateOn", "_updateOn", "setValidators", "setAsyncValidators", "addAsyncValidators", "removeAsyncValidators", "hasAsyncValidator", "clearValidators", "clearAsyncValidators", "markAsTouched", "opts", "onlySelf", "markAllAsTouched", "markAsUntouched", "_updateTouched", "markAsDirty", "markAsPristine", "_updatePristine", "markAsPending", "emitEvent", "emit", "disable", "skipPristineCheck", "_parentMarkedDirty", "_updateValue", "_updateAncestors", "changeFn", "enable", "updateValueAndValidity", "setParent", "getRawValue", "_setInitialStatus", "_cancelExistingSubscription", "_runValidator", "_calculateStatus", "_runAsyncValidator", "_updateTreeValidity", "ctrl", "_allControlsDisabled", "_asyncValidationSubscription", "subscribe", "setErrors", "unsubscribe", "_updateControlsErrors", "get", "currPath", "split", "reduce", "_find", "root", "x", "_initObservables", "EventEmitter", "_anyControlsHaveStatus", "_anyControls", "_anyControlsDirty", "_anyControlsTouched", "_registerOnCollectionChange", "_setUpdateStrategy", "parentDirty", "slice", "FormGroup", "validateFormGroupControls", "_setUpControls", "registerControl", "addControl", "options", "removeControl", "setControl", "contains", "controlName", "hasOwnProperty", "setValue", "patchValue", "_reduceChildren", "acc", "_syncPendingControls", "subtreeUpdated", "updated", "child", "cb", "_reduceValue", "condition", "entries", "initValue", "invalidKeys", "join", "FormRecord", "FormGroup", "CALL_SET_DISABLED_STATE", "InjectionToken", "providedIn", "factory", "setDisabledStateDefault", "controlPath", "name", "parent", "path", "setUpControl", "control", "dir", "callSetDisabledState", "ngDevMode", "_throwError", "valueAccessor", "_throwMissingValueAccessorError", "setUpValidators", "writeValue", "value", "disabled", "setDisabledState", "setUpViewChangePipeline", "setUpModelChangePipeline", "setUpBlurPipeline", "setUpDisabledChangeHandler", "cleanUpControl", "validateControlPresenceOnChange", "noop", "_noControlError", "registerOnChange", "registerOnTouched", "cleanUpValidators", "_invokeOnDestroyCallbacks", "_registerOnCollectionChange", "registerOnValidatorChange", "validators", "onChange", "forEach", "validator", "onDisabledChange", "isDisabled", "registerOnDisabledChange", "_registerOnDestroy", "_unregisterOnDisabledChange", "getControlValidators", "setValidators", "mergeValidators", "asyncValidators", "getControlAsyncValidators", "asyncValidator", "setAsyncValidators", "onValidatorChange", "updateValueAndValidity", "_rawValidators", "_rawAsyncValidators", "isControlUpdated", "Array", "isArray", "length", "updatedValidators", "filter", "updatedAsyncValidators", "newValue", "_pendingValue", "_pendingChange", "_pendingDirty", "updateOn", "updateControl", "_pendingTouched", "markAsTouched", "markAsDirty", "setValue", "emitModelToViewChange", "viewToModelUpdate", "emitModelEvent", "_unregisterOnChange", "setUpFormContainer", "cleanUpFormContainer", "message", "messageEnd", "_describeControlLocation", "Error", "join", "loc", "RuntimeError", "_throwInvalidValueAccessorError", "isPropertyUpdated", "changes", "viewModel", "hasOwnProperty", "change", "isFirstChange", "Object", "is", "currentValue", "isBuiltInAccessor", "getPrototypeOf", "constructor", "BuiltInControlValueAccessor", "syncPendingControls", "form", "directives", "_syncPendingControls", "selectValueAccessor", "valueAccessors", "defaultAccessor", "undefined", "builtinAccessor", "customAccessor", "v", "DefaultValueAccessor", "removeListItem$1", "list", "el", "index", "indexOf", "splice", "_ngModelWarning", "type", "instance", "warningConfig", "_ngModelWarningSentOnce", "_ngModelWarningSent", "console", "warn", "ngModelWarning", "formDirectiveProvider$1", "provide", "ControlContainer", "useExisting", "forwardRef", "NgForm", "resolvedPromise$1", "Promise", "resolve", "submitted", "_directives", "Set", "ngSubmit", "EventEmitter", "FormGroup", "composeValidators", "composeAsyncValidators", "ngAfterViewInit", "_setUpdateStrategy", "formDirective", "controls", "addControl", "then", "container", "_findContainer", "registerControl", "emitEvent", "add", "getControl", "get", "removeControl", "delete", "addFormGroup", "group", "removeFormGroup", "getFormGroup", "updateModel", "ctrl", "onSubmit", "$event", "emit", "target", "method", "onReset", "resetForm", "reset", "options", "_updateOn", "pop", "fac", "NgForm_Factory", "t", "NG_VALIDATORS", "NG_ASYNC_VALIDATORS", "NgForm_reset_HostBindingHandler", "Directive", "args", "selector", "providers", "host", "outputs", "exportAs", "Optional", "Self", "Inject", "Input", "removeListItem", "isFormControlState", "formState", "keys", "FormControl", "AbstractControl", "validatorOrOpts", "pickValidators", "pickAsyncValidators", "defaultValue", "_onChange", "_applyFormState", "_initObservables", "onlySelf", "isOptionsObj", "nonNullable", "initialValueIsDefault", "changeFn", "emitViewToModelChange", "patchValue", "markAsPristine", "markAsUntouched", "_updateValue", "_anyControls", "condition", "_allControlsDisabled", "fn", "push", "_onDisabledChange", "_forEachChild", "cb", "disable", "enable", "isFormControl", "control", "FormControl", "AbstractFormGroupDirective", "ControlContainer", "ngOnInit", "_checkParentType", "formDirective", "addFormGroup", "ngOnDestroy", "removeFormGroup", "getFormGroup", "path", "controlPath", "name", "toString", "_parent", "t", "features", "Directive", "modelParentException", "RuntimeError", "formControlNameExample", "ngModelWithFormGroupExample", "formGroupNameException", "formGroupNameExample", "ngModelGroupExample", "missingNameException", "modelGroupParentException", "modelGroupProvider", "provide", "useExisting", "forwardRef", "NgModelGroup", "constructor", "parent", "validators", "asyncValidators", "_setValidators", "_setAsyncValidators", "NgForm", "ngDevMode", "NG_VALIDATORS", "NG_ASYNC_VALIDATORS", "selectors", "inputs", "exportAs", "args", "selector", "providers", "Host", "SkipSelf", "Optional", "Self", "Inject", "Input", "formControlBinding$1", "NgControl", "NgModel", "resolvedPromise", "Promise", "resolve", "valueAccessors", "_changeDetectorRef", "callSetDisabledState", "_registered", "update", "EventEmitter", "valueAccessor", "selectValueAccessor", "ngOnChanges", "changes", "_checkForErrors", "_checkName", "oldName", "previousValue", "removeControl", "_getPath", "_setUpControl", "_updateDisabled", "isPropertyUpdated", "viewModel", "_updateValue", "model", "viewToModelUpdate", "newValue", "emit", "_setUpdateStrategy", "_isStandalone", "_setUpStandalone", "addControl", "options", "updateOn", "_updateOn", "standalone", "setUpControl", "updateValueAndValidity", "emitEvent", "value", "then", "setValue", "emitViewToModelChange", "markForCheck", "disabledValue", "currentValue", "isDisabled", "booleanAttribute", "disabled", "disable", "enable", "controlName", "NG_VALUE_ACCESSOR", "ChangeDetectorRef", "CALL_SET_DISABLED_STATE", "Output", "NgNoValidate", "hostAttrs", "host", "NUMBER_VALUE_ACCESSOR", "NumberValueAccessor", "multi", "BuiltInControlValueAccessor", "writeValue", "normalizedValue", "setProperty", "registerOnChange", "fn", "onChange", "parseFloat", "hostBindings", "NumberValueAccessor_HostBindings", "rf", "ctx", "NumberValueAccessor_blur_HostBindingHandler", "RADIO_VALUE_ACCESSOR", "RadioControlValueAccessor", "throwNameError", "RadioControlRegistryModule", "NgModule", "RadioControlRegistry", "_accessors", "add", "accessor", "push", "remove", "i", "length", "splice", "select", "forEach", "c", "_isSameGroup", "fireUncheck", "controlPair", "_control", "prov", "factory", "fac", "providedIn", "Injectable", "renderer", "elementRef", "_registry", "_injector", "setDisabledStateFired", "inject", "optional", "setDisabledStateDefault", "get", "_state", "_fn", "setDisabledState", "formControlName", "Renderer2", "ElementRef", "Injector", "RadioControlValueAccessor_HostBindings", "RANGE_VALUE_ACCESSOR", "RangeValueAccessor", "RangeValueAccessor_HostBindings", "RangeValueAccessor_input_HostBindingHandler", "$event", "RangeValueAccessor_blur_HostBindingHandler", "NG_MODEL_WITH_FORM_CONTROL_WARNING", "InjectionToken", "formControlBinding", "FormControlDirective", "console", "warn", "disabledAttrWarning", "_ngModelWarningConfig", "_ngModelWarningSent", "_isControlChanged", "previousForm", "cleanUpControl", "form", "_ngModelWarning", "hasOwnProperty", "_ngModelWarningSentOnce", "outputs", "formDirectiveProvider", "FormGroupDirective", "submitted", "_onCollectionChange", "_updateDomValue", "directives", "ngSubmit", "_checkFormPresent", "_updateValidators", "_updateRegistrations", "_oldForm", "cleanUpValidators", "_registerOnCollectionChange", "dir", "ctrl", "getControl", "removeListItem$1", "_setUpFormContainer", "_cleanUpFormContainer", "addFormArray", "removeFormArray", "getFormArray", "updateModel", "onSubmit", "syncPendingControls", "target", "method", "onReset", "resetForm", "undefined", "reset", "oldCtrl", "newCtrl", "_updateTreeValidity", "setUpFormContainer", "isControlUpdated", "cleanUpFormContainer", "setUpValidators", "missingFormException", "FormGroupDirective_Factory", "FormGroupDirective_HostBindings", "FormGroupDirective_reset_HostBindingHandler", "formGroupNameProvider", "FormGroupName", "_hasInvalidParent", "groupParentException", "formArrayNameProvider", "FormArrayName", "arrayParentException", "controlNameBinding", "FormControlName", "_added", "ngModelGroupException", "controlParentException", "FormControlName_Factory", "SELECT_VALUE_ACCESSOR", "SelectControlValueAccessor", "_buildValueString$1", "id", "slice", "_extractId$1", "valueString", "split", "_optionMap", "Map", "_idCounter", "_compareWith", "Object", "is", "compareWith", "JSON", "stringify", "_getOptionId", "_getOptionValue", "_registerOption", "keys", "has", "SelectControlValueAccessor_HostBindings", "SelectControlValueAccessor_blur_HostBindingHandler", "NgSelectOption", "_element", "_renderer", "_select", "ngValue", "set", "_setElementValue", "nativeElement", "delete", "SELECT_MULTIPLE_VALUE_ACCESSOR", "SelectMultipleControlValueAccessor", "_buildValueString", "_extractId", "SelectMultipleControlValueAccessor", "BuiltInControlValueAccessor", "constructor", "_optionMap", "Map", "_idCounter", "_compareWith", "Object", "is", "compareWith", "fn", "ngDevMode", "RuntimeError", "JSON", "stringify", "writeValue", "value", "optionSelectedStateSetter", "Array", "isArray", "ids", "map", "v", "_getOptionId", "opt", "o", "_setSelected", "indexOf", "toString", "forEach", "registerOnChange", "onChange", "element", "selected", "selectedOptions", "undefined", "options", "i", "length", "val", "_getOptionValue", "push", "_registerOption", "id", "set", "keys", "get", "_value", "valueString", "_extractId", "has", "t", "selectors", "hostBindings", "SelectMultipleControlValueAccessor_HostBindings", "rf", "ctx", "SelectMultipleControlValueAccessor_blur_HostBindingHandler", "inputs", "features", "SELECT_MULTIPLE_VALUE_ACCESSOR", "Directive", "args", "selector", "host", "providers", "Input", "NgSelectMultipleOption", "_element", "_renderer", "_select", "ngValue", "_setElementValue", "_buildValueString", "setProperty", "nativeElement", "ngOnDestroy", "delete", "ElementRef", "Renderer2", "Optional", "Host", "toInteger", "parseInt", "toFloat", "parseFloat", "AbstractValidatorDirective", "_validator", "nullValidator", "ngOnChanges", "changes", "inputName", "input", "normalizeInput", "currentValue", "_enabled", "enabled", "createValidator", "_onChange", "validate", "control", "registerOnValidatorChange", "MAX_VALIDATOR", "provide", "NG_VALIDATORS", "useExisting", "forwardRef", "MaxValidator", "multi", "max", "maxValidator", "hostVars", "MaxValidator_HostBindings", "MIN_VALIDATOR", "MinValidator", "min", "minValidator", "MinValidator_HostBindings", "REQUIRED_VALIDATOR", "RequiredValidator", "CHECKBOX_REQUIRED_VALIDATOR", "CheckboxRequiredValidator", "booleanAttribute", "requiredValidator", "RequiredValidator_HostBindings", "required", "requiredTrueValidator", "CheckboxRequiredValidator_HostBindings", "EMAIL_VALIDATOR", "EmailValidator", "emailValidator", "email", "MIN_LENGTH_VALIDATOR", "MinLengthValidator", "minlength", "minLengthValidator", "MinLengthValidator_HostBindings", "MAX_LENGTH_VALIDATOR", "MaxLengthValidator", "maxlength", "maxLengthValidator", "MaxLengthValidator_HostBindings", "PATTERN_VALIDATOR", "PatternValidator", "patternValidator", "PatternValidator_HostBindings", "pattern", "SHARED_FORM_DIRECTIVES", "NgNoValidate", "NgSelectOption", "DefaultValueAccessor", "NumberValueAccessor", "RangeValueAccessor", "CheckboxControlValueAccessor", "SelectControlValueAccessor", "RadioControlValueAccessor", "NgControlStatus", "NgControlStatusGroup", "TEMPLATE_DRIVEN_DIRECTIVES", "NgModel", "NgModelGroup", "NgForm", "REACTIVE_DRIVEN_DIRECTIVES", "FormControlDirective", "FormGroupDirective", "FormControlName", "FormGroupName", "FormArrayName", "InternalFormsSharedModule", "mod", "declarations", "imports", "RadioControlRegistryModule", "exports", "inj", "NgModule", "FormArray", "AbstractControl", "controls", "validatorOrOpts", "asyncValidator", "pickValidators", "pickAsyncValidators", "_initObservables", "_setUpdateStrategy", "_setUpControls", "updateValueAndValidity", "onlySelf", "emitEvent", "at", "index", "_adjustIndex", "_registerControl", "_onCollectionChange", "insert", "splice", "removeAt", "adjustedIndex", "_registerOnCollectionChange", "setControl", "setValue", "assertAllValuesPresent", "newValue", "assertControlPresent", "patchValue", "reset", "_forEachChild", "_updatePristine", "_updateTouched", "getRawValue", "clear", "_syncPendingControls", "subtreeUpdated", "reduce", "updated", "child", "cb", "_updateValue", "filter", "disabled", "_anyControls", "condition", "some", "_allControlsDisabled", "setParent", "_find", "name", "isAbstractControlOptions", "options", "asyncValidators", "undefined", "validators", "updateOn", "FormBuilder", "constructor", "useNonNullable", "nonNullable", "nnfb", "group", "controls", "reducedControls", "_reduceControls", "newOptions", "validator", "asyncValidator", "FormGroup", "record", "FormRecord", "control", "formState", "validatorOrOpts", "FormControl", "array", "createdControls", "map", "c", "_createControl", "FormArray", "Object", "keys", "forEach", "controlName", "AbstractControl", "Array", "isArray", "value", "length", "prov", "factory", "fac", "providedIn", "Injectable", "NonNullableFormBuilder", "inject", "args", "useFactory", "UntypedFormBuilder", "controlsConfig", "t", "VERSION", "Version", "FormsModule", "withConfig", "opts", "ngModule", "providers", "provide", "CALL_SET_DISABLED_STATE", "useValue", "callSetDisabledState", "setDisabledStateDefault", "mod", "declarations", "NgModel", "NgModelGroup", "NgForm", "exports", "InternalFormsSharedModule", "inj", "NgModule", "TEMPLATE_DRIVEN_DIRECTIVES", "ReactiveFormsModule", "NG_MODEL_WITH_FORM_CONTROL_WARNING", "warnOnNgModelWithFormControl", "FormControlDirective", "FormGroupDirective", "FormControlName", "FormGroupName", "FormArrayName", "REACTIVE_DRIVEN_DIRECTIVES", "listenerOptions", "normalizePassiveListenerOptions", "passive", "AutofillMonitor", "constructor", "_platform", "_ngZone", "_monitoredElements", "Map", "monitor", "elementOrRef", "isBrowser", "EMPTY", "element", "coerceElement", "info", "get", "subject", "result", "Subject", "cssClass", "listener", "event", "animationName", "classList", "contains", "add", "run", "next", "target", "isAutofilled", "remove", "runOutsideAngular", "addEventListener", "set", "unlisten", "removeEventListener", "stopMonitoring", "complete", "delete", "ngOnDestroy", "forEach", "_info", "Platform", "NgZone", "prov", "factory", "fac", "providedIn", "Injectable", "CdkAutofill", "_elementRef", "_autofillMonitor", "cdkAutofill", "EventEmitter", "ngOnInit", "subscribe", "emit", "ElementRef", "selectors", "outputs", "Directive", "args", "selector", "Output", "CdkTextareaAutosize", "minRows", "_minRows", "value", "coerceNumberProperty", "_setMinHeight", "maxRows", "_maxRows", "_setMaxHeight", "enabled", "_enabled", "resizeToFitContent", "reset", "placeholder", "_textareaElement", "_cachedPlaceholderHeight", "undefined", "setAttribute", "removeAttribute", "_cacheTextareaPlaceholderHeight", "document", "_destroyed", "_previousMinRows", "_isViewInited", "_handleFocusEvent", "_hasFocus", "type", "_document", "nativeElement", "minHeight", "_cachedLineHeight", "style", "maxHeight", "ngAfterViewInit", "_initialHeight", "height", "window", "_getWindow", "fromEvent", "pipe", "auditTime", "takeUntil", "_cacheTextareaLineHeight", "textareaClone", "cloneNode", "rows", "position", "visibility", "border", "padding", "overflow", "parentNode", "appendChild", "clientHeight", "_measureScrollHeight", "previousMargin", "marginBottom", "isFirefox", "FIREFOX", "needsMarginFiller", "measuringClass", "scrollHeight", "ngDoCheck", "force", "textarea", "_previousValue", "Math", "max", "requestAnimationFrame", "_scrollToCaretPosition", "setTimeout", "_noopInputHandler", "_getDocument", "doc", "defaultView", "selectionStart", "selectionEnd", "isStopped", "setSelectionRange", "CdkTextareaAutosize_Factory", "t", "DOCUMENT", "dir", "hostAttrs", "hostBindings", "CdkTextareaAutosize_HostBindings", "rf", "ctx", "inputs", "booleanAttribute", "exportAs", "features", "host", "Optional", "Inject", "Input", "alias", "transform", "TextFieldModule", "mod", "declarations", "exports", "NgModule", "getMatInputUnsupportedTypeError", "type", "Error", "MAT_INPUT_VALUE_ACCESSOR", "InjectionToken", "MAT_INPUT_INVALID_TYPES", "nextUniqueId", "_MatInputBase", "mixinErrorState", "constructor", "_defaultErrorStateMatcher", "_parentForm", "_parentFormGroup", "ngControl", "stateChanges", "Subject", "MatInput", "disabled", "_disabled", "value", "coerceBooleanProperty", "focused", "next", "id", "_id", "_uid", "required", "_required", "control", "hasValidator", "Validators", "_type", "_validateType", "_isTextarea", "getSupportedInputTypes", "has", "_elementRef", "nativeElement", "_inputValueAccessor", "readonly", "_readonly", "_platform", "inputValueAccessor", "_autofillMonitor", "ngZone", "_formField", "controlType", "autofilled", "_neverEmptyInputTypes", "filter", "t", "_iOSKeyupListener", "event", "el", "target", "selectionStart", "selectionEnd", "setSelectionRange", "element", "nodeName", "toLowerCase", "_previousNativeValue", "IOS", "runOutsideAngular", "addEventListener", "_isServer", "isBrowser", "_isNativeSelect", "_isInFormField", "multiple", "ngAfterViewInit", "monitor", "subscribe", "isAutofilled", "ngOnChanges", "ngOnDestroy", "complete", "stopMonitoring", "removeEventListener", "ngDoCheck", "updateErrorState", "_dirtyCheckNativeValue", "_dirtyCheckPlaceholder", "focus", "options", "_focusChanged", "isFocused", "_onInput", "newValue", "placeholder", "_getPlaceholder", "_previousPlaceholder", "setAttribute", "removeAttribute", "indexOf", "ngDevMode", "_isNeverEmpty", "_isBadInput", "validity", "badInput", "empty", "shouldLabelFloat", "selectElement", "firstOption", "selectedIndex", "label", "setDescribedByIds", "ids", "length", "join", "onContainerClick", "_isInlineSelect", "size", "ElementRef", "Platform", "NgControl", "NgForm", "FormGroupDirective", "ErrorStateMatcher", "AutofillMonitor", "NgZone", "MAT_FORM_FIELD", "selectors", "hostAttrs", "hostVars", "hostBindings", "MatInput_HostBindings", "rf", "ctx", "MatInput_blur_HostBindingHandler", "MatInput_input_HostBindingHandler", "provide", "MatFormFieldControl", "useExisting", "Directive", "args", "selector", "exportAs", "host", "providers", "Optional", "Self", "Inject", "Input", "name", "errorStateMatcher", "userAriaDescribedBy", "MatInputModule", "mod", "declarations", "imports", "MatCommonModule", "MatFormFieldModule", "exports", "TextFieldModule", "NgModule", "_c0", "MatCalendarBody_Conditional_0_Template", "rf", "ctx", "ctx_r0", "_cellPadding", "MatCalendarBody_For_2_Conditional_1_Template", "ctx_r5", "MatCalendarBody_For_2_For_3_Template", "_r11", "ctx_r10", "_cellClicked", "item_r7", "$event", "MatCalendarBody_For_2_For_3_Template_button_focus_1_listener", "restoredCtx", "ctx_r12", "_emitActiveDateChange", "$implicit", "colIndex_r8", "$index", "rowIndex_r3", "ctx_r6", "_isActiveCell", "_isRangeStart", "compareValue", "_isRangeEnd", "_isInRange", "_isComparisonBridgeStart", "_isComparisonBridgeEnd", "_isComparisonStart", "_isComparisonEnd", "_isInComparisonRange", "_isPreviewStart", "_isPreviewEnd", "_isInPreview", "enabled", "_isSelected", "todayValue", "_getDescribedby", "_isComparisonIdentical", "MatCalendarBody_For_2_Template", "row_r2", "ctx_r1", "MatMonthView_For_4_Template", "day_r1", "_c1", "MatCalendar_ng_template_0_Template", "MatCalendar_Case_2_Template", "_r5", "MatCalendar_Case_2_Template_mat_month_view__userSelection_0_listener", "_dateSelected", "MatCalendar_Case_2_Template_mat_month_view_dragStarted_0_listener", "ctx_r7", "_dragStarted", "MatCalendar_Case_2_Template_mat_month_view_dragEnded_0_listener", "ctx_r8", "_dragEnded", "selected", "dateFilter", "maxDate", "minDate", "dateClass", "comparisonStart", "comparisonEnd", "startDateAccessibleName", "endDateAccessibleName", "_activeDrag", "MatCalendar_Case_3_Template", "_r10", "MatCalendar_Case_3_Template_mat_year_view_monthSelected_0_listener", "ctx_r11", "_monthSelectedInYearView", "MatCalendar_Case_3_Template_mat_year_view_selectedChange_0_listener", "_goToDateInView", "ctx_r2", "MatCalendar_Case_4_Template", "_r14", "MatCalendar_Case_4_Template_mat_multi_year_view_yearSelected_0_listener", "ctx_r15", "_yearSelectedInMultiYearView", "MatCalendar_Case_4_Template_mat_multi_year_view_selectedChange_0_listener", "ctx_r16", "ctx_r3", "MatDatepickerContent_ng_template_2_Template", "_c2", "MatDatepickerToggle_Conditional_2_Template", "_c3", "_c4", "_c5", "_c6", "MatDatepickerActions_ng_template_0_Template", "createMissingDateImplError", "provider", "Error", "MatDatepickerIntl", "constructor", "changes", "Subject", "calendarLabel", "openCalendarLabel", "closeCalendarLabel", "prevMonthLabel", "nextMonthLabel", "prevYearLabel", "nextYearLabel", "prevMultiYearLabel", "nextMultiYearLabel", "switchToMonthViewLabel", "switchToMultiYearViewLabel", "startDateLabel", "endDateLabel", "formatYearRange", "start", "end", "formatYearRangeLabel", "prov", "factory", "fac", "providedIn", "Injectable", "MatCalendarCell", "value", "displayValue", "ariaLabel", "cssClasses", "rawValue", "calendarBodyId", "activeCapturingEventOptions", "normalizePassiveListenerOptions", "passive", "capture", "passiveCapturingEventOptions", "passiveEventOptions", "MatCalendarBody", "ngAfterViewChecked", "_focusActiveCellAfterViewChecked", "_focusActiveCell", "_elementRef", "_ngZone", "_platform", "inject", "Platform", "numCols", "activeCell", "isRange", "cellAspectRatio", "previewStart", "previewEnd", "selectedValueChange", "EventEmitter", "previewChange", "activeDateChange", "dragStarted", "dragEnded", "_didDragSinceMouseDown", "_enterHandler", "event", "_skipNextFocus", "type", "target", "cell", "_getCellFromElement", "run", "emit", "_touchmoveHandler", "getActualTouchTarget", "getCellElement", "preventDefault", "_leaveHandler", "relatedTarget", "_mousedownHandler", "_mouseupHandler", "cellElement", "closest", "nativeElement", "_touchendHandler", "_id", "_startDateLabelId", "_endDateLabelId", "runOutsideAngular", "element", "addEventListener", "isBrowser", "window", "startValue", "endValue", "ngOnChanges", "columnChanges", "rows", "_firstRowOffset", "length", "_cellWidth", "ngOnDestroy", "removeEventListener", "rowIndex", "colIndex", "cellNumber", "movePreview", "onStable", "pipe", "take", "subscribe", "setTimeout", "querySelector", "focus", "_scheduleFocusActiveCellAfterViewChecked", "isStart", "isEnd", "isInRange", "previousCell", "previousRow", "nextCell", "nextRow", "row", "getAttribute", "col", "parseInt", "ElementRef", "NgZone", "cmp", "selectors", "hostAttrs", "inputs", "label", "labelMinRequiredCells", "outputs", "exportAs", "features", "dependencies", "NgClass", "styles", "encapsulation", "changeDetection", "Component", "args", "selector", "host", "ViewEncapsulation", "None", "ChangeDetectionStrategy", "OnPush", "template", "Input", "Output", "isTableCell", "node", "nodeName", "parentNode", "rangeEnabled", "touchLocation", "changedTouches", "document", "elementFromPoint", "clientX", "clientY", "DateRange", "MatDateSelectionModel", "selection", "_adapter", "_selectionChanged", "selectionChanged", "updateSelection", "source", "oldValue", "next", "complete", "_isValidDateInstance", "date", "isDateInstance", "isValid", "MatSingleDateSelectionModel", "adapter", "add", "isComplete", "clone", "DateAdapter", "MatRangeDateSelectionModel", "compareDate", "MAT_SINGLE_DATE_SELECTION_MODEL_FACTORY", "parent", "MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER", "provide", "deps", "Optional", "SkipSelf", "useFactory", "MAT_RANGE_DATE_SELECTION_MODEL_FACTORY", "MAT_RANGE_DATE_SELECTION_MODEL_PROVIDER", "MAT_DATE_RANGE_SELECTION_STRATEGY", "InjectionToken", "DefaultMatCalendarRangeStrategy", "_dateAdapter", "selectionFinished", "currentRange", "createPreview", "activeDate", "createDrag", "dragOrigin", "originalRange", "newDate", "diffYears", "getYear", "diffMonths", "getMonth", "diffDays", "getDate", "sameDate", "addCalendarYears", "addCalendarMonths", "addCalendarDays", "MAT_CALENDAR_RANGE_STRATEGY_PROVIDER_FACTORY", "MAT_CALENDAR_RANGE_STRATEGY_PROVIDER", "DAYS_PER_WEEK", "MatMonthView", "_activeDate", "oldActiveDate", "validDate", "getValidDateOrNull", "deserialize", "today", "clampDate", "_hasSameMonthAndYear", "_init", "_selected", "_setRanges", "_minDate", "_maxDate", "_changeDetectorRef", "_dateFormats", "_dir", "_rangeStrategy", "_rerenderSubscription", "Subscription", "EMPTY", "activeDrag", "selectedChange", "_userSelection", "ngDevMode", "ngAfterContentInit", "localeChanges", "startWith", "comparisonChange", "firstChange", "_clearPreview", "unsubscribe", "selectedDate", "_getDateFromDayOfMonth", "rangeStartDate", "rangeEndDate", "_getDateInCurrentMonth", "markForCheck", "_updateActiveDate", "month", "_handleCalendarBodyKeydown", "isRtl", "_isRtl", "keyCode", "LEFT_ARROW", "RIGHT_ARROW", "UP_ARROW", "DOWN_ARROW", "HOME", "END", "getNumDaysInMonth", "PAGE_UP", "altKey", "PAGE_DOWN", "ENTER", "SPACE", "_selectionKeyPressed", "_canSelect", "ESCAPE", "_previewEnd", "hasModifierKey", "stopPropagation", "_handleCalendarBodyKeyup", "_todayDate", "_getCellCompareValue", "_monthLabel", "display", "monthLabel", "format", "getMonthNames", "toLocaleUpperCase", "firstOfMonth", "createDate", "_firstWeekOffset", "getDayOfWeek", "getFirstDayOfWeek", "_initWeekdays", "_createWeekCells", "_matCalendarBody", "_previewChanged", "previewRange", "_previewStart", "dragRange", "detectChanges", "dragDropResult", "dayOfMonth", "firstDayOfWeek", "narrowWeekdays", "getDayOfWeekNames", "longWeekdays", "weekdays", "map", "long", "i", "narrow", "_weekdays", "slice", "concat", "daysInMonth", "dateNames", "getDateNames", "_weeks", "push", "_shouldEnableDate", "dateA11yLabel", "cellClasses", "undefined", "d1", "d2", "year", "day", "Date", "getTime", "selectedValue", "_rangeStart", "_rangeEnd", "_isRange", "_comparisonRangeStart", "_comparisonRangeEnd", "ChangeDetectorRef", "MAT_DATE_FORMATS", "Directionality", "viewQuery", "MatMonthView_Query", "_t", "MatMonthView_Template_tbody_activeDateChange_7_listener", "MatMonthView_Template_tbody_previewChange_7_listener", "MatMonthView_Template_tbody_dragStarted_7_listener", "MatMonthView_Template_tbody_dragEnded_7_listener", "MatMonthView_Template_tbody_keyup_7_listener", "MatMonthView_Template_tbody_keydown_7_listener", "Inject", "ViewChild", "yearsPerPage", "yearsPerRow", "MatMultiYearView", "isSameMultiYearView", "_setSelectedYear", "yearSelected", "_todayYear", "activeYear", "minYearOfPage", "getActiveOffset", "_years", "_createCellForYear", "_yearSelected", "selectedYear", "_getDateFromYear", "_getActiveCell", "activeMonth", "normalizedDate", "Math", "min", "yearName", "getYearName", "_shouldEnableYear", "firstOfYear", "_selectedYear", "MatMultiYearView_Query", "MatMultiYearView_Template_tbody_activeDateChange_4_listener", "MatMultiYearView_Template_tbody_keyup_4_listener", "MatMultiYearView_Template_tbody_keydown_4_listener", "dateAdapter", "date1", "date2", "year1", "year2", "startingYear", "getStartingYear", "floor", "euclideanModulo", "maxYear", "a", "b", "MatYearView", "_setSelectedMonth", "monthSelected", "_monthSelected", "selectedMonth", "_getDateFromMonth", "_todayMonth", "_getMonthInCurrentYear", "_yearLabel", "monthNames", "_months", "_createCellForMonth", "monthName", "monthYearA11yLabel", "_shouldEnableMonth", "_isYearAndMonthAfterMaxDate", "_isYearAndMonthBeforeMinDate", "maxMonth", "minYear", "minMonth", "_selectedMonth", "MatYearView_Factory", "t", "MatYearView_Query", "MatYearView_Template_tbody_activeDateChange_4_listener", "MatYearView_Template_tbody_keyup_4_listener", "MatYearView_Template_tbody_keydown_4_listener", "calendarHeaderId", "MatCalendarHeader", "_intl", "calendar", "changeDetectorRef", "_periodButtonLabelId", "stateChanges", "periodButtonText", "currentView", "monthYearLabel", "_formatMinAndMaxYearLabels", "periodButtonDescription", "periodButtonLabel", "prevButtonLabel", "nextButtonLabel", "currentPeriodClicked", "previousClicked", "nextClicked", "previousEnabled", "_isSameView", "nextEnabled", "maxYearOfPage", "minYearLabel", "maxYearLabel", "forwardRef", "MatCalendar", "ngContentSelectors", "decls", "vars", "consts", "MatCalendarHeader_Template", "MatButton", "MatIconButton", "startAt", "_startAt", "_clampedActiveDate", "_currentView", "viewChangedResult", "_moveFocusOnNextTick", "viewChanged", "startView", "_userDragDrop", "_intlChanges", "_calendarHeaderPortal", "ComponentPortal", "headerComponent", "focusActiveCell", "minDateChange", "previousValue", "currentValue", "maxDateChange", "change", "view", "_getCurrentViewComponent", "updateTodaysDate", "normalizedYear", "normalizedMonth", "monthView", "yearView", "multiYearView", "MatCalendar_Factory", "MatCalendar_Query", "MatCalendar_contFlowTmp", "CdkMonitorFocus", "CdkPortalOutlet", "providers", "matDatepickerAnimations", "transformPanel", "trigger", "transition", "animate", "keyframes", "style", "opacity", "transform", "fadeInCalendar", "state", "datepickerUid", "MAT_DATEPICKER_SCROLL_STRATEGY", "MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY", "overlay", "scrollStrategies", "reposition", "MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER", "Overlay", "_MatDatepickerContentBase", "mixinColor", "MatDatepickerContent", "elementRef", "_globalModel", "_rangeSelectionStrategy", "intl", "_subscriptions", "_animationDone", "_isAnimating", "_actionsPortal", "_closeButtonText", "ngOnInit", "_animationState", "datepicker", "touchUi", "ngAfterViewInit", "_calendar", "_handleUserSelection", "_model", "newSelection", "close", "_handleUserDragDrop", "_startExitAnimation", "_handleAnimationEvent", "phaseName", "_getSelected", "_applyPendingSelection", "_assignActions", "portal", "forceRerender", "MatDatepickerContent_Factory", "MatDatepickerContent_Query", "MatDatepickerContent_animation_transformPanel_done_HostBindingHandler", "_selectYear", "MatDatepickerContent_Template_mat_calendar_monthSelected_1_listener", "_selectMonth", "MatDatepickerContent_Template_mat_calendar_viewChanged_1_listener", "_viewChanged", "MatDatepickerContent_Template_mat_calendar__userSelection_1_listener", "MatDatepickerContent_Template_mat_calendar__userDragDrop_1_listener", "MatDatepickerContent_Template_button_blur_3_listener", "_closeButtonFocused", "MatDatepickerContent_Template_button_click_3_listener", "tmp_3_0", "_dialogLabelId", "panelClass", "_getMinDate", "_getMaxDate", "_getDateFilter", "calendarHeaderComponent", "CdkTrapFocus", "data", "animation", "animations", "MatDatepickerBase", "datepickerInput", "getStartValue", "color", "_color", "getThemePalette", "_touchUi", "coerceBooleanProperty", "disabled", "_disabled", "newValue", "restoreFocus", "_restoreFocus", "_panelClass", "coerceStringArray", "opened", "_opened", "open", "max", "_overlay", "_viewContainerRef", "scrollStrategy", "_inputStateChanges", "_document", "DOCUMENT", "xPosition", "yPosition", "openedStream", "closedStream", "id", "_focusedElementBeforeOpen", "_backdropHarnessClass", "_scrollStrategy", "positionChange", "_overlayRef", "positionStrategy", "getConfig", "FlexibleConnectedPositionStrategy", "_setConnectedPositions", "updatePosition", "_destroyOverlay", "select", "registerInput", "input", "registerActions", "_componentRef", "instance", "removeActions", "_getFocusedElementPierceShadowDom", "_openOverlay", "canRestoreFocus", "completeClose", "location", "activeElement", "contains", "_forwardContentValues", "getOverlayLabelId", "isDialog", "overlayRef", "create", "OverlayConfig", "_getDialogStrategy", "_getDropdownStrategy", "hasBackdrop", "backdropClass", "direction", "block", "_getCloseStream", "keydownEvents", "attach", "dispose", "position", "global", "centerHorizontally", "centerVertically", "strategy", "flexibleConnectedTo", "getConnectedOverlayOrigin", "withTransformOriginOn", "withFlexibleDimensions", "withViewportMargin", "withLockedPosition", "primaryX", "secondaryX", "primaryY", "secondaryY", "withPositions", "originX", "originY", "overlayX", "overlayY", "ctrlShiftMetaModifiers", "merge", "backdropClick", "detachments", "filter", "every", "modifier", "MatDatepickerBase_Factory", "ViewContainerRef", "Directive", "MatDatepicker", "useExisting", "MatDatepickerInputEvent", "targetElement", "MatDatepickerInputBase", "_getValueFromModel", "_pendingValue", "_assignValueProgrammatically", "_parentDisabled", "_isInitialized", "blur", "_getValidators", "_parseValidator", "_minValidator", "_maxValidator", "_filterValidator", "_registerModel", "model", "_valueChangesSubscription", "_assignValue", "_shouldHandleChangeEvent", "_lastValueValid", "_isValidValue", "_cvaOnChange", "_onTouched", "_formatValue", "dateInput", "dateChange", "_validatorOnChange", "_localeSubscription", "control", "controlValue", "_matchesFilter", "dateInputsHaveChanged", "registerOnValidatorChange", "fn", "validate", "c", "_validator", "writeValue", "registerOnChange", "registerOnTouched", "setDisabledState", "isDisabled", "_onKeydown", "isAltDownArrow", "readOnly", "_openPopup", "_onInput", "lastValueWasValid", "parse", "hasChanged", "_onChange", "_onBlur", "_assignValueToModel", "MatDatepickerInputBase_Factory", "keys", "Object", "key", "MAT_DATEPICKER_VALUE_ACCESSOR", "NG_VALUE_ACCESSOR", "MatDatepickerInput", "multi", "MAT_DATEPICKER_VALIDATORS", "NG_VALIDATORS", "matDatepicker", "_datepicker", "_closedSubscription", "_min", "validValue", "_max", "_dateFilter", "wasMatchingValue", "dateFormats", "_formField", "Validators", "compose", "getLabelId", "modelValue", "MAT_FORM_FIELD", "dir", "hostVars", "hostBindings", "MatDatepickerInput_HostBindings", "MatDatepickerInput_change_HostBindingHandler", "MatDatepickerInput_blur_HostBindingHandler", "MatDatepickerInput_keydown_HostBindingHandler", "MAT_INPUT_VALUE_ACCESSOR", "MatDatepickerToggleIcon", "MatDatepickerToggle", "defaultTabIndex", "_stateChanges", "parsedTabIndex", "Number", "tabIndex", "_watchStateChanges", "_open", "datepickerStateChanged", "of", "inputStateChanged", "datepickerToggled", "MatDatepickerToggle_Factory", "contentQueries", "MatDatepickerToggle_ContentQueries", "dirIndex", "disableRipple", "Attribute", "_customIcon", "ContentChild", "_button", "_computeAriaAccessibleName", "_computeAriaAccessibleNameInternal", "ssrSafeIsElement", "nodeType", "Node", "ELEMENT_NODE", "ssrSafeIsHTMLInputElement", "ssrSafeIsHTMLTextAreaElement", "currentNode", "isDirectlyReferenced", "labelledbyIds", "split", "validIdRefs", "reduce", "validIds", "elem", "getElementById", "idRef", "join", "trim", "labels", "Array", "from", "x", "placeholder", "title", "textContent", "replace", "MAT_DATE_RANGE_INPUT_PARENT", "MatDateRangeInputPartBase", "_rangeInput", "_defaultErrorStateMatcher", "_injector", "_parentForm", "_parentFormGroup", "optional", "ngControl", "get", "NgControl", "self", "ngDoCheck", "updateErrorState", "isEmpty", "_getPlaceholder", "getMirrorValue", "_handleChildValueChange", "_openDatepicker", "_groupDisabled", "_startInput", "_endInput", "opposite", "_getAccessibleName", "ErrorStateMatcher", "Injector", "NgForm", "FormGroupDirective", "_MatDateRangeInputBase", "mixinErrorState", "MatStartDate", "rangeInput", "defaultErrorStateMatcher", "injector", "parentForm", "parentFormGroup", "_startValidator", "range", "endInput", "isLtr", "selectionStart", "selectionEnd", "setSelectionRange", "MatStartDate_HostBindings", "MatStartDate_change_HostBindingHandler", "MatStartDate_keydown_HostBindingHandler", "MatStartDate_blur_HostBindingHandler", "MatEndDate", "_endValidator", "startInput", "BACKSPACE", "endPosition", "MatEndDate_HostBindings", "MatEndDate_change_HostBindingHandler", "MatEndDate_keydown_HostBindingHandler", "MatEndDate_blur_HostBindingHandler", "nextUniqueId", "MatDateRangeInput", "shouldLabelFloat", "focused", "empty", "separator", "rangePicker", "_rangePicker", "required", "_required", "_isTargetRequired", "wasMatchingStart", "wasMatchingEnd", "_revalidate", "errorState", "startEmpty", "endEmpty", "controlType", "_ariaDescribedBy", "classList", "setDescribedByIds", "ids", "onContainerClick", "_getInputMirrorValue", "part", "_shouldHidePlaceholders", "_shouldHideSeparator", "_shouldLabelFloat", "_getAriaLabelledby", "formField", "_hasFloatingLabel", "_labelId", "_getStartDateAccessibleName", "_getEndDateAccessibleName", "_updateFocus", "origin", "hasValidator", "MatDateRangeInput_Factory", "ControlContainer", "MatDateRangeInput_ContentQueries", "MatDateRangeInput_HostBindings", "MatFormFieldControl", "Self", "MatDateRangePicker", "MatDatepickerApply", "_applySelection", "MatDatepickerApply_HostBindings", "MatDatepickerCancel", "MatDatepickerCancel_HostBindings", "MatDatepickerActions", "_portal", "TemplatePortal", "_template", "isAttached", "detach", "MatDatepickerActions_Query", "TemplateRef", "MatDatepickerModule", "mod", "declarations", "imports", "CommonModule", "MatButtonModule", "OverlayModule", "A11yModule", "PortalModule", "MatCommonModule", "exports", "CdkScrollableModule", "inj", "NgModule"]
}
